/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build-browser.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js":
/*!*************************************************!*\
  !*** (webpack)/node_modules/process/browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///(webpack)/node_modules/process/browser.js?");

/***/ }),

/***/ "./build-browser.js":
/*!**************************!*\
  !*** ./build-browser.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * @module libbetter\n * @sub-module BetterLog\n * @sub-module BetterEvents\n * @sub-module BetterUtil.browser\n * @description This file can be built with webpack to create a file that can be loaded directly\n *\t\t\t\tby the browser in a <script>. It will make the sub-modules available on window\n *\n * @author plundell\n * @license MIT\n */\n\n\n//This will set window.BetterLog\n__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './log'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nwindow.BetterLog._env='browser';\n\n//This will set window.BetterEvents\n__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './events'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n//This will set window.BetterUtil\n__webpack_require__(/*! ./util/bu-browser.js */ \"./util/bu-browser.js\")(window);\n\n//# sourceURL=webpack:///./build-browser.js?");

/***/ }),

/***/ "./util/browser/domevents.util.js":
/*!****************************************!*\
  !*** ./util/browser/domevents.util.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/browser/domevents.util.js\n//simpleSourceMap2=/lib/util/browser/domevents.util.js\n;'use strict';\n/*\n* @module bu-browser-events\n* @author plundell\n* @license MIT\n* @description Helper functions related to DOM events\n*\n* This module is required by bu-browser\n*/\nmodule.exports=function export_mobX({cX,_log,elemX}){\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\tmarkInputting\n\t\t,throttleInput\n\t}\n\t\t\n\t/*\n\t* Monitor 'input' events on <body>, setting .inputting=function and attribute flag 'inputting' on target elem WHILE \n\t* these events are firing in rapid succession\n\t*\n\t* @param number timeout \tHow long to apply the 'inputting' flag after the last 'input' has been fired\n\t*\n\t* @return function \t\t\tCallback which removes this functionality\n\t*/\n\tvar unmark;\n\tfunction markInputting(timeout=100){\n\t\t//If this was previously called, just remove the listener and add it again\n\t\tif(unmark){\n\t\t\t_log.note(\"You were already marking inputs. Removing that and running again. Check that you want\"\n\t\t\t\t+\" to be calling it this many times.\");\n\t\t\tunmark();\n\t\t\tunmark=null;\n\t\t}\n\n\t\tvar lastInput\n\t\t\t,callback=function(event){\n\t\t\t\tlet target=event.target;\n\t\t\t\t//On the 'input' from a new target, just get ready for additional ones. By not setting anything this time we avoid\n\t\t\t\t//doing anything when eg. a <select> changed once\n\t\t\t\tif(event.target!=lastInput){\n\t\t\t\t\t//Before loosing reference to it, timeout the old input\n\t\t\t\t\tif(lastInput && lastInput.inputting){\n\t\t\t\t\t\tlastInput.inputting.expire();\n\t\t\t\t\t}\n\t\t\t\t\tlastInput=event.target;\n\n\t\t\t\t\t//Now prepare the new input...\n\t\t\t\t\tevent.target.inputting=cX.betterTimeout(function(){\n\t\t\t\t\t\tevent.target.removeAttribute('inputting');\n\t\t\t\t\t\tdelete event.target.inputting;\n\t\t\t\t\t},timeout)\n\n\t\t\t\t\t//...then set the flag\n\t\t\t\t\tevent.target.setAttribute('inputting','');\n\t\t\t\t\t\n\t\t\t\t}else if(event.target.inputting){\n\t\t\t\t\t//Push the timeout to the future\n\t\t\t\t\tevent.target.inputting.postpone();\n\t\t\t\t}\n\t\t\t\t//If it's already expired then do nothing...\n\t\t\t}\n\t\t\t,options={capture:true, passive:true};\n\t\t;\n\t\t\n\t\t//Now add the listener...\n\t\tdocument.body.addEventListener('input',callback,options)\n\n\t\t//...then return another function that can be used once to remove it (additional calls will just be ignored)\n\t\tunmark=cX.once(function unmarkInputting(){document.body.removeEventListener('input',callback,options);});\n\t\treturn unmark;\n\t}\n\n\n\t/*\n\t* Throttle an input so it only emits 'input' events so often\n\t*\n\t* @param <HTMLElement> elem\n\t* @param number delay \t\t\tHow often to emit 'input' at most\n\t*\n\t* @return function \t\t\t\tA function to remove the throttle\n\t*/\n\tfunction throttleInput(elem,delay=100){\n\t\tcX.checkType(['node','number'],arguments);\n\t\t\n\t\tvar timeout=cX.betterTimeout(delay,elem,elem.dispatchEvent);\n\t\t\n\t\tfunction throttledInput(event){\n\t\t\tif(!event.throttled){\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\tevent.throttled=true;\n\t\t\t\ttimeout.throttle(event);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlet options={capture:true};\n\t\telem.addEventListener('input',throttledInput,options)\n\n\t\treturn function unthrottleInput(){elem.removeEventListener('input',throttledInput,options)};\n\t}\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/browser/domevents.util.js?");

/***/ }),

/***/ "./util/browser/elements.util.js":
/*!***************************************!*\
  !*** ./util/browser/elements.util.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("throw new Error(\"Module parse failed: Identifier 'date' has already been declared (672:6)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\t\\tfieldset.appendChild(date);\\n| \\n> \\t\\tlet date=document.createElement('input');\\n| \\t\\tdate.type='time'\\n| \\t\\tfieldset.appendChild(time);\");\n\n//# sourceURL=webpack:///./util/browser/elements.util.js?");

/***/ }),

/***/ "./util/browser/mobile.util.js":
/*!*************************************!*\
  !*** ./util/browser/mobile.util.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/browser/mobile.util.js\n//simpleSourceMap2=/lib/util/browser/mobile.util.js\n/*\n* @module bu-browser-styling\n* @author plundell\n* @license MIT\n* @description Helper functions related to mobile devices, like touch etc\n*\n* This module is required by bu-browser\n*/\n;'use strict';\nmodule.exports=function export_mobX({cX,_log,elemX}){\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\t'detectSwipe':detectSwipe\n\t\t,'getZoom':getZoom\n\t}\n\t\t\n\n\t/*\n\t 2020-03-16: \n\t There is something called 'passive events', supported by some browsers, not others. In supported \n\t browsers addEventListener()'s 3rd arg is an options object, while in the rest it is just checked for\n\t truthy to determine if the event should bubble or not. Therefore we need to know if the current \n\t browser supports it so we can act accordingly when eg detecting swipes.\n\t\t https://developers.google.com/web/tools/lighthouse/audits/passive-event-listeners\n\t\t https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n\t\t https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n\t*/\n\t// Test via a getter in the options object to see if the passive property is accessed\n\tvar supportsPassive = false;\n\ttry {\n\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tsupportsPassive = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener(\"testPassive\", null, opts);\n\t\twindow.removeEventListener(\"testPassive\", null, opts);\n\t} catch (e) {}\n\n\n\n\n\t/* \n\t* Call a func on left/right/up/down swipes\n\t* Based on this answer by 'Ulysse BN': \n\t* \thttps://stackoverflow.com/questions/15084675/how-to-implement-swipe-gestures-for-mobile-devices/58719294#58719294\n\t*\n\t* NOTE: params can be passed in any order\n\t*\n\t* @opt string|node elem \t@see getLiveElement(). Defaults to the window element\n\t* @param function cb \t\tFunction called on swipe with single string 'up','down','right' or 'left'\n\t* @param number deltaMin \tSwipe distance required to trigger. Near 0 it will almost always trigger, with a big value \n\t*\t\t\t\t\t\t\tit can never trigger.\n\t* @param bool preventScroll Default false.\n\t*/\n\tfunction detectSwipe(...args) {\n\t\t//First get the args\n\t\tvar cb=cX.getFirstOfType(args,'function')||_log.makeError('No callback function given').setCode('EINVAL').throw();\n\t\tvar elem=elemX.getLiveElement(cX.getFirstOfType(args,'node')||cX.getFirstOfType(args,'string')||window); //should not throw...\n\t\tvar deltaMin=cX.getFirstOfType(args,'number')||90;\n\t\tvar preventScroll=cX.getFirstOfType(args,'boolean')||false;\n\n\n\t\t//2020-03-16: See above\n\t\tvar passiveOrBubble=(supportsPassive ? {passive:true,capture:false} : false);\n\t\t\n\t\t//Define vars that will store where touches start and end\n\t\tvar startX=0,startY=0,endX=0,endY=0;\n\n\t\t//Now listen for the start and end events...\n\n\t\telem.addEventListener('touchstart', function ontouchstart(e) {\n\t\t\t//Set start AND end positions to the same thing... so if we don't move at all it won't look like we have...\n\t\t\tendX=startX=e.touches[0].screenX\n\t\t\tendY=startY=e.touches[0].screenY\n\t\t\t// console.log('start','x:',startX,'y:',startY)\n\n\t\t\t//If we're preventing scroll, we only have to call preventDefault() once on the first move event\n\t\t\tif(preventScroll){\n\t\t\t\t//'once' listener that works in all situations\n\t\t\t\tvar preventScroll=function(e){e.preventDefault();elem.removeEventListener('touchmove',preventScroll)}\n\t\t\t\telem.addEventListener('touchmove',preventScroll)\n\t\t\t}\n\t\t}, passiveOrBubble)\n\n\n\t\telem.addEventListener('touchend', function ontouchend(e) {\n\t\t\t//Now record the end positions\n\t\t\tendX = e.changedTouches[0].screenX\n\t\t\tendY = e.changedTouches[0].screenY\n\t\t\t\t//unlike touchstart, here 'touches' is an empty array...\n\n\t\t\t//Get the traveled distance along each axis and determine what to call the callback with (if the swipe is \n\t\t\t//diaganol it may very well be called twice)\n\t\t\tlet deltaX=endX-startX, deltaY=endY-startY;\n\t\t\t// console.log('end','x:',endX,'y:',endY)\n\n\t\t\tvar swipe=false;\n\t\t\tif(Math.abs(deltaX)>deltaMin){\n\t\t\t\tswipe=true;\n\t\t\t\tlet d= deltaX > 0 ? 'right' : 'left';\n\t\t\t\t_log.debug(\"detected swipe \"+d,{deltaX,deltaMin});\n\t\t\t\tcb(d);\n\t\t\t}\n\n\t\t\tif(Math.abs(deltaY)>deltaMin){\n\t\t\t\tswipe=true;\n\t\t\t\tlet d= deltaY > 0 ? 'up' : 'down';\n\t\t\t\t_log.debug(\"detected swipe \"+d,{deltaY,deltaMin});\n\t\t\t\tcb(d);\n\t\t\t}\n\n\t\t\t//If no swipe happened, but we DID move our finger... just say so...\n\t\t\tif(!swipe && (deltaY || deltaX)){\n\t\t\t\t_log.trace(\"no swipe, too short...\",{deltaX,deltaY,deltaMin});\n\t\t\t}\n\t\t}, passiveOrBubble)\n\t}\n\n\n\t/*\n\t* Get the current zoom level \n\t*\n\t* @return number  Decimal number of zoom, 1 == 100%\n\t*/\n\tfunction getZoom(){\n\t\t\treturn document.documentElement.clientWidth/window.innerWidth\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/browser/mobile.util.js?");

/***/ }),

/***/ "./util/browser/rest.util.js":
/*!***********************************!*\
  !*** ./util/browser/rest.util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/browser/rest.util.js\n//simpleSourceMap2=/lib/util/browser/rest.util.js\n/*\n* @module bu-browser-rest\n* @author plundell\n* @license MIT\n* @description Helper functions related to RESTful api calls\n*\n* This module is required by bu-browser\n*/\n;'use strict';\nmodule.exports=function export_restX({cX,_log}){\n\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\t'POST':POST\n\t\t// ,'queryStrToObj':queryStrToObj\n\t\t// ,'objToQueryStr':objToQueryStr\n\t}\n\t\t\n\n\n\t/*\n\t* Post an object and get a response\n\t*\n\t* Details and examples can be found here:\n\t* https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n\t*\n\t* @param string target \t\t\t\t\tWhere to send the data, usually a file on the server\n\t* @param primitive|object|array data \tThe data to send. It will be json stringified\n\t* @param @opt <BetterLog> log \t\t\tThe log to use\n\t*\n\t* @return Promise(mixed,err) \t\t\tA promise that resolves when a successfull response arrives, \n\t*\t\t\t\t\t\t\t\t\t\tor rejects in all other cases with one of these codes:\n\t*\t\t\t\t\t\t\t\t\t\t\tTypeError \t\t- The passed in args where bad\n\t*\t\t\t\t\t\t\t\t\t\t\tclienterror  \t- request never left this computer\n\t*\t\t\t\t\t\t\t\t\t\t\tservererror \t- Server responded with a negative response \n\t*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(see err.msg + err.status)\n\t*\t\t\t\t\t\t\t\t\t\t\tabort \t\t\t- The request was aborted before full response\n\t*\t\t\t\t\t\t\t\t\t\t\ttimeout \t\t- The request timed out\n\t*\t\t\t\t\t\t\t\t\t\t\tBUGBUG \t\t\t- Should not happen. Some error with this code\n\t* @logged\n\t*/\n\tfunction POST(target,data,log){\n\t\t\n\t\t//Use the passed in log or the util log\n\t\tif(!_log._isLog(log))\n\t\t\tlog=_log\n\t\t\n\t\tif(typeof target!='string')\n\t\t\treturn log.rejectType('arg#1 to be string target, eg. api.php',target);\n\t\t\n\t\t//Create promise we'll return\n\t\tvar {promise,resolve,reject,inspect}=xxx.util.exposedPromise();\n\n\t\ttry{\n\t\t\tvar xhr = new XMLHttpRequest();\n\n\t\t\t//First set event listeners\n\t\t//2020-02-20: Is this v correct? Because 'loadend' loads after error AND when load is complete, so maybe 'error'\n\t\t//\t\t\t\thappens even on bad responses??\n\t\t\t// xhr.addEventListener('error',function POST_error(err){\n\t\t\t// \treject(log.makeError('Failed to make request (ie. nothing left this computer)',err).setCode('clienterror').exec());\n\t\t\t// })\n\t\t\txhr.addEventListener('abort',function POST_abort(err){\n\t\t\t\treject(log.makeError('Request aborted.',err).setCode('abort').exec());\n\t\t\t})\n\t\t\txhr.addEventListener('timeout',function POST_timeout(err){\n\t\t\t\t//don't know if error is also fired\n\t\t\t\treject(log.makeError('Request timed out.',err).setCode('timeout').exec());\n\t\t\t})\n\t\t\txhr.addEventListener('loadend',function POST_load(){\n\t\t\t\tif(this.status>=200 && this.status<300){\n\t\t\t\t\tlog.info(`Got successfull ${this.status} response from ${target}:`,this.response);\n\t\t\t\t\tresolve(this.response);\n\t\t\t\t}else if(inspect.status=='pending'){\n\t\t\t\t\tvar err=log.makeError(target)\n\t\t\t\t\t\t.setCode(this.status)\n\t\t\t\t\t\t.somewhere(this.response)\n\t\t\t\t\t;\n\t\t\t\t\treject(err);\t\t\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t//Then make the request\n\t\t\tlog.info(`About to POST to ${target}:`,data);\n\t\t\tlet payload=JSON.stringify(data);\n\t\t\txhr.open(\"POST\", target, true); //true==async\n\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\t\t\txhr.send(payload); //ProTip: Chrome will console.error this by default. You can turn it off in DevTools 3-dots\n\n\t\t}catch(err){\n\t\t\treject(log.makeError(err).setCode('BUGBUG').exec());\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n\n\n//# sourceURL=webpack:///./util/browser/rest.util.js?");

/***/ }),

/***/ "./util/browser/styling.util.js":
/*!**************************************!*\
  !*** ./util/browser/styling.util.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/browser/styling.util.js\n//simpleSourceMap2=/lib/util/browser/styling.util.js\n\n/*\n* @module bu-browser-styling\n* @author plundell\n* @license MIT\n* @description Helper functions related to css styling\n*\n* This module is required by bu-browser\n*/\nmodule.exports=function export_styleX({cX,_log,elemX}){\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\t'increaseBrightness':increaseBrightness\n\t\t,'scrollBarWidth':scrollBarWidth\n\t\t,'colorNameToHex':colorNameToHex\n\t\t,'createCSSRule':createCSSRule\n\t\t,appendCSSRule\n\t\t,findCSSRule\n\t\t,getSameOriginStylesheets\n\t}\n\t  \n\n\n\tfunction increaseBrightness(hex, percent){\n\t\t// strip the leading # if it's there\n\t\thex = hex.replace(/^\\s*#|\\s*$/g, '');\n\n\t\t// convert 3 char codes --> 6, e.g. `E0F` --> `EE00FF`\n\t\tif(hex.length == 3){\n\t\t\thex = hex.replace(/(.)/g, '$1$1');\n\t\t}\n\n\t\tvar r = parseInt(hex.substr(0, 2), 16),\n\t\t\tg = parseInt(hex.substr(2, 2), 16),\n\t\t\tb = parseInt(hex.substr(4, 2), 16);\n\n\t\tpercent=percent/100\n\t\treturn '#' +\n\t\t   ((0|(1<<8) + r + (256 - r) * percent ).toString(16)).substr(1) +\n\t\t   ((0|(1<<8) + g + (256 - g) * percent ).toString(16)).substr(1) +\n\t\t   ((0|(1<<8) + b + (256 - b) * percent ).toString(16)).substr(1);\n\t}\n\n\n\tfunction scrollBarWidth(){\n\t  \tvar scrollDiv = document.createElement(\"div\");\n\t  \tscrollDiv.style = \"width: 100px;\"\n\t\t\t\t\t   +\"height: 100px;\"\n\t\t\t\t\t   +\"overflow: scroll;\"\n\t\t\t\t\t   +\"position: absolute;\"\n\t\t\t\t\t   +\"top: -9999px;\"\n\t  \t;\n\t  \tdocument.body.appendChild(scrollDiv);\n\n\t\t// Get the scrollbar width\n\t\tvar scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n\t\t// Delete the DIV \n\t\tdocument.body.removeChild(scrollDiv);\n\n\t\treturn scrollbarWidth;\n\t}\n\n\n\tfunction colorNameToHex(name){\n\t\tname=name.toUpperCase();\n\t\tif(colors.hasOwnProperty(name))\n\t\t\treturn colors[name];\n\t\telse\n\t\t\treturn colors['GRAY'];\n\t}\n\n\tvar colors={\n\t\t\"WHITE\":\"#FFFFFF\"\n\t\t,\"AZURE\":\"#FFFFFF\"\n\t\t,\"MINTCREAM\":\"#FFFFFF\"\n\t\t,\"SNOW\":\"#FFFFFF\"\n\t\t,\"IVORY\":\"#FFFFFF\"\n\t\t,\"GHOSTWHITE\":\"#FFFFFF\"\n\t\t,\"FLORALWHITE\":\"#FFFFFF\"\n\t\t,\"ALICEBLUE\":\"#FFFFFF\"\n\t\t,\"LIGHTCYAN\":\"#CCFFFF\"\n\t\t,\"HONEYDEW\":\"#FFFFFF\"\n\t\t,\"LIGHTYELLOW\":\"#FFFFFF\"\n\t\t,\"SEASHELL\":\"#FFFFFF\"\n\t\t,\"LAVENDERBLUSH\":\"#FFFFFF\"\n\t\t,\"WHITESMOKE\":\"#FFFFFF\"\n\t\t,\"OLDLACE\":\"#FFFFFF\"\n\t\t,\"CORNSILK\":\"#FFFFCC\"\n\t\t,\"LINEN\":\"#FFFFFF\"\n\t\t,\"LIGHTGOLDENRODYELLOW\":\"#FFFFCC\"\n\t\t,\"LEMONCHIFFON\":\"#FFFFCC\"\n\t\t,\"BEIGE\":\"#FFFFCC\"\n\t\t,\"LAVENDER\":\"#CCCCFF\"\n\t\t,\"PAPAYAWHIP\":\"#FFFFCC\"\n\t\t,\"MISTYROSE\":\"#FFCCCC\"\n\t\t,\"ANTIQUEWHITE\":\"#FFFFCC\"\n\t\t,\"BLANCHEDALMOND\":\"#FFFFCC\"\n\t\t,\"BISQUE\":\"#FFFFCC\"\n\t\t,\"PALETURQUOISE\":\"#99FFFF\"\n\t\t,\"MOCCASIN\":\"#FFCCCC\"\n\t\t,\"GAINSBORO\":\"#CCCCCC\"\n\t\t,\"PEACHPUFF\":\"#FFCCCC\"\n\t\t,\"NAVAJOWHITE\":\"#FFCC99\"\n\t\t,\"PALEGOLDENROD\":\"#FFFF99\"\n\t\t,\"WHEAT\":\"#FFCCCC\"\n\t\t,\"POWDERBLUE\":\"#CCCCFF\"\n\t\t,\"AQUAMARINE\":\"#66FFCC\"\n\t\t,\"LIGHTGREY\":\"#CCCCCC\"\n\t\t,\"PINK\":\"#FFCCCC\"\n\t\t,\"LIGHTBLUE\":\"#99CCFF\"\n\t\t,\"THISTLE\":\"#CCCCCC\"\n\t\t,\"LIGHTPINK\":\"#FFCCCC\"\n\t\t,\"LIGHTSKYBLUE\":\"#99CCFF\"\n\t\t,\"PALEGREEN\":\"#99FF99\"\n\t\t,\"LIGHTSTEELBLUE\":\"#99CCCC\"\n\t\t,\"KHAKI\":\"#FFCC99\"\n\t\t,\"SKYBLUE\":\"#99CCFF\"\n\t\t,\"AQUA\":\"#00FFFF\"\n\t\t,\"CYAN\":\"#00FFFF\"\n\t\t,\"SILVER\":\"#CCCCCC\"\n\t\t,\"PLUM\":\"#CC99CC\"\n\t\t,\"GRAY\":\"#CCCCCC\"\n\t\t,\"LIGHTGREEN\":\"#99FF99\"\n\t\t,\"VIOLET\":\"#FF99FF\"\n\t\t,\"YELLOW\":\"#FFFF00\"\n\t\t,\"TURQUOISE\":\"#33CCCC\"\n\t\t,\"BURLYWOOD\":\"#CCCC99\"\n\t\t,\"GREENYELLOW\":\"#99FF33\"\n\t\t,\"TAN\":\"#CCCC99\"\n\t\t,\"MEDIUMTURQUOISE\":\"#33CCCC\"\n\t\t,\"LIGHTSALMON\":\"#FF9966\"\n\t\t,\"MEDIUMAQUAMARINE\":\"#66CC99\"\n\t\t,\"DARKGRAY\":\"#999999\"\n\t\t,\"ORCHID\":\"#CC66CC\"\n\t\t,\"DARKSEAGREEN\":\"#99CC99\"\n\t\t,\"DEEPSKYBLUE\":\"#00CCFF\"\n\t\t,\"SANDYBROWN\":\"#FF9966\"\n\t\t,\"GOLD\":\"#FFCC00\"\n\t\t,\"MEDIUMSPRINGGREEN\":\"#00FF99\"\n\t\t,\"DARKKHAKI\":\"#CCCC66\"\n\t\t,\"CORNFLOWERBLUE\":\"#6699FF\"\n\t\t,\"HOTPINK\":\"#FF66CC\"\n\t\t,\"DARKSALMON\":\"#FF9966\"\n\t\t,\"DARKTURQUOISE\":\"#00CCCC\"\n\t\t,\"SPRINGGREEN\":\"#00FF66\"\n\t\t,\"LIGHTCORAL\":\"#FF9999\"\n\t\t,\"ROSYBROWN\":\"#CC9999\"\n\t\t,\"SALMON\":\"#FF9966\"\n\t\t,\"CHARTREUSE\":\"#66FF00\"\n\t\t,\"MEDIUMPURPLE\":\"#9966CC\"\n\t\t,\"LAWNGREEN\":\"#66FF00\"\n\t\t,\"DODGERBLUE\":\"#3399FF\"\n\t\t,\"YELLOWGREEN\":\"#99CC33\"\n\t\t,\"PALEVIOLETRED\":\"#CC6699\"\n\t\t,\"MEDIUMSLATEBLUE\":\"#6666FF\"\n\t\t,\"MEDIUMORCHID\":\"#CC66CC\"\n\t\t,\"CORAL\":\"#FF6666\"\n\t\t,\"CADETBLUE\":\"#669999\"\n\t\t,\"LIGHTSEAGREEN\":\"#339999\"\n\t\t,\"GOLDENROD\":\"#CC9933\"\n\t\t,\"ORANGE\":\"#FF9900\"\n\t\t,\"LIGHTSLATEGRAY\":\"#669999\"\n\t\t,\"FUCHSIA\":\"#FF00FF\"\n\t\t,\"MAGENTA\":\"#FF00FF\"\n\t\t,\"MEDIUMSEAGREEN\":\"#33CC66\"\n\t\t,\"PERU\":\"#CC9933\"\n\t\t,\"STEELBLUE\":\"#3399CC\"\n\t\t,\"ROYALBLUE\":\"#3366CC\"\n\t\t,\"SLATEGRAY\":\"#669999\"\n\t\t,\"TOMATO\":\"#FF6633\"\n\t\t,\"DARKORANGE\":\"#FF9900\"\n\t\t,\"SLATEBLUE\":\"#6666CC\"\n\t\t,\"LIMEGREEN\":\"#33CC33\"\n\t\t,\"LIME\":\"#00FF00\"\n\t\t,\"INDIANRED\":\"#CC6666\"\n\t\t,\"DARKORCHID\":\"#9933CC\"\n\t\t,\"BLUEVIOLET\":\"#9933FF\"\n\t\t,\"DEEPPINK\":\"#FF0099\"\n\t\t,\"DARKGOLDENROD\":\"#CC9900\"\n\t\t,\"CHOCOLATE\":\"#CC6633\"\n\t\t,\"DARKCYAN\":\"#009999\"\n\t\t,\"DIMGRAY\":\"#666666\"\n\t\t,\"OLIVEDRAB\":\"#669933\"\n\t\t,\"SEAGREEN\":\"#339966\"\n\t\t,\"TEAL\":\"#009999\"\n\t\t,\"DARKVIOLET\":\"#9900CC\"\n\t\t,\"MEDIUMVIOLETRED\":\"#CC0066\"\n\t\t,\"ORANGERED\":\"#FF3300\"\n\t\t,\"OLIVE\":\"#999900\"\n\t\t,\"SIENNA\":\"#996633\"\n\t\t,\"DARKSLATEBLUE\":\"#333399\"\n\t\t,\"DARKOLIVEGREEN\":\"#666633\"\n\t\t,\"FORESTGREEN\":\"#339933\"\n\t\t,\"CRIMSON\":\"#CC0033\"\n\t\t,\"BLUE\":\"#0000FF\"\n\t\t,\"DARKMAGENTA\":\"#990099\"\n\t\t,\"DARKSLATEGRAY\":\"#336666\"\n\t\t,\"SADDLEBROWN\":\"#993300\"\n\t\t,\"BROWN\":\"#993333\"\n\t\t,\"FIREBRICK\":\"#993333\"\n\t\t,\"PURPLE\":\"#990099\"\n\t\t,\"GREEN\":\"#009900\"\n\t\t,\"RED\":\"#FF0000\"\n\t\t,\"MEDIUMBLUE\":\"#0000CC\"\n\t\t,\"INDIGO\":\"#330099\"\n\t\t,\"MIDNIGHTBLUE\":\"#000066\"\n\t\t,\"DARKGREEN\":\"#006600\"\n\t\t,\"DARKBLUE\":\"#000099\"\n\t\t,\"NAVY\":\"#000099\"\n\t\t,\"DARKRED\":\"#990000\"\n\t\t,\"MAROON\":\"#990000\"\n\t\t,\"BLACK\":\"#000000\"\n\t}\n\n\t/*\n\t* Add a rule to the first viable stylesheet of the document. Based on this answer: \n\t*\thttps://stackoverflow.com/a/8630641\n\t*\n\t* NOTE: There crossorigin issues with this, and different browsers handle it differently (eg. firefox\n\t*\t\tthrows and error, while chrome won't let you see those tags to begin with, so you can't\n\t*\t\tcause an error). Where this error is most likely to occur is with <style> tags as opposed to <link> \n\t*\t\ttags which seemingly are treated as a different origin\n\t* \n\t* @param string selector  Any css selector, ie. the part that comes before the {}\n\t* @param string style \t  Everything that goes between {} in a css file\n\t* @param boolean replace  If an identical selector already exists, replace it's contents\n\t*\n\t* @throw Error \t\tIf the document is not compatible with creating rules \n\t*\n\t* @return void\n\t*/\n\tfunction createCSSRule (selector, style, replace=false) {\n\t\tif(!document.styleSheets || document.getElementsByTagName('head').length == 0) \n\t\t\tthrow new Error(\"This document/browser doesn't support creating CSS selectors\");\n\n\t\t//Get a list of stylesheets that we are allowed to edit and that will affect the screen\n\t\tvar styleSheets=getSameOriginStylesheets().filter(ss=>{\n\t\t\t//Only include enabled stylesheets\n\t\t\tif(ss.disabled)\n\t\t\t\treturn false;\n\n\t\t\t//Only include those that affect screens (?? we may not want this behaviour)\n\t\t\tlet mediaText=typeof ss.media=='string' ? ss.media : ss.media.mediaText;\n\t\t\tif(!mediaText||mediaText=='all'||mediaText.indexOf('screen')>-1)\n\t\t\t\treturn true\n\t\t\telse\n\t\t\t\treturn false;\n\t\t});\n\n\n\t\t\n\t\ttry{\n\t\t\t//If we're replacing an existing rule, look through all rules in all stylesheets...\n\t\t\tif(replace){\n\t\t\t\tlet rule=findCSSRule(selector,styleSheets);\n\t\t\t\trule.cssText=style;\n\t\t\t\t_log.debug(\"Replaced existing CSS rule\",rule);\n\t\t\t\treturn rule;\n\t\t\t}\n\t\t}catch(err){\n\t\t\t_log.warn(\"Failed to replace existing rule, will try to append next...\",err);\n\t\t}\n\n\t\t//If none was found, try creating one as the last item of the last stylesheet (so it \n\t\t//gets highest priority)\n\t\ttry{\n\t\t\tlet sheet=styleSheets.pop();\n\t\t\tif(!sheet){\n\t\t\t\t_log.note(\"No style sheet found at all, is that correct?\");\n\t\t\t}else{\n\t\t\t\treturn appendCSSRule(sheet,selector,style);\n\t\t\t}\n\t\t}catch(err){\n\t\t\t_log.warn(\"Failed to add rule to existing stylesheet, will try creating own stylesheet next...\",err);\t\n\t\t}\n\n\t\t\t\n\t\t//If we're still running, this means we failed to use existing sheets, so create a new one\n\t\t//and insert the rule there\n\t\ttry{\n\t\t\tvar styleSheet = document.createElement('style');\n\t\t\tstyleSheet.type = 'text/css';\n\t\t\tdocument.head.appendChild(styleSheet);\n\t\t\treturn appendCSSRule(styleSheet,selector,style);\n\t\t}catch(err){\n\t\t\t_log.throw(\"Failed to create a CSS rule in an existing or new styleSheet.\",err);\n\t\t}\n\t}\n\n\n\t/*\n\t* Appends a CSS rule to the end of a stylesheet\n\t*\n\t* @param <HTMLElement>|<CSSStyleSheet> styleSheet\n\t* @param string selector\n\t* @param string style\n\t*\n\t* @throw <ble Error> \tIf no rule was appended\n\t*\n\t* @return <CSSRule>\n\t*/\n\tfunction appendCSSRule(styleSheet, selector, style){\n\t\t//If a live style elem is passed, just call this method again with the style sheet\n\t\tif(cX.varType(styleSheet)=='node'){\n\t\t\tif(styleSheet.sheet)\n\t\t\t\treturn appendCSSRule(styleSheet.sheet,selector,style);\n\t\t\telse\n\t\t\t\t_log.makeTypeError(\"a <style> elem\",styleSheet).throw();\n\t\t}\n\n\t\tcX.checkTypes(['<CSSStyleSheet>','string','string'],arguments);\n\n\t\tvar rule;\n\t\tif(typeof styleSheet.insertRule=='function'){ //modern version\n\t\t\tvar pos=styleSheet.insertRule(`${selector}{${style}}`, styleSheet.cssRules.length); //default to first, so we specify last\n\t\t\tif(pos!=styleSheet.cssRules.length-1)\n\t\t\t\t_log.warn(`A CSS rule was inserted at index ${pos}, which is not the end`,styleSheet.cssRules);\n\t\t\trule=styleSheet.cssRules[pos];\n\t\t}else if(typeof styleSheet.addRule=='function'){ //legacy from Microsoft\n\t\t\tstyleSheet.addRule(selector,style); //defaults to last position\n\t\t\trule=styleSheet.rules[styleSheet.length-1];\n\t\t}\n\t\tif(rule)\n\t\t\treturn rule;\n\t\telse\n\t\t\t_log.makeError('No rule was created. Dont know why? Called with:',arguments).throw();\n\t}\n\n\n\t/*\n\t* @param string selector\n\t* @opt array-like styleSheets \tThe style sheets to look through (remember, they need to be same origin)\n\t*\n\t* @return <CSSStyleRule>|undefined\n\t*/\n\tfunction findCSSRule(selector,styleSheets=null){\n\t\tstyleSheets=Array.from(styleSheets)||getSameOriginStylesheets();\n\t\tfor(var ss of styleSheets){\n\t\t\tlet rules=(typeof ss.media=='string' ? ss.rules : ss.cssRules), l=rules.length;\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tif(rules[i].selectorText && rules[i].selectorText.toLowerCase()==selector.toLowerCase()) {\n\t\t\t\t\treturn rules[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t* @return array[<StyleSheet>]\n\t*/\n\tfunction getSameOriginStylesheets(){\n\t\tif(!document.styleSheets || !document.styleSheets.length)\n\t\t\treturn [];\n\n\t\treturn Array.from(document.styleSheets).filter(ss=>{\n\t\t\ttry{\n\t\t\t\tss.cssRules||ss.rules\n\t\t\t\treturn true;\n\t\t\t}catch(err){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t})\n\t}\n\t/*\n\t* @return array[<StyleSheet>]\n\t*/\n\tfunction getSameOriginStylesheets2(){\n\t\tif(!document.styleSheets || !document.styleSheets.length)\n\t\t\treturn [];\n\n\t\t//Get the origin of this script\n\t\tlet origin=elemX.getOrigin(document.currentScript);\n\n\t\treturn Array.from(document.styleSheets).filter(ss=>origin==elemX.getOrigin(ss))\n\t}\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/browser/styling.util.js?");

/***/ }),

/***/ "./util/bu-browser.js":
/*!****************************!*\
  !*** ./util/bu-browser.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";'use strict';\n/**\n* @module bu-browser\n* @author plundell\n* @license MIT\n* @description Helper and utility functions for browsers\n*\n* This script should be bundled for the web with browserify or webpack\n*/\n\nmodule.exports=function exportBetterUtilBrowser(dep){\n\n    //Pass all deps straight on to cX\n    const cX=__webpack_require__(/*! ./bu-common.js */ \"./util/bu-common.js\")(dep);\n\n    //Rename the log\n    const _log = cX._log;\n    _log.changeName('BetterUtil');\n\n\t\n\tconst elemX=__webpack_require__(/*! ./browser/elements.util.js */ \"./util/browser/elements.util.js\")({cX,_log});\n\tconst styleX=__webpack_require__(/*! ./browser/styling.util.js */ \"./util/browser/styling.util.js\")({cX,_log,elemX});\n\tconst mobX=__webpack_require__(/*! ./browser/mobile.util.js */ \"./util/browser/mobile.util.js\")({cX,_log,elemX});\n\tconst restX=__webpack_require__(/*! ./browser/rest.util.js */ \"./util/browser/rest.util.js\")({cX,_log});\n    const evtX=__webpack_require__(/*! ./browser/domevents.util.js */ \"./util/browser/domevents.util.js\")({cX,_log,elemX});\n\t\n    //Combine everything onto the same object\n    var bu=Object.assign(cX,elemX,styleX,mobX,restX,evtX);\n\n    //Since this module is exclusivly used in the browser, we also set the exported\n    //object on the passed in one, that way if dep==window it will automatically be\n    //exposed globally (and if dep is just a temp object then no worries...)\n    dep.BetterUtil=bu;\n\n    return bu;\n\n}\n\n\n\n//# sourceURL=webpack:///./util/bu-browser.js?");

/***/ }),

/***/ "./util/bu-common.js":
/*!***************************!*\
  !*** ./util/bu-common.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n* @module bu-common\n* @author plundell\n* @description General purpose javascript utilities and helpers\n* @license MIT\n*\n* This file is meant to be 'required'. It in turn requires all util files in the 'common' folder \n* and re-exports them as one object.\n*\n* This module is required by bu-node and bu-browser which are probably the entry points you'll\n* want to use. \n*/\n\nmodule.exports=function exportBetterUtilCommon(dep){\n\t\n\t//The passed in object should contain all the dependencies.\n\tfunction missingDependency(which){throw new Error(\"BetterUtil is missing a dependency: \"+which);}\n\tconst BetterLog = dep.BetterLog || missingDependency('BetterLog');\n\tconst BetterEvents = dep.BetterEvents || missingDependency('BetterEvents');\n\n\t//Also make sure it contains two function we need\t\n\tvar {varType,logVar}=BetterLog;\n\tif(typeof varType!='function'||typeof logVar!='function'){\n\t\tconsole.error({\n\t\t\tvarType:[typeof varType,varType]\n\t\t\t,logVar:[typeof logVar,logVar]\n\t\t\t,BetterLog:[typeof BetterLog,BetterLog]\n\t\t});\n\t\tthrow new Error(\"BUGBUG: The BetterLog constructor didn't have prop-funcs varType and logVar\");\n\t}\n\n\tconst _log=new BetterLog('cX')\n\n\n\n\tconst vX=__webpack_require__(/*! ./common/vars.util.js */ \"./util/common/vars.util.js\")({varType,logVar,_log});\n\tconst aX=__webpack_require__(/*! ./common/arr.util.js */ \"./util/common/arr.util.js\")({vX,_log});\n\tconst fX=__webpack_require__(/*! ./common/functions.util.js */ \"./util/common/functions.util.js\")({vX,_log,aX});\n\tconst oX=__webpack_require__(/*! ./common/obj.util.js */ \"./util/common/obj.util.js\")({vX,_log});\n\tconst pX=__webpack_require__(/*! ./common/promise.util.js */ \"./util/common/promise.util.js\")({vX,_log});\n\tconst stX=__webpack_require__(/*! ./common/string.util.js */ \"./util/common/string.util.js\")({vX,_log});\n\tconst mX=__webpack_require__(/*! ./common/misc.util.js */ \"./util/common/misc.util.js\")({vX,_log, stX});\n\tconst tX=__webpack_require__(/*! ./common/time.util.js */ \"./util/common/time.util.js\")({vX,_log});\n\tconst netmask=__webpack_require__(/*! ./common/netmask.polyfill.js */ \"./util/common/netmask.polyfill.js\");\n\tconst validate=__webpack_require__(/*! ./common/validate.util.js */ \"./util/common/validate.util.js\")({netmask});\n\tconst Timer=__webpack_require__(/*! ./common/timer.class.js */ \"./util/common/timer.class.js\")({BetterLog,BetterEvents});\n\n\tconst cX=Object.assign(\n\t\t{\n\t\t\tvalidate\n\t\t\t,_log\n\t\t\t,netmask\n\t\t\t,Timer\n\t\t}\n\t\t,vX,aX,fX,oX,pX,stX,mX,tX\n\t)\n\n\treturn cX;\n}\n\n\n\n\n//# sourceURL=webpack:///./util/bu-common.js?");

/***/ }),

/***/ "./util/common/arr.util.js":
/*!*********************************!*\
  !*** ./util/common/arr.util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/common/arr.util.js\n//simpleSourceMap2=/lib/util/common/arr.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to ARRAYS\n*/\n;'use strict';\nmodule.exports=function export_aX({_log,vX}){\n\n\t//Methods to export\n\tvar _exports= {\n\t    'join':join\n\t    ,'uniqueArrayFilter':uniqueArrayFilter\n\t    ,'extractItem':extractItem\n\t    ,'extractItems':extractItems\n\t    ,'flatten':flatten\n\t    ,'rowsToString':rowsToString\n\t    ,'getFirstOfType':getFirstOfType\n\t    ,'arrayDiff':arrayDiff\n\t    ,'sameArrayContents':sameArrayContents\n\t    ,'anyArrayOverlap':anyArrayOverlap\n\t    ,'pushToNestedArray':pushToNestedArray\n\t    ,'filterSplit':filterSplit\n\t};\n\n\n\n\n\n\n\n\n\t/*\n\t* Join an array, optionally setting last delimiter to something else\n\t* @return string\n\t*/\n\tfunction join(arr, delimit, lastDelimit){\n\t\ttry{\n\t\t\tvX.checkType('array',arr);\n\t\t\tvar last= (typeof lastDelimit=='string' ? lastDelimit+arr.splice(-1,1) : \"\");\n\t\t\treturn arr.join(delimit) + last;\n\t\t}catch(err){\n\t\t\t_log.throw(err);\n\t\t}\n\t}\n\n\n\n\tfunction uniqueArrayFilter(value, index, arr) { \n\t\t// vX.checkType('array',arr);\n\t    return arr.indexOf(value) === index;\n\t}\n\n\n\tfunction extractItem(arr,item){\n\t\tvX.checkType('array',arr);\n\t\treturn extractCommon(arr,item);\n\t}\n\n\t/*\n\t* Extract several items from an array\n\t*\n\t* @param array arr\n\t* @param array|function x \tList of items to extract, or a callback which get's passed each item and if it\n\t*\t\t\t\t\t\t\treturns truthy then the item is extracted\n\t*\n\t* @return array \t\tAn array of the items that existed (ie. could be an empty array)\n\t*/\n\tfunction extractItems(arr,x){\n\t\tif(vX.checkTypes(['array',['array','function']],Object.values(arguments))[1]=='function'){\n\t\t\tvar extracted=[],i;\n\t\t\tfor(i=arr.length-1; i>-1;i--){\n\t\t\t\tif(x(arr[i],i,arr)){\n\t\t\t\t\textracted.unshift(arr.splice(i,1)[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn extracted;\n\t\t}else{\n\t\t\treturn x\n\t\t\t\t.map(item=>extractCommon(arr,item))\n\t\t\t\t.filter(item=>typeof item!='undefined');\n\t\t}\n\t}\n\n\t/*\n\t*@private\n\t*/\n\tfunction extractCommon(arr,item){\n\t\tlet i=arr.indexOf(item);\n\t\treturn (i>-1 ? arr.splice(i,1)[0] : undefined);\n\t}\n\n\n\n\n\tfunction flatten(arr){\n\t\tvar ret=[];\n\t\tarr.forEach(child=>{\n\t\t\tif(Array.isArray(child))\n\t\t\t\tret=ret.concat(child);\n\t\t\telse\n\t\t\t\tret.push(child);\n\t\t})\n\t\treturn ret;\n\t}\n\n\tfunction rowsToString(arr){\n\t\t//So as not to change the original array, we create a duplicate\n\t\tvar arr2=[];\n\t\t//First we're going to find the longest string in each column, which decides the width of that column\n\t\tvar ll={},c;\n\t\tarr.forEach(row=>{\n\t\t\tvar row2={};\n\t\t\tfor(c in row){\n\t\t\t\tswitch(row[c]){\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\trow2[c]='<undef>'; break;\n\t\t\t\t\tcase null:\n\t\t\t\t\t\trow2[c]='<null>';break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\trow2[c]=String(row[c]);\n\t\t\t\t}\n\t\t\t\tlet l=row2[c].length\n\t\t\t\tif(!ll[c])\n\t\t\t\t\tll[c]=Math.max(String(c).length, l); //longest of column title and this value\n\t\t\t\telse if(ll[c]<l)\n\t\t\t\t\tll[c]=l\n\t\t\t}\n\t\t\tarr2.push(row2);\n\t\t})\n\n\t\tvar output=''\n\n\t\t//Add the header row\n\t\tfor(c in ll){\n\t\t\toutput+=String(c).padEnd(ll[c]+2);\n\t\t}\n\t\toutput+='\\n'\n\n\t\t//Add all data\n\t\tarr2.forEach(row=>{\n\t\t\tfor(c in ll){\n\t\t\t\tlet str=row[c]||'<undef>';\n\t\t\t\toutput+=str.padEnd(ll[c]+2);\n\t\t\t}\n\t\t\toutput+='\\n'\n\t\t})\n\t\treturn output;\n\t}\n\n\n\t/*\n\t* Look through an array for the first instance of a given type, returning (possibly extracting) it\n\t*\n\t* @param array arr \t \t\tAn array or the arguments obj\t\t\n\t* @param any type \t\t\t@see checkType(arg2)\n\t* @param extract bool \t\tDefault false. If true the item is removed from arr\n\t*\n\t* @return any|undefined\t\tThe target item, or undefined\n\t*/\n\tfunction getFirstOfType(arr, type,extract=false){\n\n\t\tif(vX.checkType(['array','object'],arr)=='object'){\n\t\t\tif(typeof arr.length!='number')\n\t\t\t\t_log.throwType(\"arg #1 to be an array-like object\",arr);\n\t\t\telse\n\t\t\t\tarr=Array.from(arr);\n\t\t}\n\n\t\tvar i=0,l=arr.length;\n\t\tfor(i;i<l;i++){\n\t\t\tlet v=arr[i]\n\t\t\tif(vX.checkType(type,v,true)){\n\t\t\t\tif(extract)\n\t\t\t\t\tarr.splice(i,1);\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\n\n\t/*\n\t* Check difference between 2 arrays\n\t*\n\t* @param array A\n\t* @param array B\n\t*\n\t* @return [[only in A],[only in B],[in both]] \tReturns array with 3 child arrays\n\t*/\n\tfunction arrayDiff(A,B,...flags){\n\t\tif(!flags.includes('noCheck'))\n\t\t\tvX.checkTypes(['array','array'],[A,B]);\n\n\t\tvar onlyA=[],onlyB=[],both=[],x;\n\t\tfor(x of A){\n\t\t\tif(B.indexOf(x)>-1)\n\t\t\t\tboth.push(x);\n\t\t\telse\n\t\t\t\tonlyA.push(x);\n\t\t}\n\t\tfor(x of B){\n\t\t\tif(A.indexOf(x)==-1)\n\t\t\t\tonlyB.push(x);\n\t\t}\n\t\treturn [onlyA,onlyB,both];\n\t}\n\n\n\t/*\n\t* Check if 2 arrays contain the same items, even if those items are not in the same order\n\t*\n\t* @param array A\n\t* @param array B\n\t*\n\t* @return boolean\n\t*/\n\tfunction sameArrayContents(A,B){\n\t\tvX.checkTypes(['array','array'],[A,B]);\n\n\t\tif(A.length!=B.length)\n\t\t\treturn false;\n\n\t\tvar [onlyA,onlyB,ignore]=arrayDiff(A,B,'noCheck');\n\t\treturn onlyA.length==0 && onlyB.length==0\n\t}\n\n\n\t/*\n\t* Check if 2 arrays have any overlap (but quicker than getting a full arrayDiff\n\t*\n\t* @param array A\n\t* @param array B\n\t*\n\t* @return boolean\n\t*/\n\tfunction anyArrayOverlap(A,B){\n\t\tvar x;\n\t\tfor(x of A){\n\t\t\tif(B.indexOf(x)>-1)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/*\n\t* @throws TypeError \tIf nested prop exists and is not an array\n\t*/\n\tfunction pushToNestedArray(obj,key,value){\n\t\tif(!obj.hasOwnProperty(key))\n\t\t\tobj[key]=[];\n\t\tobj[key].push(value);\n\t}\n\n\n\n\t/*\n\t* Filter an array into two arrays\n\t*\n\t* @param array arr\n\t* @param function func\n\t* @param bool retainIndex \tIf truthy, the items will have the same indexes in their new arrays\n\t*\t\t\t\t\t\t\tas they did in the original. This will create non-sequential arrays\n\t*\n\t* @return array \t\t\tAn array with items that returned truthy. The falsey items\n\t*\t\t\t\t\t\t\tare set on a hidden property .rest\n\t*/\n\tfunction filterSplit(arr,func,retainIndex=false){\n\t\ttry{\n\t\t\tvar i,l=arr.length,a=[],b=[];\n\t\t\tif(retainIndex){\n\t\t\t\tfor(i=arr.length-1;i>=0;i--){\n\t\t\t\t\tif(func(arr[i])){\n\t\t\t\t\t\ta[i]=arr[i];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb[i]=arr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(i=arr.length-1;i>=0;i--){\n\t\t\t\t\tif(func(arr[i])){\n\t\t\t\t\t\ta.unshift(arr[i])\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb.unshift(arr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject.defineProperty(a,'rest',{value:b,writable:true,configurable:true});\n\t\t\treturn a;\n\t\t}catch(err){\n\t\t\tcX.checkTypes(['array','function'],arguments);\n\t\t\tcX._log.makeError(err).throw();\n\t\t}\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/arr.util.js?");

/***/ }),

/***/ "./util/common/functions.util.js":
/*!***************************************!*\
  !*** ./util/common/functions.util.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/functions.util.js\n//simpleSourceMap2=/lib/util/common/functions.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n\nmodule.exports=function export_fX({_log,vX,aX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\tprettyArgs\n\t\t,getArgNames\n\t\t,callWithNamedArgs\t\n\t\t,once\t\n\t\t,renameFunction\n\t\t,betterTimeout\n\n\t};\n\n\n\n\n\n\t/*\n\t\tThis function can be called from within another function and returns\n\t\tan object where the parameters and their values are the calling functions\n\t\targument names and the values passed in to them\n\n\t\t@liveArgs*: the 'arguments' array from the calling function\n\n\t\t@throws Error If calling function is native or bound\n\t\t@return: An object {callerArg1:passedInValue1, callerArg2:passedInValue2 ...}\n\t*/\n\tfunction prettyArgs(liveArgs){\n\t\tretObj = Object()\n\t\tvar argArray = JSON.parse(JSON.stringify(liveArgs)) // hardcopy\n\t\tif(argNames = getArgNames(arguments.callee.caller)){\n\t\t\tfor(i in argArray){\n\t\t\t\tretObj[argNames[i]]=argArray[i]\n\t\t\t}\n\t\t} \n\n\t\treturn retObj\n\t}\n\n\n\t/*\n\t* This function gets the names of a given functions arguments\n\t*\n\t* @param function f\n\t* @param bool showDefaults \tIf truthy, default values will show up\n\t*\n\t* @throws Error \tIf function was bound or native\n\t* @return array \tAn array of strings (or empty array)\n\t*/\n\tfunction getArgNames(f,showDefaults=false) {\n\t\ttry{\n\t\t\tvar fnStr = f.toString();\n\t\t\tif(fnStr=='function () { [native code] }'){\n\t\t\t\tif(!f.length)\n\t\t\t\t\treturn [];\n\t\t\t\tthrow 'Because passed function was native or bound.';\n\t\t\t}\n\t\t\t\n\t\t\t//Grab everything between the first parenthesis\n\t\t\tfnStr=fnStr.slice(fnStr.indexOf('(')+1,fnStr.indexOf(')'));\n\t\t  \tif(fnStr){\n\t\t  \t\tvar arr=fnStr.split(',').map(arg=>arg.trim());\n\t\t  \t\tif(showDefaults)\n\t\t  \t\t\treturn arr;\n\t\t  \t\telse\n\t\t  \t\t\treturn arr.map(arg=>arg.replace(/(.+)=.+/,'$1').trim()) //remove possible default value and whitespace\n\t\t  \t}else{\n\t\t  \t\treturn [];\n\t\t  \t}\n\t  \t} catch(err){\n\t  \t\t_log.makeError(err).prepend('Could not get argument names.').throw();\n\t  \t}\n\t}\n\n\n\t/*\n\t* Call a func given an object of named args\n\t*\n\t* @param function func \t\tThe function to call\n\t* @param object args \t\tAn object with keys matching the names of the functions args\n\t* @param @opt object self \tCall the function as\n\t*\n\t* @throw TypeError \t\t\tIf the args expected by this function are wrong\n\t* @throw any \t\t\t\tWhatever the function you're calling may throw\n\t* @return any \t\t\t\tReturns whatever the function returns\n\t*/\n\tfunction callWithNamedArgs(func, args, self){\n\t\tvX.checkTypes(['function','object',['object','undefined']],[func,args,self]);\t\n\t\treturn func.apply(self,getArgNames(func).map(key=>args[key]));\n\t}\n\n\n\t/*\n\t* Change the name of a function. \n\t*\n\t* @param function fn\n\t* @param string name\n\t*\n\t* @return void\n\t*/\n\tfunction renameFunction(fn,name){\n\t\tvX.checkTypes(['function','string'],arguments);\n\t\tObject.defineProperty(fn,'name',{value:name,writable:false, configurable:true})\n\t}\n\n\n\n\t/*\n\t* Wrap a $callback in another function that prevents the original being called more than once\n\t*\n\t* @param function callback\n\t* @opt function onDupCall \tAn error-first callback for subsequent calls to @return. It can choose to return\n\t*\t\t\t\t\t\t\t or log or throw. If omitted, the initial return value will be returned, or the initial\n\t*\t\t\t\t\t\t\t error will be thrown again\n\t* @throw <ble TypeError>\n\t* @return function \t\tA new function. Subsequent calls to it will return/throw same as the first call unless $onDupCall\n\t*/\n\tfunction once(callback,onDupCall){\n\t\tvX.checkTypes(['function',['function','undefined']],arguments);\n\n\t\tfunction onceCallback(...args){\n\t\t\t//We're going to store the result on a hidden prop on the returned func so it\n\t\t\t//can be used to check if the function has been called or not...\n\n\t\t\t//...so start by checking if such a prop exists, else call $callback now!\n\t\t\tif(!onceCallback.hasOwnProperty('_once')){\n\t\t\t\ttry{\n\t\t\t\t\tvar value=callback(...args);\n\t\t\t\t}catch(err){\n\t\t\t\t\tvar error=err;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(onceCallback,'_once',{configurable:true,value:[error,value]})\n\t\t\t\n\t\t\t//If this is a second call, and $onDupCall was passed...\n\t\t\t}else if(onDupCall){\n\t\t\t\t///...call it now with [error,value,[newArgs]]\n\t\t\t\treturn onDupCall(...onceCallback._once,args);\n\t\t\t}else{\n\t\t\t\tvar [error,value]=onceCallback._once;\n\t\t\t}\n\n\t\t\t//If we're still running, this is either the first call or subsequent calls aren't a problem\n\t\t\t//and only return the same as the first\n\t\t\tif(error)\n\t\t\t\tthrow error;\n\t\t\telse\n\t\t\t\treturn value;\n\t\t}\n\n\t\tif(callback.name)\n\t\t\trenameFunction(onceCallback,callback.name+'_once');\n\n\t\treturn onceCallback;\n\t}\n\n\n\n\t/*\n\t* @return object \tAn object with methods that allow for manipulation of timeouts\n\t* \t@prop function callback \tThe passed in $callback (using getter, cannot be changed)\n\t* \t@prop number delay \t\t\tThe current delay (getter+setter)\t\n\t*\t@method execute(this,args) \tApply the callback immediately. If nothing is passed to it, run possible waiting action\n\t* \t@method trigger(...args)\t$callback after a timeout, ignoring repeated calls during wait\n\t* \t@method block(...args)\t\t$callback first, then ignore repeated calls during wait\n\t*\t@method clear()\t\t\t\tclear any pending timeout (regardless if .timeout() or .block() set it)\n\t*   @method debounce(...args) \tClear pending timeout if it exists, start a new one regardless\n\t* \t@method throttle(...args) \tLike block(), but the last missed call is run after the timeout\n\t* \t@method postpone\t\t\tIf a timeout exists, change it's expiration, else do nothing\n\t* \t@method expire \t\t\t\tIf a timeout exists, clear it + run $callback, else do nothing\n\t*\n\t*/\n\tfunction betterTimeout(...args){\n\t\tvar delay=aX.getFirstOfType(args,'number');\n\t\tvar callback=aX.getFirstOfType(args,'function');\n\t\tvar callAsOverride=aX.getFirstOfType(args,'object');\n\n\t\tvX.checkTypes(['function','number'],[callback,delay]);\n\n\t\t//Define private props\n\t\tvar timerId, result, after;\n\t\t\n\t\tvar obj={};\n\t\tObject.defineProperties(obj,{\n\t\t\tcallback:{get:()=>callback}\n\t\t\t,delay:{get:()=>delay, set:(val)=>{if(typeof val=='number')delay=val}}\n\t\t\t,result:{get:()=>result}\n\t\t\t,ignored:{get:()=>timerId?after:undefined}\n\t\t})\n\n\n\t\t/*\n\t\t* Call $callback and store the results. \n\t\t*\n\t\t* NOTE: if args aren't passed in here AND no calls to .timeout() or .block() have been ignored\n\t\t*\t\tthen this function will do nothing\n\t\t*\n\t\t* @opt object callAs\n\t\t* @opt array args\n\t\t*\n\t\t* @return <obj>\n\t\t*/\n\t\tobj.execute=function execute(callAs,args){\n\t\t\tif(!args){\n\t\t\t\tif(!after)\n\t\t\t\t\treturn;\n\t\t\t\targs=after[1];\n\t\t\t\tcallAs=after[0];\n\t\t\t}\n\t\t\tresult=callback.apply(callAsOverride||callAs,args);\n\t\t\tafter=undefined;\n\t\t\treturn obj;\n\t\t}\n\n\n\t\t/*\n\t\t* Prevent any upcomming calls \n\t\t*/\n\t\tobj.clear=function clear(){\n\t\t\tif(timerId){\n\t\t\t\tclearTimeout(timerId);\n\t\t\t\ttimerId=undefined;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\n\t\t/*\n\t\t* Trigger a timeout with the callback at the end, ignoring new calls during that time\n\t\t*/\n\t\tobj.trigger=function trigger(){\n\t\t\tif(!timerId){\n\t\t\t\t//Store in .after so .expire and .delay can alter the timeout but use the same args\n\t\t\t\tafter=[this,arguments];\n\t\t\t\t\n\t\t\t\ttimerId=setTimeout(()=>{\n\t\t\t\t\tclear().execute(this,arguments);\n\t\t\t\t}, delay);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\n\t\t/*\n\t\t* Invert the workflow, ie. call first then block during a timeout. \n\t\t*/\n\t\tobj.block=function block(){\n\t\t\tif(!timerId){\n\t\t\t\t//Set a blocking timeout...\n\t\t\t\ttimerId=setTimeout(clear,delay)\n\n\t\t\t\t//...then execute\n\t\t\t\texecute(this,arguments);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\n\t\t/*\n\t\t* Discard any existing timeouts, then trigger a new one\n\t\t*/\n\t\tobj.debounce=function debounce(){\n\t\t\treturn clear().trigger.apply(this,arguments);\n\t\t}\n\n\t\t/*\n\t\t* Same as .block but the last call during the timeout is run directly after. This is good when throttleing inputs\n\t\t* so the last/freshest data is received\n\t\t*/\n\t\tobj.throttle=function throttle(){\n\t\t\tif(!timerId){\n\t\t\t\t//Set a blocking timeout, but at the end of it we check if anything has been set on .after\n\t\t\t\t//in which case the callback get's run again...\n\t\t\t\ttimerId=setTimeout(()=>{\n\t\t\t\t\ttimerId=undefined;\n\t\t\t\t\texecute()\n\t\t\t\t},delay);\n\n\t\t\t\t//...but first we run it right away\n\t\t\t\tapply(this,arguments);\n\t\t\t\t  //^this also undefines .after\n\t\t\t}else{\n\n\t\t\t\t//Store missed calls in .after so the last one can be used by apply() when the timer expires ^\n\t\t\t\tafter=[this,arguments];\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\n\n\n\n\t\t/*\n\t\t* Move a current timeout further into the future. This works for any method\n\t\t*/\n\t\tobj.postpone=function postpone(){\n\t\t\tif(timerId){\n\t\t\t\tclear();\n\t\t\t\tif(after){\n\t\t\t\t\t//regardless which method set $after, now we want to execute it after a delay\n\t\t\t\t\ttrigger.apply(after[0],after[1]);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn obj;\n\t\t}\n\t\n\n\t\t/*\n\t\t* Expire a timeout now and run $callback if .after is set. This works after any method\n\t\t*/\n\t\tobj.expire=function expire(){\n\t\t\tif(timerId){\n\t\t\t\tclear().execute();\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t}\n\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/functions.util.js?");

/***/ }),

/***/ "./util/common/misc.util.js":
/*!**********************************!*\
  !*** ./util/common/misc.util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/misc.util.js\n//simpleSourceMap2=/lib/util/common/misc.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n\nmodule.exports=function export_mX({_log,stX,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\n\t\t'round':round\n\n\t\t,'getRandomInt':getRandomInt\n\n\t\t,'eventTimeout':eventTimeout\n\n\t\t,'mapping':{\n\t\t\t'prepare':prepareMap\n\t\t\t,'apply':applyMap\n\t\t}\n\n\t\t,range\n\t};\n\n\n\t/*\n\t* Round to specific number of decimal places\n\t* \thttp://www.jacklmoore.com/notes/rounding-in-javascript/\n\t*\n\t* @param number value \t\tAny value to round\n\t* @param number decimals \tInteger number of decimals\n\t*\n\t* @return number\n\t*/\n\tfunction round(value, decimals=0) {\n\t  return Number(Math.round(value+'e'+decimals)+'e-'+decimals);\n\t}\n\n\n\n\n\tfunction getRandomInt(max=1000000) {\n\t  \treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\n\n\n\n\n\t/*\n\t* Listen for an event once, calling callback if it's not fired within a given period\n\t*\n\t* @param <EventEmitter> emitter \tJust needs to have method 'once'\n\t* @param string \t\teventName\n\t* @param number \t\ttimeoutMs\n\t* @param function \t\ttimeoutCallback\n\t* @param mixed \t\t\tcallbackArg\n\t*\n\t* @return number \tThe timeout id so it can be cleared\n\t*/\n\tfunction eventTimeout(emitter,eventName,timeoutMs,timeoutCallback,callbackArg){\n\t\tvar triggered=false;\n\t\temitter.once(eventName,()=>triggered=true);\n\t\treturn setTimeout(()=>{\n\t\t\tif(triggered==false)\n\t\t\t\ttimeoutCallback(callbackArg)\n\t\t},timeoutMs)\n\t}\n\n\n\n\n\n\n\n\n\n\t/*\n\t* This function transforms a @map and @returns an object where parameter keys can be thought of\n\t* as 'aliases'(many) and parameter values are the (few) names they map to.\n\t* \n\t* @param object map\t\t\t\tKeys are the desired props, values are single aliases, \n\t*\t\t\t\t\t\t\t\t  or arrays of aliases. Example: \n\t*\t\t\t\t\t\t\t\t\t\t{'Name':'n','Age':['a','years']}\n\t* @param @opt boolean addSelf \tDefault true. If true, add entry to map that maps the desired prop \n\t*\t\t\t\t\t\t\t\t to itself (makes it easy to just lookup once)\n\t* @param @opt boolean addLower \tDefault true. If true, the lower case of each desired prop will be \n\t*\t\t\t\t\t\t\t\t  included\n\t* \n\t* @throw TypeError \t\tIf $map is poorly formated\n\t*\n\t* @return: An object where each parameter name corresponds to a string the case and spelling of which\n\t*\t\t  is the desired output when applying the prapared map. Example:\n\t*\t\t  {\n\t*\t\t \t 'Name': 'Name' \t<-- included if @addSelf = true\n\t*\t\t \t ,'name': 'Name'\t<-- included if @addLower = true\n\t*\t\t\t ,'n':'Name' \n\t*\t\t \t ,'Age':'Age', \t\t<-- included if @addSelf = true\n\t*\t\t \t ,'age':'Age', \t\t<-- included if @addLower = true\n\t*\t\t \t ,'a':'Age', \n\t*\t\t \t ,'years':'Age', \n\t*\t\t  }\n\t*/\n\tfunction prepareMap(map, addSelf=true, addLower=true){\n\n\t\tvar MAP = {}, real, alias;\n\t\ttry{\n\t\t\tfor(real in map){\n\t\t\t\tvar aliases=map[real];\n\t\t\t\tif(!Array.isArray(aliases)){\n\t\t\t\t\taliases=[aliases];\n\t\t\t\t}\n\n\t\t\t\t//First add the aliases\n\t\t\t\tfor(alias in aliases){ //eg. n=>Name\n\t\t\t\t\tMAP[alias]=real;\n\t\t\t\t\n\t\t\t\t\t//Optionally add lower case version of alias\n\t\t\t\t\tif(typeof alias=='string' && addLower){\n\t\t\t\t\t\tMAP[alias.toLowerCase()]=real;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Then optionally add lower case version of real\n\t\t\t\tif(typeof real=='string' && addLower){\n\t\t\t\t\tMAP[real]=real\n\t\t\t\t}\n\n\t\t\t\t//Then optionally add self\n\t\t\t\tif(addSelf){\n\t\t\t\t\tMAP[real]=real\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Finally, set secret prop so we can know it's already been prepared (to allow\n\t\t\t//both prepared and unprepared maps to be passed to apply)\n\t\t\tObject.defineProperty(MAP,'_hasBeenPrepared',{value:true});\n\t\t\treturn MAP\n\t\t} catch(e) {\n\t\t\t_log.throwType('Unsupported formated map passed to prepareMap():', map, e)\n\t\t}\n\t\t\n\t}\n\n\t/*\n\t* Map props on an object \n\t*\n\t* @param object data \t\n\t* @param object map \t\t\t\t\tThe object returned from prepareMap(), or an array that can \n\t*\t\t\t\t\t\t\t\t\t\t\tbe passed to it\n\t* @param boolean onlyReturnMatches \t\tIf true, only props with a map-entry will be returned\n\t* \t\n\t* @return object \t\t\t\t\t\t\n\t*/\n\tfunction applyMap(data, map, onlyReturnMatches=false){\n\t\tvX.checkTypes(['object','object'],[data,map]);\n\n\t\tvar MAP=(!map._hasBeenPrepared ? prepareMap(map) : map)\n\t\t\t,mData={}\n\t\t\t,key\n\t\t;\n\n\t\tif(onlyReturnMatches){\n\t\t\tfor(key in data){\n\t\t\t\tif(MAP[key]){\n\t\t\t\t\tmData[MAP[key]]=data[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(key in data){\n\t\t\t\tmData[MAP[key]]=data[key]\n\t\t\t}\n\t\t}\n\n\t\treturn mData\n\t}\n\n\n\n\t/*\n\t* Get a range of numbers\n\t*\n\t* @param number from\n\t* @param number to\n\t*\n\t* @return array\n\t*/\n\tfunction range(from,to){\n\t\tvX.checkTypes(['number','number'],arguments);\n\t\treturn [...Array(to+1).keys()].slice(from);\n\t}\n\n\n\n\n\n\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/misc.util.js?");

/***/ }),

/***/ "./util/common/netmask.polyfill.js":
/*!*****************************************!*\
  !*** ./util/common/netmask.polyfill.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/common/netmask.polyfil.js\n//simpleSourceMap2=/lib/util/common/netmask.polyfil.js\n/*\n* netmask (Polyfill)\n*\n* Date: Feb 2020\n*\n* This module contains the npm module 'netmask' so we don't need to depend on an external package.\n* \thttps://www.npmjs.com/package/netmask\n* \n* The module is origninally written in CoffeScript but has been transpiled using\n* \thttps://awsm-tools.com/code/coffee2js\n*\n*/\n;'use strict';\nmodule.exports=(function() {\n\tvar Netmask, ip2long, long2ip;\n\n\tlong2ip = function(long) {\n\t\tvar a, b, c, d;\n\t\ta = (long & (0xff << 24)) >>> 24;\n\t\tb = (long & (0xff << 16)) >>> 16;\n\t\tc = (long & (0xff << 8)) >>> 8;\n\t\td = long & 0xff;\n\t\treturn [a, b, c, d].join('.');\n\t};\n\n\tip2long = function(ip) {\n\t\tvar b, byte, i, _i, _len;\n\t\tb = (ip + '').split('.');\n\t\tif (b.length === 0 || b.length > 4) {\n\t\t\tthrow new Error('Invalid IP');\n\t\t}\n\t\tfor (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {\n\t\t\tbyte = b[i];\n\t\t\tif (isNaN(parseInt(byte, 10))) {\n\t\t\t\tthrow new Error(\"Invalid byte: \" + byte);\n\t\t\t}\n\t\t\tif (byte < 0 || byte > 255) {\n\t\t\t\tthrow new Error(\"Invalid byte: \" + byte);\n\t\t\t}\n\t\t}\n\t\treturn ((b[0] || 0) << 24 | (b[1] || 0) << 16 | (b[2] || 0) << 8 | (b[3] || 0)) >>> 0;\n\t};\n\n\tNetmask = (function() {\n\t\tfunction Netmask(net, mask) {\n\t\t\tvar error, i, _i, _ref;\n\t\t\tif (typeof net !== 'string') {\n\t\t\t\tthrow new Error(\"Missing `net' parameter\");\n\t\t\t}\n\t\t\tif (!mask) {\n\t\t\t\t_ref = net.split('/', 2), net = _ref[0], mask = _ref[1];\n\t\t\t}\n\t\t\tif (!mask) {\n\t\t\t\tswitch (net.split('.').length) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmask = 8;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tmask = 16;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tmask = 24;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tmask = 32;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Invalid net address: \" + net);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof mask === 'string' && mask.indexOf('.') > -1) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.maskLong = ip2long(mask);\n\t\t\t\t} catch (_error) {\n\t\t\t\t\terror = _error;\n\t\t\t\t\tthrow new Error(\"Invalid mask: \" + mask);\n\t\t\t\t}\n\t\t\t\tfor (i = _i = 32; _i >= 0; i = --_i) {\n\t\t\t\t\tif (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {\n\t\t\t\t\t\tthis.bitmask = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (mask) {\n\t\t\t\tthis.bitmask = parseInt(mask, 10);\n\t\t\t\tthis.maskLong = 0;\n\t\t\t\tif (this.bitmask > 0) {\n\t\t\t\t\tthis.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Invalid mask: empty\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.netLong = (ip2long(net) & this.maskLong) >>> 0;\n\t\t\t} catch (_error) {\n\t\t\t\terror = _error;\n\t\t\t\tthrow new Error(\"Invalid net address: \" + net);\n\t\t\t}\n\t\t\tif (!(this.bitmask <= 32)) {\n\t\t\t\tthrow new Error(\"Invalid mask for ip4: \" + mask);\n\t\t\t}\n\t\t\tthis.size = Math.pow(2, 32 - this.bitmask);\n\t\t\tthis.base = long2ip(this.netLong);\n\t\t\tthis.mask = long2ip(this.maskLong);\n\t\t\tthis.hostmask = long2ip(~this.maskLong);\n\t\t\tthis.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;\n\t\t\tthis.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);\n\t\t\tthis.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;\n\t\t}\n\n\t\tNetmask.prototype.contains = function(ip) {\n\t\t\tif (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {\n\t\t\t\tip = new Netmask(ip);\n\t\t\t}\n\t\t\tif (ip instanceof Netmask) {\n\t\t\t\treturn this.contains(ip.base) && this.contains(ip.broadcast || ip.last);\n\t\t\t} else {\n\t\t\t\treturn (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;\n\t\t\t}\n\t\t};\n\n\t\tNetmask.prototype.next = function(count) {\n\t\t\tif (count == null) {\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\treturn new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);\n\t\t};\n\n\t\tNetmask.prototype.forEach = function(fn) {\n\t\t\tvar index, lastLong, long;\n\t\t\tlong = ip2long(this.first);\n\t\t\tlastLong = ip2long(this.last);\n\t\t\tindex = 0;\n\t\t\twhile (long <= lastLong) {\n\t\t\t\tfn(long2ip(long), long, index);\n\t\t\t\tindex++;\n\t\t\t\tlong++;\n\t\t\t}\n\t\t};\n\n\t\tNetmask.prototype.toString = function() {\n\t\t\treturn this.base + \"/\" + this.bitmask;\n\t\t};\n\n\t\treturn Netmask;\n\n\t})();\n\n\treturn {ip2long,long2ip,Netmask};\n\n})()\n\n//# sourceURL=webpack:///./util/common/netmask.polyfill.js?");

/***/ }),

/***/ "./util/common/obj.util.js":
/*!*********************************!*\
  !*** ./util/common/obj.util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/promise.util.js\n//simpleSourceMap2=/lib/util/common/promise.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to OBJECTS\n*/\n\nmodule.exports=function export_oX({_log,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\t'objCreateFill':objCreateFill\n\t\t,'combineKeysValues':combineKeysValues\n\t\t,'recombineKeysValues':recombineKeysValues\n\t\t,'addUniqueItemToNestedArr':addUniqueItemToNestedArr\n\t\t,'combineUniqueNestedArrays':combineUniqueNestedArrays\n\t\t,'splitArrayItemsToObject':splitArrayItemsToObject\n\t\t,'indentStringToObject':indentStringToObject\n\t\t,'objectToLines':objectToLines\n\t\t,linesToObj\n\t\t,flattenObject\n\t\t,'hasOwnProperties':hasOwnProperties\n\t\t,'keysToLower':keysToLower\n\t\t,'subObj':subObj\n\t\t,'extract':extract\n\t\t,'emptyObject':emptyObject\n\t\t,'getFirstMatchingProp':getFirstMatchingProp\n\t\t,'nestedGet':nestedGet\n\t\t,'nestedSet':nestedSet\n\t\t,nestedAssign\n\t\t,'getChildProps':getChildProps\n\t\t,'groupChildrenByProp':groupChildrenByProp\n\t\t,'groupKeysByValue':groupKeysByValue\n\t\t,'argObjToArr':argObjToArr\n\t\t,'nestedObjToArr':nestedObjToArr\n\t\t,'forEachNestedPrimitive':forEachNestedPrimitive\n\t\t,'objToQueryStr':objToQueryStr\n\t};\n\n\n\n\n\n\tfunction objCreateFill(keys,value,copyValue=false){\n\t\tvX.checkType('array',keys);\n\n\t\tvar obj={};\n\t\tfor(let key of keys){\n\t\t\tobj[key]=copyValue ? vX.copy(value) : value;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tfunction combineKeysValues(keys,values,formatKeys=null,formatValues=null){\n\t\tvX.checkTypes(['array','array'],[keys,values]);\n\t\tif(keys.length!=values.length)\n\t\t\tthrow new Error(\"Expected both arrays to be same length, they were \"+keys.length+\" and \"+values.length);\n\n\t\tif(typeof formatKeys!='function')\n\t\t\tformatKeys=x=>x\n\t\tif(typeof formatValues!='function')\n\t\t\tformatValues=x=>x\n\n\t\tvar obj={};\n\t\tfor(let i in keys){\n\t\t\tobj[formatKeys(keys[i])]=formatValues(values[i]);\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tfunction recombineKeysValues(obj,formatKeys,formatValues){\n\t\tvX.checkType('object',obj);\n\t\treturn combineKeysValues(Object.keys(obj),Object.values(obj),formatKeys,formatValues);\n\t}\n\n\n\tfunction addUniqueItemToNestedArr(obj,key,value){\n\t\tif(!obj.hasOwnProperty(key))\n\t\t\tobj[key]=[value]\n\t\telse if(!Array.isArray(obj[key]))\n\t\t\tthrow new TypeError(\"Expected prop (\"+key+\") to be array, was:\" +typeof obj[key])\n\t\telse if(!obj[key].includes(value))\n\t\t\tobj[key].push(value);\n\n\t\treturn;\n\t}\n\n\t/*\n\t* Two objects both with nested arrays. Append unique items from source to target.\n\t*\n\t* @param array source \tEg. {a:[1,2],b[2,3,4]}\n\t* @param array target \tEg. {a:[1,6],c:[5]} \tNOTE: This array gets altered\n\t*\n\t* \t@target after: \t{a:[1,2,6],b[2,3,4],c:[5]}\n\t*\n\t* @return void\n\t*/\n\tfunction combineUniqueNestedArrays(source,target){\n\t\tfor(let key of Object.keys(source)){\n\t\t\tlet arr=typeof source[key]=='array' ? source[key] : [source[key]];\n\t\t\tif(!target.hasOwnProperty(key))\n\t\t\t\ttarget[key]=arr;\n\t\t\telse if(Array.isArray(target[key]))\n\t\t\t\t\t_log.throwType(`nested key ${key} to be array`,target[key]);\n\t\t\telse\n\t\t\t\tarr.forEach(item=>{\n\t\t\t\t\tif(!target[key].includes(item))\n\t\t\t\t\t\ttarget[key].push(item);\n\t\t\t\t})\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t* @param array[string,...] arr \tArray of key/value pairs, eg: \n\t*\t\t\t\t\t\t\t\t\t['key1=value1', 'key2=value2',...]\n\t* @param string delimiter \t\tThe character used in every item of @arr to split key/value, eg:\n\t*\t\t\t\t\t\t\t\t\t '='\n\t*\n\t* @return object \t\t\t\tFrom above example: \n\t*\t\t\t\t\t\t\t\t\t{key1:'value1', key2:'value2'}\n\t*/\n\tfunction splitArrayItemsToObject(arr,delimiter){\n\t\t//Check types, throwing on fail\n\t\tif(vX.checkTypes(['array',['string','object']],[arr,delimiter])[1]=='object')\n\t\t\tvX.instanceOf(RegExp, delimiter);\n\n\t\tvar obj={};\n\t\tvar firstErr=true;\n\t\tarr.forEach((line,i)=>{\n\t\t\ttry{\n\t\t\t\tvX.checkType('string',line);\n\n\t\t\t\t//Split on first delimiter (glueing rest together if needed)\n\t\t\t\tvar [key, ...value]=line.split(delimiter);\n\t\t\t\tobj[key]=value.join(delimiter);\n\t\t\t}catch(err){\n\t\t\t\tif(firstErr){\n\t\t\t\t\tfirstErr=false;\n\t\t\t\t\t_log.warn(\"Error parsing array for key-value pairs\");\n\t\t\t\t}\n\t\t\t\t_log.warn(\"   item \"+i+\": \"+err.message);\n\t\t\t}\n\t\t})\n\t\treturn obj;\n\t\t\n\t}\n\n\n\t/*\n\t* @param string str \tExample:\n\t*\t\t\t\t\t\t\t\"wlan0\n\t*\t\t\t\t\t\t\t\taddr 0.0.0.0\n\t*\t\t\t\t\t\t\t\thwaddr aa:aa:aa:aa:aa:aa\n\t*\t\t\t\t\t\t\t\tdetails\n\t*\t\t\t\t\t\t\t\t\ttype wifi\n\t*\t\t\t\t\t\t\teth0\n\t*\t\t\t\t\t\t\t\taddr 192.168.1.2\n\t*\t\t\t\t\t\t\t\thwaddr bb:bb:bb:bb:bb:bb\n\t*\t\t\t\t\t\t\t\"\n\t* @return object \t\tFrom above example:\n\t*\t\t\t\t\t\t\t{\n\t*\t\t\t\t\t\t\t\t'wlan0':{\n\t*\t\t\t\t\t\t\t\t\t'addr 0.0.0.0':{}\n\t*\t\t\t\t\t\t\t\t\t,'hwaddr aa:aa:aa:aa:aa:aa':{}\n\t*\t\t\t\t\t\t\t\t\t,'details':{\n\t*\t\t\t\t\t\t\t\t\t\t'type wifi'\n\t*\t\t\t\t\t\t\t\t\t}\n\t*\t\t\t\t\t\t\t\t}\n\t*\t\t\t\t\t\t\t\t,'eth0':{\n\t*\t\t\t\t\t\t\t\t\t'addr 192.168.1.2':{}\n\t*\t\t\t\t\t\t\t\t\t,'hwaddr bb:bb:bb:bb:bb:bb':{}\n\t*\t\t\t\t\t\t\t\t}\n\t*\t\t\t\t\t\t\t}\n\t*/\n\tfunction indentStringToObject(str){\n\n\t\tvar data={},len=0, curr=[data],last=data;\n\t\tstr.split('\\n').forEach(line=>{\n\t\t\tlet m=line.match(/^(\\s*)(.+)$/);\n\t\t\tif(!m) return; //skip empty lines\n\t\t\t\n\t\t\t//Determine by the length of the indentation if we work our way up or down\n\t\t\t//the object structure\n\t\t\tlet l=m[1].length;\n\t\t\tif(l>len){\n\t\t\t\t//more indent, move down by adding the last created object to the current position array\n\t\t\t\tcurr.unshift(last); \n\t\t\t}else if(l<len){\n\t\t\t\t//less indent, move up by removing the last added object to the current position array\n\t\t\t\tcurr.shift();\n\t\t\t}\n\t\t\tlen=l; //save for next round\n\n\t\t\t//create new object and set it on the current position \n\t\t\tlast={};\n\t\t\tcurr[0][m[2].trim()]=last;\n\n\t\t})\n\t\treturn data;\n\t}\n\n\n\t/*\n\t* Turn object into a string, eg:\n\t* \t\t{key1:value1,key2:value2} => key1=value1\\nkey2=value2\n\t*\n\t* @param object obj\n\t* @param string delimiter \tDelimiter to use between key and value, eg '='\n\t*\n\t* @return string\n\t*/\n\tfunction objectToLines(obj,delimiter='='){\n\t\tvX.checkTypes(['object','string'],[obj,delimiter])\n\t\treturn Object.entries(obj).map(([key,value])=>key+delimiter+value).join('\\n');\n\t}\n\n\n\t/*\n\t* Turn a delimited string into an object, eg:\n\t* \t\tkey1=value1\\nkey2=value2 => {key1:value1,key2:value2}\n\t*\n\t* @param string str \t\tA string output by objectToLines\n\t* @param string delimiter \tDelimiter to use between key and value, eg '='\n\t*\n\t* @return object\n\t*/\n\tfunction linesToObj(str,delimiter='='){\n\t\tvX.checkTypes(['string','string'],[str,delimiter]);\n\t\tvar obj={};\n\t\tstr.split('\\n').forEach(line=>{line=line.split('=');obj[line[0]]=line[1]});\n\t\treturn obj\n\t}\n\n\n\n\t/*\n\t* @param object obj \tFrom    {type:{shape:'round',color:'red'},weight:4}\n\t* @opt string delim\n\t*\n\t* @throws <ble TypeError>\n\t* @return object \t\tTo \t\t{'type.shape':'round','type.color':'red',weight:4}\n\t*/\n\tfunction flattenObject(obj,delim='.'){\n\t\tvX.checkTypes(['object','string'],[obj,delim]);\n\t\tvar flat={};\n\t\tvar address=[];\n\t\tvar loop=(self)=>{\n\t\t\tObject.entries(self).forEach(([key,value])=>{\n\t\t\t\tif(vX.isPrimitive(value)){\n\t\t\t\t\tflat[address.concat(key).join(delim)]=value;\n\t\t\t\t}else{\n\t\t\t\t\taddress.push(key);\n\t\t\t\t\tloop(value);\n\t\t\t\t\taddress.pop();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tloop(obj);\n\n\t\treturn flat;\n\t}\n\n\n\n\n\t/*\n\t* Check if an object has ANY of a list of properties\n\t*\n\t* @return bool\n\t*/\n\tfunction hasOwnProperties(obj,keys,mode='any'){\n\t\tvX.checkTypes(['object','array','string'],[obj,keys,mode]);\n\t\t\n\t\tswitch(mode){\n\t\t\tcase 'any': //object contains at least one of the keys\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\n\t\t\tcase 'all': //object contains all the keys, but optionally others as well\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(!obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase 'noother': //object does not contain any other keys, but it may contain none\n\t\t\t\treturn Object.keys(obj).every(key=>keys.includes(key))\n\n\t\t\tcase 'exact':\n\t\t\t\treturn hasOwnProperties(obj,keys,'noother') && hasOwnProperties(obj,keys,'all');\n\n\t\t\tcase 'array':\n\t\t\t\tvar ret=[];\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\tret.push(keys[i]);\n\t\t\t\t}\n\t\t\t\tif(!ret.length)\n\t\t\t\t\treturn null;\n\t\t\t\telse\n\t\t\t\t\treturn ret;\n\n\t\t\tcase 'object':\n\t\t\t\tvar ret={};\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\tret[keys[i]]=obj[keys[i]];\n\t\t\t\t}\n\t\t\t\tif(!Object.keys(ret).length)\n\t\t\t\t\treturn null;\n\t\t\t\telse\n\t\t\t\t\treturn ret;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unrecognized mode: \"+mode);\n\n\t\t}\n\t}\n\n\t/*\n\t* Make sure all keys in an object are lower case (non-recursive)\n\t*\n\t* @param object obj\n\t* \n\t* @return object\n\t*/\n\tfunction keysToLower(obj){\n\t\treturn recombineKeysValues(obj,key=>key.toLowerCase()); \n\t}\n\n\n\t/*\n\t* Get specific keys from an object, returning a new object\n\t*\n\t* @param object obj\n\t* @param mixed \tfilter \t\t\tA single key, an array of keys, or a function to validate keys\n\t* @param bool excludeMissing \tIf true, keys that are not found on obj are not included on returned object. Else\n\t*\t\t\t\t\t\t\t\tthe returned object will have that key with value undefined\n\t* \n\t* @throws TypeError\n\t* @return object\n\t*/\n\tfunction subObj(obj,filter, excludeMissing=false){\n\t\tvar types=vX.checkTypes([['array','object'],['string','number','array','function']],[obj,filter])\n\n\t\tif(types[1]=='function'){\n\t\t\tvar keys=Object.entries(obj).filter(keyvalue=>filter(keyvalue[0],keyvalue[1])).map(keyvalue=>keyvalue[0]);\n\t\t\texcludeMissing=false; //nothing to exclude\n\t\t}else if(types[1]!='array'){\n\t\t\treturn obj[filter];\n\t\t}else\n\t\t\tkeys=filter\n\n\t\tvar rObj={};\n\t\tif(excludeMissing){\n\t\t\tkeys.forEach(key=>{\n\t\t\t\tif(obj.hasOwnProperty(key))\n\t\t\t\t\trObj[key]=obj[key]\n\t\t\t})\n\t\t}else{\n\t\t\tkeys.forEach(key=>rObj[key]=obj[key])\n\t\t}\n\n\t\treturn rObj;\n\t}\n\n\tfunction extract(obj,filter, excludeMissing){\n\t\tvar data=subObj(obj,filter,excludeMissing);\n\n\t\tif(Array.isArray(filter)||typeof filter=='function')\n\t\t\tObject.keys(data).forEach(key=>delete obj[key]);\n\t\telse\n\t\t\tdelete obj[filter];\n\n\t\treturn data;\n\t}\n\n\tfunction emptyObject(obj){\n\t\treturn extract(obj,Object.keys(obj));\n\t}\n\n\t/*\n\t* Find a value within a sub-object that matches a criteria\n\t*\n\t* @param object obj \t\t\t@see subObj\n\t* @param array keys \t\t\t@see subObj\n\t* @param @opt function crit \tDefaults to truthy value\n\t* @param @opt boolean extract \t@see subObj\n\t*\n\t* @return any|undefined \tThe first matching prop value, or undefined\n\t*/\n\tfunction getFirstMatchingProp(obj,keys,crit=null,_extract=false){\n\t\tif(!crit)\n\t\t\tcrit=(x)=>x?true:false //returns first non-empty\n\t\telse\n\t\t\tvX.checkType(['function','null'],crit)\n\n\n\t\tif(_extract)\n\t\t\tobj=extract(obj,keys,true)\n\t\telse\n\t\t\tobj=subObj(obj,keys,true)\n\n\t\treturn Object.values(obj).find(crit);\n\t}\n\n\n\t/*\n\t* Check if a nested prop exists on an object\n\t*\n\t* @throws <ble TypeError>\n\t*\n\t* @return boolean\n\t*/\n\tfunction nestedHas(obj,keypath){\n\t\ttry{\n\t\t\treturn typeof nestedGet(obj,keypath)!='undefined'\n\t\t}catch(err){\n\t\t\tswitch(err.code){\n\t\t\t\tcase 'TypeError':\n\t\t\t\t\tthrow err;\n\t\t\t\tcase 'EFAULT':\n\t\t\t\t\treturn false;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.throwCode(\"BUGBUG\",'nestedGet() threw an unexpected error:',err);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*\n\t* Get a nested child from a multi-level object or array\n\t*\n\t* @param array|object obj\n\t* @param array keypath \t\t\t\t\tArray of keys, each pointing to one level deeper. NOTE: this array will be altered\n\t*\t\t\t\t\t\t\t\t\t\t\tby this function, containing any remaining keys after recursion has happened\n\t*\t\t\t\t\t\t\t\t\t\t\tto the available depth\n\t* @param bool returnLastObject \t\t\tDefault false => if a nested property doesn't exist, undefined will be returned. \n\t*\t\t\t\t\t\t\t\t\t\t\ttrue=>the last existing object will be returned and the keypath reflects\n\t*\t\t\t\t\t\t\t\t\t\t\tthe remaining keys\n\n\t* @throws <ble TypeError> \t\t\t\t\n\t* @throws <ble EFAULT> \t\tIf there is a non-object along keypath\n\t*\n\t* @return mixed|[mixed,false|array]  \tThe requested value, or @see $returnLastObject\n\t*/\n\tfunction nestedGet(obj,keypath,returnLastObject=false){\n\t\t// _log.traceFunc(arguments)\n\t\tvX.checkTypes([['object','array'],'array'],[obj,keypath]); //throw typeerror\n\n\t\tvar subobj=obj, address=[];\n\t\twhile(keypath.length){\n\t\t\t//Starting this loop means we're trying to go down one level...\n\t\t\tif(typeof subobj!='object')\n\t\t\t\t//...having a non-object means that's impossible, so throw an error\n\t\t\t\t_log.throwCode('EFAULT',`Cannot get nested value, non-object @ ${address.join('.')}:`,subobj, obj);\n\n\t\t\telse if(!subobj.hasOwnProperty(keypath[0])){\n\t\t\t\t//...having nothing also means that's impossible, but here we offer an option, see arg #3\n\t\t\t\tif(returnLastObject)\n\t\t\t\t\t//To know if this is not the desired position, the caller has to confirm that keypath isn't empty\n\t\t\t\t\treturn subobj;\n\t\t\t\telse\n\t\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t//We've now confirmed there's one more step available, go there and restart loop\n\t\t\tsubobj=subobj[keypath[0]];\n\t\t\taddress.push(keypath.shift());\n\t\t\t// _log.debug(address.join('.'),subobj)\n\t\t}\n\n\t\t//At this point we've successfully navigated to the desired location, so return the value there\n\t\treturn subobj;\n\t}\n\n\n\n\t/*\n\t* Set a nested child on a multi-level object or array\n\t*\n\t* @param obj array|object\n\t* @param keys array \t\tArray of keys, each pointing to one level deeper. NOTE: this array is altered\n\t* @param mixed value \t\t\n\t* @param bool create \t\tDefault false. If true the path will be created (with objects only)\n\t*\n\t* @throws TypeError \t\tSee nestedGet.\n\t* @return mixed  \t\t\tThe value set\n\t*/\n\tfunction nestedSet(obj,keys,value,create=false){\n\t\t// _log.traceFunc(arguments);\n\t\t//First check arg#2, and use it to get the object we're setting on\n\t\tvX.checkType('array',keys); //throw typeerror\n\t\tvar key=keys.pop();\n\t\tif(!key)\n\t\t\t_log.throw(\"No keys specified, cannot set value on object: \",value,obj);\n\n\t\t//For logging vv, we need an un-altered keys array so we can determine where a nested value waa\n\t\tvar _keys=vX.copy(keys);\n\n\t\t//Get the nested object we'll be setting on (also works if $keys are now empty)\n\t\tvar subobj=nestedGet(obj,keys,true); //true=>return last existing object so we can create the \n\t\tlet address=_keys.splice(-keys.length).join(); //_keys=[1,2,3]  keys=[2,3]  =>  1.2\n\t\tif(create){\t\t\t\t\t\t\t\t\t\t\t//      rest here\n\t\t\t//If any keys didn't exist, we create them now\n\t\t\tvar k;\n\t\t\twhile(k=keys.shift()){\n\t\t\t\tsubobj[k]={}; //create the next level\n\t\t\t\tsubobj=subobj[k]; //move the \"pointer\", if you will, to that level\n\t\t\t}\n\t\t\t\n\t\t}else if(keys.length){\n\t\t\t_log.makeError(`Not creating @ '${address}':`,obj).throw();\n\t\t}\n\t\t\t\n\n\t\tif(typeof subobj!='object') //array or object works\n\t\t\t_log.throw(`Not an object @ '${address}':`,obj)\n\t\t\n\n\t\t//If we're still running here. obj will be the object we're setting on, key the prop we're setting and value \n\t\t//the value, so just get on with it and return\n\t\treturn subobj[key]=value;\n\t}\n\n\n\t/*\n\t* Assign to nested objects without overwriting non-mentioned props\n\t*\n\t* @param object target \tThe object that gets changed\n\t* @param object obj \tThe object with new data to be assigned to $target\n\t*\n\t* {type:{\t\t\t\t{type:{\t\t\t\t\t{type:{\n\t*\tshape:'round'   +     \tcolor:'blue'\t=\t\tshape:'round'\n\t*\t,color:'red'}\t\t}}\t\t\t\t\t\t\t,color:'blue'}\n\t* ,weight:4}    \t\t\t\t\t\t\t\t,weight:4}\n\t*\n\t* @throws <ble TypeError>\n\t*\n\t* @return object \t\t$target\n\t*/\n\tfunction nestedAssign(target,data){\n\t\tvX.checkTypes(['object','object'],arguments);\n\t\tvar delim='<&@%>'; //any random string that is sure not to exist in a key\n\t\tvar arr=flattenObject(data,delim);\n\t\tObject.entries(arr).forEach(([address,value])=>nestedSet(target,address.split(delim),value,'create'));\n\t\treturn target;\n\t}\n\n\n\t/*\n\t* Get prop from each nested child object in an object\n\t*/\n\tfunction getChildProps(obj,prop,onMissing){\n\t\tvar ret={}\n\t\t\t,types=vX.checkTypes([['object','array'],['string','array']],[obj,prop])\n\t\t;\n\t\t\n\t\t//So we don't have to check on every prop, do 1 of 2 loops\n\t\tif(types[1]=='string'){\n\t\t\t//...getting prop on the base object\n\t\t\tObject.entries(obj).forEach(([key,child])=>{\n\t\t\t\tif(child.hasOwnProperty(prop))\n\t\t\t\t\tret[key]=child[prop]\n\t\t\t\telse if(onMissing!=undefined)\n\t\t\t\t\tret[key]=onMissing\n\t\t\t\t//if onMissing is not set, the key is not included\n\t\t\t})\n\t\t}else{\n\t\t\t//Get nested prop\n\t\t\tObject.entries(obj).forEach(([key,child])=>{\n\t\t\t\ttry{\n\t\t\t\t\tvar val=nestedGet(child,prop);\n\t\t\t\t}catch(err){\n\t\t\t\t\tval=undefined\n\t\t\t\t}\n\n\t\t\t\t//Loop early if the prop doesn't exist and arg#3 is undef\n\t\t\t\tif(val==undefined && onMissing==undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tret[key]=val\n\t\t\t})\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* From: \n\t*\t{\t\t\t\t\t\t\t\t\t\t\t[\n\t*\t\tBob:{age:44,gender:'Male'}\t\t\t\t\t0:{age:44,gender:'Male'}\n\t*\t\t,Steve:{age:82,gender:'Male'}\t\t\t\t,1:{age:82,gender:'Male'}\n\t*\t\t,Sue:{arge:24,gender:'Female'}\t\t\t\t,2:{arge:24,gender:'Female'}\n\t*\t}\t\t\t\t\t\t\t\t\t\t\t]\n\t*\n\t* To:\n\t*\t{\t\t\t\t\t\t\t\t\t\t\t{\n\t*\t\tMale:{\t\t\t\t\t\t\t\t\t\tMale:{\n\t*\t\t\tBob:{age:44,gender:'Male'}\t\t\t\t\t0:{age:44,gender:'Male'}\n\t*\t\t\t,Steve:{age:82,gender:'Male'}\t\t\t\t,1:{age:82,gender:'Male'}\n\t*\t\t}\t\t\t\t\t\t\t\t\t\t\t}\n\t*\t\t,Female:{\t\t\t\t\t\t\t\t\t,Female:{\n\t*\t\t\tSue:{age:24,gender:'Female'}\t\t\t\t2:{age:24,gender:'Female'}\n\t*\t\t}\t\t\t\t\t\t\t\t\t\t\t}\n\t*\t}\t\t\n\t*\n\t* @param \t\t\t\t\t\t\t\t\t\n\t*/\n\tfunction groupChildrenByProp(obj,prop,...optional){\n\t\tvX.checkTypes([['object','array'],'string'],[obj,prop])\n\t\t\n\t\tvar onMissing='undefined',extract=false;\n\t\toptional.forEach((x,i)=>{\n\t\t\tswitch(typeof x){\n\t\t\t\tcase 'boolean': \n\t\t\t\t\textract=x; break;\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'string': \n\t\t\t\t\tif(x=='extract')\n\t\t\t\t\t\textract=true;\n\t\t\t\t\telse\n\t\t\t\t\t\tonMissing=x; \n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.makeError(`Arg #${i+2} can be string/number/boolean, got:`,x).throw('TypeError');\n\t\t\t}\n\t\t})\n\n\t\tvar ret={};\n\t\tObject.entries(obj).forEach(([key,child])=>{\n\t\t\tvar v=child[prop]||onMissing;\n\t\t\tv=(typeof v=='number'?v:String(v));\n\t\t\tret[v]=ret[v]||{}\n\t\t\tret[v][key]=child;\n\t\t\tif(extract) delete child[prop];\n\t\t})\n\t\treturn ret;\n\t}\n\n\t/*\n\t* From:\n\t*\t{\n\t*\t\tfoo:'bar'\n\t*\t\t,cat:true\n\t*\t\t,hat:'bar'\n\t*\t}\n\t*\n\t*  To:\n\t*  \t{\n\t*\t\tbar:['foo','hat']\n\t*\t\t,true:['cat']\n\t*  \t}\n\t*/\n\tfunction groupKeysByValue(obj){\n\t\tvX.checkType(['object','array'],obj)\n\t\tvar grouped={},key;\n\t\tfor(key in obj){\n\t\t\tif(!grouped.hasOwnProperty(key))\n\t\t\t\tgrouped[key]=[];\n\t\t\tgrouped[key].push(obj[key]);\n\t\t}\n\t}\n\n\n\n\n\tfunction argObjToArr(obj){\n\t\tvar arr=[], key;\n\n\t\tfor(key in obj){\n\t\t\tarr.push(key);\n\t\t\tarr.push(obj[key]);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/*\n\t* Turn object of nested objects into array of nested objects, moving the key in the parent object\n\t* into each child\n\t*\n\t* @param object obj\n\t* @param string propName\n\t*\n\t* @return array\n\t*/\n\tfunction nestedObjToArr(obj, propName='id'){\n\t\tvar key, arr=[];\n\t\tfor(key in obj){\n\t\t\tlet x={};\n\t\t\tx[propName]=key;\n\t\t\tarr.push(Object.assign(x,obj[key]));\n\t\t}\n\t\treturn arr;\n\t}\n\n\t/*\n\t* @param object|array obj \n\t* @param function callback \tWill be called with the current object and the key\n\t*\n\t* @return object|array \t\tThe passed in $obj \t\t\n\t*/\n\tfunction forEachNestedPrimitive(obj,callback){\n\t\tvX.checkType(['object','array'],obj);\n\t\tfunction recurs(obj){\n\t\t\tfor(let key in obj){\n\t\t\t\tif(vX.checkType(['object','array'],obj[key],true))\n\t\t\t\t\trecurs(obj[key]);\n\t\t\t\telse\n\t\t\t\t\tcallback(obj,key);\n\t\t\t}\n\t\t}\n\t\trecurs(obj);\n\t\treturn obj;\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Turn an object into a legal query string\n\t*\n\t* @param object obj \tEg. {hello:\"bob\",foo:[\"bar\",\"car\"]}\n\t*\n\t* @see string.util.js:queryStrToObj()\n\t*\n\t* @throw <ble.TypeError>\n\t* @return string \t\tEg. \"hello=bob&foo[]=bar,car\". NOTE: no leading '?' or '#'\n\t*/\n\tfunction objToQueryStr(obj){\n\t\tvX.checkType('object',obj);\n\t\tvar parts=[],key,value;\n\t\tfor(key in obj){\n\t\t\tvalue=obj[key];\n\t\t\t\n\t\t\t//For all-primitive, arrays we use the special syntax: key[]=item1,item2\n\t\t\tif(Array.isArray(value) && vX.allPrimitive(value)){\n\t\t\t\tkey+='[]'\n\t\t\t\tvalue=value.join(',');\n\t\t\t}\n\n\t\t\tif(typeof value=='object'){\n\t\t\t\tvalue=JSON.stringify(obj);\n\t\t\t}\n\n\t\t\t//Empty string, null and undefined all get turned into empty string\n\t\t\tif(vX.isEmpty(value,null)){ //null is normally considered non-empty\n\t\t\t\tvalue=''\n\t\t\t}\n\t\t\tparts.push(key+'='+encodeURIComponent(value));\n\t\t}\n\t\treturn parts.join('&');\n\t}\n\n\n\n\treturn _exports;\n\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/obj.util.js?");

/***/ }),

/***/ "./util/common/promise.util.js":
/*!*************************************!*\
  !*** ./util/common/promise.util.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/promise.util.js\n//simpleSourceMap2=/lib/util/common/promise.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to PROMISES\n*/\n \n\nmodule.exports=function export_pX({_log,vX}){\n\n\n\t//Export\n\tvar _exports={\n\t\t'sleep':sleep\n\t\t,'toPromise':toPromise\n\t\t,'applyPromise':applyPromise\n\t\t,'createPromiseFunc':createPromiseFunc\n\t\t,promisify //alias for ^\n\t\t,'awaitAllPromises':awaitAllPromises\n\t\t,'firstResolved':firstResolved\n\t\t,'InspectablePromise':InspectablePromise\n\t\t,'promiseTimeout':promiseTimeout\n\t\t,'rejectTimeout':rejectTimeout\n\t\t,'exposedPromise':exposedPromise\n\t\t,'groupPromises':groupPromises\n\t\t,'thenCallback':thenCallback\n\t\t,'promiseAlways':promiseAlways\n\t\t,promisifyCallback\n\t}\n\n\n\t/*\n\t* Simulate sleeping by creating a promise that resolves x ms later\n\t*\n\t* NOTE: This function should be called with the 'await' prefix from within an 'async' function\n\t* \n\t* @param integer ms \tThe number of milliseconds to sleep\n\t* @param bool \t log \tIf true, a message will be logged to the console before and after sleeping\n\t*\n\t* @return Promise  \t\t\n\t*/\n\tfunction sleep(ms,returnValue=undefined,log=null){\n\t\tif(log && log instanceof _log)\n\t\t\tlog.debug(\"Going to sleep for \"+ms+\" ms...\");\n\n\t    return new Promise(resolve=>{\n\t        setTimeout(()=>{\n\t        \tif(log && log instanceof _log)\n\t        \t\tlog.debug('...waking up');\n\t        \t\n\t        \tresolve(returnValue);\n\t        },ms)\n\t    })\n\t}\n\n\n\t/*\n\t* Turn smth into a promise. \n\t*\n\t* @param function|<Promise>|any x \tNOTE: if function, it will be called immediately\n\t*\n\t* @return <Promise> \tDepending on what's passed in, this will return:\n\t*\t\t<Promise> --> same promsie\n\t*\t\tfunction  --> executes function inside a promise, then returns the promise\n\t* \t\tany       --> same variable, wrapped in resolved promise\n\t*/\n\tfunction toPromise(x){\n\t\tif(x instanceof Promise)\n\t\t\treturn x\n\t\telse if(typeof x =='function')\n\t\t\treturn applyPromise(x)\n\t\telse\n\t\t\treturn Promise.resolve(x);\n\t}\n\n\n\t/*\n\t* Call a function and return a promise that resolves/rejects with result\n\t*/\n\tfunction applyPromise(func,args,callAs){\n\t\ttry{\n\t\t\tvX.checkType('function',func);\n\t\t\t\n\t\t\tif(vX.varType(args)!='array')\n\t\t\t\targs=[args];\n\n\t\t\tif(vX.varType(callAs)!='object')\n\t\t\t\tcallAs=this;\n\n\t\t\treturn new Promise(async function _applyPromise(resolve,reject){\n\t\t\t\ttry{\n\t\t\t\t\tvar data=await func.apply(callAs,args);\n\t\t\t\t\tresolve(data);\n\t\t\t\t}catch(err){\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}catch(err){\n\t\t\treturn _log.reject('Failed to wrap function in promise.',err);\n\t\t}\n\t}\n\n\t/*\n\t* Wrap a function in another function that ensures the returned value\n\t* will be a Promise.\n\t*\n\t* NOTE: this does NOT call the function, only wraps it for future calls\n\t*\n\t* @param function func\n\t* @opt object callAs\n\t*\n\t* @return function\n\t*/\n\tfunction createPromiseFunc(func,callAs){\n\t\tvX.checkType('function',func);\n\t\treturn (function(...args){\n\t\t\ttry{\n\t\t\t\tPromise.resolve(func.apply(callAs||this,args))\n\t\t\t}catch(err){\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\t\t})\n\t}\n\tvar promisify=createPromiseFunc\n\n\n\n\n\n\n\t/*\n\t* Wait for all promises to finish (not like Promise.all that rejects on the first reject)\n\t*\n\t* @param array promises \tAn array of Promise objects\n\t* @param array options \t\tOptional. Array of string option flags. Available are:\n\t*\t\t'flatten' \t\t- Un-nest recursive/nested calls to this function\n\t*\t\t'alwaysResolve' - Even if some @promises reject, resolve with retObj (object)\n\t*\t\t'onlyResolved' \t- Even if some @promises reject, resolve with retObj.resolved (array)\n\t*\t\t'logRejected' \t- Log all the rejected promises\n\t* \t\t'timeout' \t\t- This rejects early if timeout reached. Next item in array must be number of ms. \n\t*\t\t\t\t\t\t\tNOTE: promises will keep executing after timeout fires\n\t*\t\t'array' \t\t- Return array of arrays (@see retObj.all)\n\t*\t\t\n\t*\n\t* @return Promise(array|object) \t\t@see @options. Default: If any @promises are rejected this rejects with an object \n\t*\t\t\t\t\t\t\t\t\t\twith props 'resolved', 'rejected' (arrays of resulting values with indexes retained \n\t*\t\t\t\t\t\t\t\t\t\tfrom @promises) and 'all' (array or arrays [bool, value]). If all @promises resolve\n\t*\t\t\t\t\t\t\t\t\t\tthis resolve with an array of those values.\n\t*/\n\tfunction awaitAllPromises(promises,options=[],...opts){\n\n\t\t_log.makeEntry('note',\"TODO: replace call to awaitAllPromises() with groupPromises()\")\n\t\t\t.changeWhere(1).highlight('blue');\n\n\t\tvX.checkType('array',promises);\n\t\tif(!Array.isArray(options)){\n\t\t\topts.unshift(options);\n\t\t\toptions=opts;\n\t\t}\n\n\n\t\tvar anyErrors=false;\n\n\t\t//Prepare the return object outside main promise so we can reject with it if option timeout triggers\n\t\tvar retObj={\n\t\t\tresolved:[]\n\t\t\t,rejected:[]\n\t\t\t,all:[] //array of arrays, [result(true/false), value]\n\t\t\t,remaining:promises.length\n\t\t\t,promises:promises.map(toPromise) //make sure any functions get called and wrapped in promises\n\t\t\t,err:null\n\t\t\t,awaitAllPromises:null\n\t\t};\n\n\t\t//Loop through all promises and wrap them so they all...\n\t\tvar wrappedPromises=retObj.promises.map(p=>\n\t\t\tp.then(\n\t\t\t\tdata=>[true, data]\n\t\t\t\t,err=>{\n\t\t\t\t\tanyErrors=true;\n\t\t\t\t\treturn [false, err];\n\t\t\t\t}\n\t\t\t) //...resolve with an array [result, value]\n\t\t\t.then(arr=>{retObj.remaining-=1;return arr}) //...decrease 'remaining' counter (good if timeout used)\n\t\t);\n\n\t\t//...^^ array can now be passed to Promise.all without it finishing on the first reject\n\t\tretObj.awaitAllPromises=Promise.all(wrappedPromises).then(retArr=>{\t//because we handled everything ^^ => nothing here will fail\n\t\t\ttry{\n\n\t\t\t\t//Before we do anything else, if we want to flatten (usefull if this func is called multiple times)...\n\t\t\t\tif(options.indexOf('flatten')>-1){\n\t\t\t\t \t//...check if any of the promises produced a value containing the special flag we set below for \n\t\t\t\t \t//this very purpose. NOTE: this resets the indexes so they mean nothing...\n\t\t\t\t\tvar tmp=[];\n\t\t\t\t\tretArr.forEach(([success,val])=>{\n\t\t\t\t\t\tswitch(val.__awaitAllPromises__){\n\t\t\t\t\t\t\tcase 'mixed_array':\n\t\t\t\t\t\t\t\ttmp=tmp.concat(val);\n\t\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\t\ttmp=tmp.concat(val.rejected.map(v=>[false,v]));\n\t\t\t\t\t\t\t\tval=val.resolved; // same handling vv, don't break;\n\t\t\t\t\t\t\tcase 'resolved_array':\n\t\t\t\t\t\t\t\ttmp=tmp.concat(val.map(v=>[true,v]));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ttmp.push([success,val]); \n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tretArr=tmp;\n\t\t\t\t}\n\n\t\t\t\t//Set on return obj\n\t\t\t\tretObj.all=retArr;\n\t\t\t\t\n\n\t\t\t\t//Split resolved/rejected and set on return obj\n\t\t\t\tretArr.forEach(([success,val],i)=>{\n\t\t\t\t\tif(success==true)\n\t\t\t\t\t\tretObj.resolved[i]=val; \t//NOTE: since keys are not consecutive, console.log will look eg.  \n\t\t\t\t\telse\t\t\t   \t\t\t\t// \t\t\t[<4 empty items>,'foo',<2 empty items>,'bar']\n\t\t\t\t\t\tretObj.rejected[i]=val;\n\t\t\t\t});\n\n\t\t\t\t//If any ^^ rejected, set an error that says so \n\t\t\t\tif(retObj.rejected.length && !retObj.err) //don't overwrite timeout err set vv\n\t\t\t\t\tretObj.err=(retObj.rejected.length+' promises rejected, those with index: '+Object.keys(retObj.rejected).join(','));\n\n\n\t\t\t\t//To enable the functionality of 'flatten' option, add a flag on both object and arrays ^^\n\t\t\t\tObject.defineProperty(retObj.resolved,'__awaitAllPromises__',{value:'resolved_array'});\n\t\t\t\tObject.defineProperty(retObj,'__awaitAllPromises__',{value:'object'});\n\t\t\t\tObject.defineProperty(retArr,'__awaitAllPromises__',{value:'mixed_array'});\n\t\t\t\t// retObj.rejected.prototype.__awaitAllPromises__=true; //not needed because it's never returned...\n\n\n\t\t\t\t//If we want to log all rejected\n\t\t\t\tif(options.indexOf('logRejected')>-1){\n\t\t\t\t\tvar l=retObj.promises.length;\n\t\t\t\t\tretObj.rejected.forEach((err,i)=>_log.makeError(err)\n\t\t\t\t\t\t.addHandling(`This was promise ${i+1} of ${l} passed to awaitAllPromises().`).exec());\n\t\t\t\t}\n\n\t\t\t\tif(options.indexOf('array')>-1)\n\t\t\t\t\treturn anyErrors ? Promise.reject(retArr) : Promise.resolve(retArr);\n\n\t\t\t\telse if(options.includes('alwaysResolve'))\n\t\t\t\t\treturn Promise.resolve(retObj);\n\n\t\t\t\telse if(options.indexOf('onlyResolved')>-1 || !anyErrors)\n\t\t\t\t\t//Grab only the resolved ones as array(retain index)(may be empty array), and resolve\n\t\t\t\t\treturn Promise.resolve(retObj.resolved);\n\n\t\t\t\telse\n\t\t\t\t\treturn Promise.reject(retObj)\n\n\t\t\t}catch(err){\n\t\t\t\t_log.error(\"BUGBUG awaitAllPromises():\",err);\n\t\t\t\treturn Promise.reject(retObj);\n\t\t\t}\n\t\t})\n\n\t\tvar i=options.indexOf('timeout')\n\t\tvar timeout=options[i+1];\n\t\tif(i>-1 && typeof timeout=='number'){\n\t\t\treturn Promise.race([\n\t\t\t\tretObj.awaitAllPromises\n\t\t\t\t,sleep(timeout).then(()=>{\n\t\t\t\t\tretObj.err='timeout'\n\t\t\t\t//TODO 2019-09-13: This should instead prompt ^^ to finish in the same way it would have otherwise...\n\t\t\t\t//\t\t\t\t\tso at least we get the data we have...\n\t\t\t\t\treturn Promise.reject(retObj);\n\t\t\t\t})\n\t\t\t]);\n\n\t\t}else\n\t\t\treturn retObj.awaitAllPromises;\n\n\t\t\n\t}\n\n\n\n\t/*\n\t* @return Promise(mixed,err)\tResolves with value of first resolved promise, rejects if none resolve\n\t*/\n\tfunction firstResolved(promises,logRejected=false){\n\t\tvar stack=new Error().stack; //to use in error below vv\n\n\t\treturn new Promise(function _firstResolved(resolve,reject){\n\t\t\tvX.checkTypes(['array','boolean'],[promises,logRejected]);\n\n\t\t\tlet l=promises.length, errs=[];\n\t\t\tvar e=0,success=false;\n\t\t\tpromises.map(p=>toPromise(p) //make sure any functions get called and wrapped in promises\n\t\t\t\t.then(\n\t\t\t\t\tdata=>{\n\t\t\t\t\t\tif(!success){\n\t\t\t\t\t\t\tsuccess=true;\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}else if(logRejected){\n\t\t\t\t\t\t\tlog.note(\"More than one promise resolved:\",data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t,err=>{\n\t\t\t\t\t\t//Log or save error\n\t\t\t\t\t\tif(logRejected)\n\t\t\t\t\t\t\tlog.error(err);\n\t\t\t\t\t\telse if(!success)\n\t\t\t\t\t\t\terrs.push(err);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//If all promises have finised and we still don't have success, reject\n\t\t\t\t\t\te++\n\t\t\t\t\t\tif(e>=l && !success){\t\n\t\t\t\t\t\t\treject(log.makeError(`All ${l} promises rejected.`,\n\t\t\t\t\t\t\t\tlogRejected?\"See previous logs\":errs).setStack(stack)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t) \n\t\t\t)\n\t\t})\n\t}\n\n\n\n\t/*\n\t* @constructor\n\t*/\n\tfunction InspectablePromise(promise){\n\t\tthis.status='pending';\n\t\tthis.result=undefined;\n\n\t\tvar {promsie:promise2,resolve,reject}=exposedPromise();\n\n\t\tvar _private={\n\t\t\tresolvedHandler:null\n\t\t\t,rejectHandler:null\n\t\t}\n\n\n\t\t//When the actual promise resolves/rejects, just store the result\n\t\tpromise.then(\n\t\t\t\tdata=>{\n\t\t\t\t\tif(this.status=='pending'){\n\t\t\t\t\t\tthis.status='resolved';\n\t\t\t\t\t\tthis.result=data;\n\t\t\t\t\t\tif(typeof _private.resolveHandler=='function')\n\t\t\t\t\t\t\tresolve(_private.resolveHandler(data));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t,err=>{\n\t\t\t\t\tif(this.status=='pending'){\n\t\t\t\t\t\tthis.status='rejected';\n\t\t\t\t\t\tthis.result=err;\n\t\t\t\t\t\tif(typeof _private.rejectHandler=='function')\n\t\t\t\t\t\t\tresolve(_private.rejectHandler(err));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t;\n\n\t\t//Bring these methods to surface\n\t\tthis.then=(resolveHandler,rejectHandler)=>{\n\n\t\t\tswitch(this.status){\n\t\t\t\tcase 'pending':\n\t\t\t\t\t_private.resolveHandler=resolveHandler;\n\t\t\t\t\t_private.rejectHandler=rejectHandler;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'resolved':\n\t\t\t\t\tif(typeof resolveHandler=='function')\n\t\t\t\t\t\tresolve(resolveHandler(this.result));\n\t\t\t\tcase 'timeout':\n\t\t\t\tcase 'rejected':\n\t\t\t\t\tif(typeof rejectHandler=='function')\n\t\t\t\t\t\treturn resolve(rejectHandler(this.result))\n\t\t\t\t\telse \n\t\t\t\t\t\treturn reject(this.result);\n\n\t\t\t}\n\n\t\t\treturn promise2;\n\t\t}\n\n\t\tthis.catch=(rejectHandler)=>{\n\t\t\tif(typeof rejectHandler=='function'){\n\t\t\t\tif(this.status=='rejected')\n\t\t\t\t\tresolve(rejectHandler(this.result))\n\t\t\t\telse \n\t\t\t\t\t_private.rejectHandler=rejectHandler;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn promise2;\n\t\t}\n\t}\n\n\n\n\n\n\t/*\n\t* Add timeout to a promise or function (func will be called)\n\t*\n\t* @return Promise(any, any|Promise)\n\t*/\n\tfunction promiseTimeout(promise,timeout=1,rejectValue='timeout'){\n\t\tpromise=toPromise(promise);\n\t\treturn Promise.race([\n\t\t\tpromise\n\t\t\t,sleep(timeout).then(()=>{\n\t\t\t\tif(arguments.length==3){\n\t\t\t\t\t//Since we're abandoning it, we can't have it fail async silently...\n\t\t\t\t\tpromise.catch(_log.error); \n\t\t\t\t\treturn Promise.reject(rejectValue)\n\t\t\t\t}else{\n\t\t\t\t\t//rejecting with promise object doesn't wait for it to finish, but the caller\n\t\t\t\t\t//can add their own handling to it\n\t\t\t\t\treturn Promise.reject(promise) \n\t\t\t\t}\n\n\t\t\t})\n\t\t]);\n\t\t\n\t}\n\n\n\n\n\n\n\t/*\n\t* Add timeout ability given the resolve/reject functions of a Promise. Said timeout can easily be cleared (@see return)\n\t*\n\t* @return object{resolve,reject,clear} \tReturns 3 functions, new resolve and reject, and a clear timeout\n\t*/\n\tfunction rejectTimeout(resolve,reject,timeout){\n\t\tvX.checkTypes(['function','function','number'],[resolve,reject,timeout]);\n\n\t\t// console.log('setting timeout');\n\t\tlet id=setTimeout(()=>{\n\t\t\t// console.log('rejected about to time out');\n\t\t\treject('timeout');\n\t\t},timeout);\n\n\t\tvar clear=()=>{clearTimeout(id);};\n\t\t\n\t\t// console.log('creating new resolve');\n\t\tvar newResolve=function(x){\n\t\t\t// console.log('new resolve called');\n\t\t\tclearTimeout(id);\n\t\t\tresolve(x);\n\t\t}\n\n\t\tvar newReject=function(x){\n\t\t\tclearTimeout(id);\n\t\t\treject(x);\t\n\t\t}\n\t\t// console.log('returning new resolve');\n\t\treturn {resolve:newResolve,reject:newReject,clear:clear};\n\t}\n\n\n\t/*\n\t* Create a Promise, breakout resolve and reject, return as object. That way you can return the promise while\n\t* keeping resolve/reject to use async\n\t*\n\t* @return object{promise,resolve,reject,callback[,clear]}\n\t*/\n\tfunction exposedPromise(timeout=null){\n\t\tvar inspect={status:'pending',result:undefined,done:false}\n\t\t\t,ret={inspect}\n\t\t\t,promise = new Promise((resolve,reject)=>{\n\t\t\t\tret.resolve=resolve;\n\t\t\t\tret.reject=reject;\n\t\t\t})\n\t\t;\n\n\t\tret.promise=promise.then(\n\t\t\tdata=>{ret.inspect.done=true;ret.inspect.status='resolved';ret.inspect.result=data;return data}\n\t\t\t,err=>{ret.inspect.done=true;ret.inspect.status='rejected';ret.inspect.result=err;return Promise.reject(err)}\n\t\t);\n\n\n\t\tif(typeof timeout=='number'){\n\t\t\tObject.assign(ret,rejectTimeout(ret.resolve,ret.reject,timeout));\n\t\t}\n\n\n\t\tret.callback=function(err,data){return err ? ret.reject(err) : ret.resolve(data)};\n\n\t\treturn ret;\n\t}\n\n\n\n\t/*\n\t* Exposes a group of promises, see @return\n\t*\n\t* @param array promises \tAll items will be sent to @see toPromise()\n\t* @param @opt <BetterLog>   Will log.error(reject) and log.trace(resolve)\n\t* @param @opt <Emitter>  \tAny object with 'emit' method. Emits 'resolve','reject','finished'\n\t*\n\t* @return object \tSee top and bottom of function body\n\t*/\n\tfunction groupPromises(promises,...optional){\n\t\t\n\t\tvX.checkTypes(['array'],[promises]); //use typeS so it throws 'arg #1...'\n\n\t\t//Grab optional args\n\t\tvar i=optional.length-1,log,emitter;\n\t\tfor(i;i>=0;i--){\n\t\t\tlet x=optional[i];\n\t\t\tif(x && typeof x=='object'){\n\t\t\t\tif(x.constructor.name=='BetterLog')\n\t\t\t\t\tlog=x;\n\t\t\t\telse if(typeof x.emit=='function')\n\t\t\t\t\temitter=x;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Make sure we have an array of promises. This will call any functions, wrap any values etc.\n\t\tpromises=promises.map(toPromise)\n\n\t\t//Prepare the return object \n\t\tvar r={\n\t\t\tresolved:[]  \t//array[any] - indexes match $promises (implies holes), values are resolved data\n\t\t\t,rejected:[]    //array[any] - indexes match $promises (implies holes), values are rejected err\n\t\t\t,all:[] \t\t//array[any] - indexes match $promises, [[result(true/false), value],...]\n\t\t\t,promises: promises  //array[<Promise>]\n\t\t\t,err:null \t\t //string - 'x of y promises rejected, z remaining'\n\t\t};\t\n\t\tObject.defineProperty(r,'remaining',{enumerable:true,get:()=>{return r.promises.length-Object.keys(r.all).length}});\n\n\t\t//2019-11-28: NO, do not do this vv. If you do this r.promise never resolves... for some reason\n\t\t//Add shortcuts to...\n\t\t// r.then=r.promise.then.bind(r.promise)\n\t\t// r.catch=r.promise.catch.bind(r.promise)\n\n\n\t\t//Loop through the promises and handle, ie. creating a new array of promises \n\t\t//that will all resolve AND at the same time populate the arrays of the return obj\n\t\tlet l=r.promises.length;\n\t\tvar handledPromises=r.promises.map((groupedPromise,i)=>groupedPromise\n\t\t\t.then(\n\t\t\t\tresolved=>{\n\t\t\t\t\tr.resolved[i]=resolved; \n\t\t\t\t\tr.all[i]=[true, resolved]\n\t\t\t\t\t\n\t\t\t\t\tif(log)\n\t\t\t\t\t\tlog.trace(`Promise #${i} resolved (${r.remaining} remaining) with:`,resolved);\n\t\t\t\t\tif(emitter)\n\t\t\t\t\t\temitter.emit('resolve',resolved,i)\n\t\t\t\t}\n\t\t\t\t,rejected=>{\n\t\t\t\t\tr.rejected[i]=rejected; \n\t\t\t\t\tr.all[i]=[false, rejected]\n\n\t\t\t\t\t\n\t\t\t\t\tif(log)\n\t\t\t\t\t\tlog.makeError(rejected).addHandling(`Promise ${i+1} rejected (${r.remaining} remaining)`).exec();\n\t\t\t\t\tif(emitter)\n\t\t\t\t\t\temitter.emit('reject',rejected,i);\n\n\t\t\t\t\tvar msg=`${Object.keys(r.rejected).length} of ${l} promises rejected`\n\t\t\t\t\tif(r.remaining)\n\t\t\t\t\t\tmsg+=`, ${r.remaining} remaining`\n\t\t\t\t\tr.err=msg;\n\t\t\t\t}\n\t\t\t) \n\t\t\t.then(function allFinished(){\n\t\t\t\tif(r.remaining<1&&log){\n\t\t\t\t\tlog.trace(\"All grouped promises have finished\");\n\t\t\t\t\tif(emitter)\n\t\t\t\t\t\temitter.emit('finished',r);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\t//Finally, add a promise that resolves/rejects when all promises have finished\n\t\tr.promise=Promise.all(handledPromises).then(()=>(r.err?Promise.reject(r):r)) \n\n\n\t\treturn r;\n\t}\n\n\t\t\n\n\n\n\t/*\n\t* Call a callback on both success/fail in a promise flow, returning whatever the callback returns\n\t*\n\t* @param <Promise>|any promise \n\t* @param function(err,data) callback\n\t*\n\t* @return Promise  \t\t\t\n\t*/\n\tfunction thenCallback(promise,callback){\n\t\treturn Promise.resolve(promise).then(\n\t\t\tdata=>callback(null,data)\n\t\t\t,err=>callback(err)\n\t\t);\n\t}\n\n\n\t/*\n\t* Call a callback on both success/fail in a promise flow, resolveing/rejecting with the same value\n\t* that was passed in, ie. response from callback will be ignored\n\t*\n\t* @param <Promise>|any promise \t\t\t\n\t* @param function(err,data) callback\n\t*\n\t* @return Promise  \t\t\t\n\t*/\n\tfunction promiseAlways(promise,callback){\n\t\treturn Promise.resolve(promise).then(\n\t\t\tdata=>{callback(null,data); return data}\n\t\t\t,err=>{callback(err); return Promise.reject(err)}\n\t\t);\n\t}\n\n\n\n\t/*\n\t* Call an async function which is expecting a callback as last argument, returning a \n\t* promise instead\n\t*\n\t* @param function func\n\t* @opt any ...args\n\t*\n\t* @return Promise(any,err);\n\t*/\n\tfunction promisifyCallback(func,...args){\n\t\tvar {callback,promise}=exposedPromise();\n\t\targs.push(callback);\n\t\tfunc.apply(this,args)\n\t\treturn promise;\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/promise.util.js?");

/***/ }),

/***/ "./util/common/string.util.js":
/*!************************************!*\
  !*** ./util/common/string.util.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/string.util.js\n//simpleSourceMap2=/lib/util/common/string.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n\nmodule.exports=function export_stX({_log,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\tmd5hash\n\t\t,formatString\n\t\t,firstToUpper\n\t\t,firstToLower\n\t\t,toLower\n\t\t,trim\n\t\t,substring\n\t\t,replaceAll\n\t\t,escapeRegExp\n\t\t,regexpAll\n\t\t,limitString\n\t\t,split\n\t    ,splitAt\n\t    ,indexWords\n\t    ,linuxTableToObjects\n\t    ,wrapInBashColor\n\t    ,progressBar\n\t    ,queryStrToObj\n\t\t,dashToCamel\n\t\t,randomString\n\t\t,getUniqueString\n\t};\n\n\n\t/*\n\t* Get hexdec encoded md5 sum of string\n\t*\n\t* @param string str\n\t*\n\t* @return string \t\n\t*/\n\tfunction md5hash(str){\n\t\tif(typeof CryptoJS=='undefined')\n\t\t\tthrow new Error(\"Cannot find CryptoJS\");\n\t\tif(typeof str != 'string')\n\t\t\tthrow new TypeError(\"Can only hash strings\")\n\n\t\tvar hash = CryptoJS.MD5(str);\n\t\treturn hash.toString(CryptoJS.enc.hex);\n\t}\n\n\n\t/*\n\t* Format a string\n\t*\n\t* @param string format\n\t* @param string str\n\t*\n\t* @return string \t\tThe formated $str, or an empty string if no such format exists or\n\t*\t\t\t\t\t\t$str wasn't a string\n\t*/\n\tfunction formatString(format,str){\n\t\tif(typeof str!='string')\n\t\t\treturn '';\n\n\t\tswitch(format){\n\t\t\tcase 'firstToUpper':\n\t\t\tcase 'firstBig':\n\t\t\tcase 'capitalize':\n\t\t\t\treturn firstToUpper(str);\n\t\t\tcase 'firstToLower':\n\t\t\tcase 'firstSmall':\n\t\t\t\treturn firstToLower(str);\n\t\t\tcase 'toLowerCase':\n\t\t\tcase 'toLower':\n\t\t\tcase 'lower':\n\t\t\tcase 'low':\n\t\t\tcase 'small':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'toUpperCase':\n\t\t\tcase 'toUpper':\n\t\t\tcase 'upper':\n\t\t\tcase 'up':\n\t\t\tcase 'big':\n\t\t\tcase 'large':\n\t\t\tcase 'capitals':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/*\n\t* Capitalize first letter of string\n\t*\n\t* @param string str\n\t*\n\t* @return string\n\t*/\n\tfunction firstToUpper(str){\n\t\treturn str.charAt(0).toUpperCase() + str.slice(1);\n\t}\n\n\t/*\n\t* Un-capitalize first letter of string\n\t*\n\t* @param string str\n\t*\n\t* @return string\n\t*/\n\tfunction firstToLower(str){\n\t\treturn str.charAt(0).toLowerCase() + str.slice(1);\n\t}\n\n\t/*\n\t* Check if string, in which case make lowercaser, else return arg#2\n\t*\n\t* @param string \tstr\n\t* @param any \t\tdeflt\n\t*\n\t* @return string|@deflt\n\t*/\n\tfunction toLower(str,deflt=undefined){\n\t\treturn typeof str=='string' ? str.toLowerCase() : deflt;\n\t}\n\n\n\t/*\n\t* More capable substring function, able to start from end of string\n\t*/\n\tfunction substring(str,start,length){\n\t\tvX.checkType('string',str);\n\t\tif(start>str.length)\n\t\t\treturn '';\n\t\t\n\t\tif(start<0){\n\t\t\tstart=str.length+start;\n\t\t}\n\n\t\tvar finish=str.length;\n\t\tif(typeof length=='number')\n\t\t\tMath.min(start+length, str.length);\n\t\t\n\t\treturn str.substring(start,finish)\n\t}\n\n\n\n\t/*\n\t* Trim quotes, spaces and newlines from the start/end of a string\n\t*\n\t* @var string str \t\t\tAny string\n\t* @var bool   checkEmpty\tDefault false. If true an error is throw if not non-empty string\n\t*\n\t* @throw TypeError \t\t\tIf @str is not a string\n\t* @throw Error \t\t\t\tSee @checkEmpty\n\t*\n\t* @return string  \t\t\tThe trimmed string\n\t*/\n\tfunction trim(str,checkEmpty=false){\n\t\tif(typeof str!='string')\n\t\t\t_log.throwType('string',str);\n\n\n\t\tfunction replace(s){\n\t\t\treturn s\n\t\t\t\t.trim()\n\t\t\t\t.replace(/^[\"'\\n]+/,\"\")\n\t\t\t\t.replace(/[\"'\\n]+$/,\"\")\n\t\t\t\t.trim()\n\t\t\t;\n\t\t}\n\n\t\t//Call the above function repeatedly until the string stops changing\n\t\tvar s,i=0;\n\t\twhile(str!=(s=replace(str))){\n\t\t\tstr=s;\n\t\t\tif(++i>10){\n\t\t\t\t_log.warn(\"Exceeded 10 loops when trying to trim string...\")\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(checkEmpty && str=='')\n\t\t\tthrow new Error(\"String was empty\");\n\t\telse\n\t\t\treturn str;\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Replace all occurences of a substring. \n\t*\n\t* @param string target \t\t\tThe string to operate on\n\t* @param string search \t\t\tThe substring to remove\n\t* @param string replacement \tA substring to insert in replacement of @search\n\t*\n\t* @return string\n\t*/\n\tfunction replaceAll(target,search,replacement){\n\t\tif(target.length<40){\n\t\t\t//This is slower than using RegExp, but it does not rely on the search string being properly escaped, \n\t\t\t//and for a shorter string it may be quicker not to have to escape the search string\n\t\t\treturn target.split(search).join(replacement);\n\t\t}else{\n\t\t\t//This will be faster, but we have to make sure the search string is escaped first, which only makes\n\t\t\t//it worth it for slightly longer strings\n\t\t\tsearch=escapeRegExp(search);\n\t\t\treturn target.replace(new RegExp(search, 'g'), replacement);\n\t\t}\n\n\n\t}\n\n\t/*\n\t* Escape any regexp characters in a string so it can be used for exact matches in an actual RegExp\n\t*\n\t* Example: \t'hello.world'=>'hello\\.world'\n\t*\n\t* @return string\n\t*/\n\tfunction escapeRegExp(str) {\n\t\tvX.checkType('string',str)\n\t \treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n\t}\n\n\n\n\t/*\n\t* Get all matches for a regexp on a string, ie. run regexp.exec until it returns nothing\n\t*\n\t* NOTE: this only works if the 'g' flag is set, else RegExp.exec won't remember the position of the \n\t*       last match and you'll have an infinite loop on your hands... So if 'g' is not set, we do it for you\n\t*\n\t* @param <RegExp> regexp\n\t* @param string str\n\t* @param number maxMatches  Break loop if it matches more than this number. Default 0=infinite\n\t* \n\t* @return array[array,...] \tEach item is a match, ie. a child array. See \n\t*\t\t\thttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec#Description\n\t\t\n\t\tExample. \n\t\t\tregexp -->\t/(\\w+)ball/   \n\t\t\tstr    -->\t'football is better than basketball'\n\t\t\treturn -->\t[[football,foot],[basketball, basket]]\n\t*/\n\tfunction regexpAll(regexp, str,maxMatches=0){\n\t\t// vX.instanceOf(RegExp,regexp);\n\t\tvX.checkTypes(['<RegExp>','string'],[regexp,str]);\n\n\t\t//Make sure we have the g flag\n\t\tif(regexp.flags.indexOf('g')==-1){\n\t\t\t_log.debug(\"Adding 'g' flag to regexp else we cannot get all matches. \"+regexp);\n\t\t\tregexp=new RegExp(regexp.toString()+'g');\n\t\t}\n\n\t\tvar matches=[],match,i=0;\n\t\twhile((match=regexp.exec(str))!==null){\n\t\t\ti++;\n\t\t\tif(maxMatches && maxMatches<i){\n\t\t\t\t_log.warn(`Exceeded max matches (${maxMatches}), breaking early.`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatches.push(match);\n\t\t}\n\n\t\t// _log.trace('The regexp ('+String(regexp)+') matched '+matches.length+' times');\n\t\treturn matches;\n\t}\n\n\n\n\n\n\t/*\n\t* Make sure a string isn't too long by removing the middle of it\n\t*\n\t* @param string\n\t* @param number\n\t*\n\t* @return string\n\t*/\n\tfunction limitString(str,limit){\n\t\tvX.checkType('string',str);\n\t\tlet len=str.length;\n\t\tif(len>limit){\n\t\t\tvar half=Math.round(limit/2);\n\t\t\treturn str.substring(0,half)+' ...'+(len-limit)+'... '+str.substring(len-half);\n\t\t}else\n\t\t\treturn str;\n\n\t}\n\n\n\n\t/*\n\t* return array\n\t*/\n\tfunction split(str,delimit,lastDelimit){\n\t\ttry{\n\t\t\tvX.checkType('string',str);\n\t\t\tvar arr=str.split(delimit);\n\t\t\tvX.checkType(['array'],arr); //throw on fail\n\t\t\tif(lastDelimit){\n\t\t\t\tvar last=arr.pop();\n\t\t\t\tif(vX.checkType(['string'],last,true))\n\t\t\t\t\tarr.concat(last.split(lastDelimit))\n\t\t\t}\n\t\t\treturn arr;\n\t\t} catch(err){\n\t\t\t_log.throw(err);\n\t\t}\t\n\n\t}\n\n\t/*\n\t* Split a string at multiple locations\n\t*\n\t* @param string str \t\t\tString to split\n\t* @param array[number] splitArr Array of numbers where to split the string\n\t*\n\t* @return array\n\t*/\n\tfunction splitAt(str,splitArr){\n\t\tvX.checkTypes(['string','array'],arguments);\n\t\tvar arr=[],i;\n\t\tfor(i=0;i<splitArr.length;i++){\n\t\t\tarr.push(str.substring(splitArr[i],splitArr[i+1]).trim());\n\t\t}\n\t\treturn arr;\n\t}\n\n\n\t/*\n\t* From a string, get an object where keys are the starting index of each word and values are the word.\n\t*\n\t* @param string line \t\n\t*\n\t* @return obj \t\n\t*/\n\tfunction indexWords(line){\n\t\tvar obj={},i=0;\n\t\tline.match(/[^\\s]+(\\s+|$)/g).forEach(m=>{ //matches non-whitespace followed by whitespace (capture \n\t\t\t\t\t\t\t\t\t\t\t\t  //group not used for capturing, only regex syntax)\n\t\t\tobj[i]=m.trim(); //m is the full match (word+white), but we trim the white\n\t\t\ti+=m.length;//move index total length of match (word+white)\n\t\t\t//Now i is the starting index of the next word\n\t\t})\n\t\treturn obj;\n\t}\n\n\n\t/*\n\t* Turn the output from a linux command into an array of object (ie. one object per line)\n\t*\n\t* @param string|array stdout\n\t* @param @opt boolean headersToLowerCase\n\t* @param @opt boolean outputIsTerese \t\tDefault false. Set true if lines have spaces in columns \n\t*\t\t\t\t\t\t\t\t\t\t\t other than the before last one, eg:\n\t* \t\t\t\t\t\t\t\t\t\t\t\tname age hobby                weight\n\t*  \t \t\t\t\t\t\t\t\t\t\t\tBob  33 To go to the movies      70\n\t*\n\t* @return object\n\t*/\n\tfunction linuxTableToObjects(stdout, headersToLowerCase=false, outputIsTerese=false){\n\t\t//Make sure we have a string\n\t\tif(typeof stdout=='object' && stdout.hasOwnProperty('stdout'))\n\t\t\tstdout=stdout.stdout\n\n\t\t//Turn string into arr\n\t\tvar arr;\n\t\tif(Array.isArray(stdout))\n\t\t\tarr=stdout\n\t\telse{\n\t\t\tif(typeof stdout!='string')\n\t\t\t\tstdout=stdout.toString('utf8').trim();\n\n\t\t\tif(typeof stdout!='string')\n\t\t\t\t_log.throwType('string',stdout);\n\n\t\t\tarr=stdout.split('\\n')\n\t\t}\n\n\t\t//Make sure arr contains some non-empty lines\n\t\tvar arr=arr.map(line=>line.trim()).filter(line=>line);\n\t\tif(!arr.length)\n\t\t\treturn [];\n\n\t\t//extract the headers row and turn into array\n\t\ttry{\n\t\t\tvar headers=arr.splice(0,1)[0];\n\n\t\t\t//If output is terese, use special function to split...\n\t\t\tif(outputIsTerese){\n\t\t\t\tlet obj=indexWords(headers);\n\t\t\t\toutputIsTerese=Object.keys(obj);\n\t\t\t\theaders=Object.values(obj);\n\t\t\t}else{\n\t\t\t\theaders=headers.split(/\\s+/)\n\t\t\t}\n\n\t\t\tif(headersToLowerCase)\n\t\t\t\theaders=headers.map(header=>header.toLowerCase());\n\t\t\t// console.log('GOT HEADERS:',headers);\n\t\t}catch(err){\n\t\t\t_log.makeError('Failed to convert linux columns to array of objects.',err).throw();\n\t\t}\n\n\t\t//Now turn each row into an object, using the header for for prop names\n\t\treturn arr.map(line=>{\n\t\t\tvar values;\n\t\t\tif(outputIsTerese){\n\t\t\t\tvalues=splitAt(line,outputIsTerese);\n\t\t\t}else{\n\t\t\t\tvalues=line.split(/\\s+/);\t\t\t\t\t\t\t//BUG: this split combined with.... vv\n\t\t\t\t// log.info('GOT VALUES:',values);\n\n\t\t\t\t//Assume that only the last column has spaces... may NOT be the case...\n\t\t\t\tif(values.length>headers.length){\n\t\t\t\t\t//eg. \tname \t\tdescription \t=> ['name','description']\n\t\t\t\t\t//\t\tBob \t\tLikes to ski \t=> ['Bob','Likes','to','ski']\n\t\t\t\t\tlet lastCol=values.splice(headers.length-1).join(' ');\n\t\t\t\t\tvalues.push(lastCol);\n\t\t\t\t\t//now we have: ['Bob', 'Likes to ski']\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(values.length!=headers.length){\n\t\t\t\t_log.throw(\"Problem converting columns to array of objects. There are \"\n\t\t\t\t\t+`${headers.length} headers and ${values.length} values`,log.logVar(headers,1000), log.logVar(values,1000))\n\t\t\t}\n\n\t\t\tvar obj={};\n\t\t\tfor(let i in headers){\n\t\t\t\tobj[headers[i]]=values[i];\n\t\t\t}\n\t\t\treturn obj;\n\t\t})\n\t}\n\n\n\n\tvar bashColors={\n\t\t//Color\t\t\tText \tBackground\n\t\t'black'\t\t\t:['30'\t,'40']\n\t\t,'red'\t\t\t:['31'\t,'41']\n\t\t,'green'\t\t:['32'\t,'42']\n\t\t,'yellow'\t\t:['33'\t,'43']\n\t\t,'blue'\t\t\t:['34'\t,'44']\n\t\t,'magenta'\t\t:['35'\t,'45']\n\t\t,'cyan'\t\t\t:['36'\t,'46']\n\t\t,'white'\t\t:['37'\t,'47']\n\t\t,'brightblack'\t:['90'\t,'100']\n\t\t,'brightred'\t:['91'\t,'101']\n\t\t,'brightgreen'\t:['92'\t,'102']\n\t\t,'brightyellow'\t:['93'\t,'103']\n\t\t,'brightblue'\t:['94'\t,'104']\n\t\t,'brightmagenta':['95'\t,'105']\n\t\t,'brightcyan'\t:['96'\t,'106']\n\t\t,'brightwhite'\t:['97'\t,'107']\n\t}\n\n\t\t\t\n\n\n\tfunction wrapInBashColor(str,f,b){\n\t\tvar c;\n\t\tif(typeof f=='string'){\n\t\t\tf=f.toLowerCase().replace(' ','')\n\t\t\tif(bashColors.hasOwnProperty(f)){\n\t\t\t\tc=bashColors[f][0];\n\t\t\t\tstr='\\x1b['+c+'m'+str\n\t\t\t}\n\t\t}\n\n\t\tif(typeof b=='string'){\n\t\t\tb=b.toLowerCase().replace(' ','')\n\t\t\tif(bashColors.hasOwnProperty(b)){\n\t\t\t\tc=bashColors[b][1];\n\t\t\t\tstr='\\x1b['+c+'m'+str\n\t\t\t}\n\t\t}\n\n\t\tif(c)\n\t\t\tstr+='\\x1b[0m';\n\n\t\treturn str;\n\t}\n\n\n\n\tfunction progressBar(progress,totalLength=10,color=false,fill='x',empty='.'){\n\t\tvar prog=Math.round(progress*totalLength),rest=totalLength-prog\n\t\tfill=fill.repeat(prog);\n\t\tif(color)\n\t\t\tfill=wrapInBashColor(fill,color);\n\t\treturn '['+fill+empty.repeat(rest)+']';\n\n\t}\n\n\n\t/*\n\t* Turn a hash or search string into an object\n\t*\n\t* @param string str \tA query string like \"hello=bob&foo[]=bar,car\", with or without leading # or ?\n\t*\n\t* @see obj.util.js:objToQueryStr()\n\t*\n\t* @throw <ble.TypeError>\n\t* @return object \t\tEg. {hello:\"bob\",foo:[\"bar\",\"car\"]}\n\t*/\n\tfunction queryStrToObj(str){\n\t\tvX.checkType('string',str);\n\n\t\t//Remove leading ? or #\n\t\tif(str.substring(0,1)=='#'||str.substring(0,1)=='?')\n\t\t\tstr=str.substring(1);\n\n\t\tvar obj={},pairs = str.split('&'),i=pairs.length-1;\n\t    for (i;i>=0;i--) {\n\t    \ttry{\n\t\t        var pair = pairs[i].split('='),key=pair[0];\n\t\t        //Empty values are allowed (the key becomes a flag), but not missing keys\n\t\t        if(key){\n\t\t        \t//First turn obvious stuff into their real vartype, like numbers, null, undefined etc.\n\t\t        \tvar value=vX.stringToPrimitive(pair[1]);\n\t\t        \t// if it's still a string, decode it...\n\t\t        \tif(value && typeof value=='string'){\n\t\t        \t\tvalue=decodeURIComponent(value);\n\t\t        \t}\n\t\t        \t//The key could indicate that we have an array...\n\t\t\t        if(key.substring(key.length-2)=='[]'){\n\t\t\t        \tkey=key.substring(0,key.length-2);\n\t\t\t        \tif(vX.isEmpty(value)){ //null, undefined, empty string... but not false or 0\n\t\t\t        \t\tvalue=[]\n\t\t\t        \t}else if(typeof value=='string'){\n\t\t\t        \t\tvalue=value.split(',').map(vX.stringToPrimitive);\n\t\t\t        \t}else{\n\t\t\t        \t \tvalue=[value]; //could be '0' or 'false'\n\t\t\t        \t}\n\n\t\t\t        //Or the value could indicate that it's a json\n\t\t\t        }else if(value[0]=='{' || value[0]=='['){\n\t\t\t        \tvalue=vX.tryJsonParse(value) //will return parsed object or the same string on fail\n\t\t\t        }\n\t\t\t        obj[key]=value;\n\t\t        }\n\t    \t}catch(err){\n\t    \t\t_log.warn(\"Bad pair in uri string:\",pairs[i],str,err);\n\t    \t}\n\t    }\n\t    return obj;\n\t}\n\n\t/*\n\t* Convert \"hello-world\" => \"helloWorld\"\n\t*\n\t* @param string str\n\t* @return string\n\t*/\n\tfunction dashToCamel(str){\n\t\treturn str.replace(new RegExp('-([a-z])', 'g'), (match,capture)=>capture.toUpperCase())\n\t}\n\n\n\n\n\tfunction randomString(length=32, chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') {\n\t    var result = '';\n\t    for (var i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];\n\t    return result;\n\t}\n\n\n\tfunction getUniqueString(str, existing){\n\t\tvX.checkTypes(['string','array'],arguments);\n\n\t\tif(!existing.includes(str))\n\t\t\treturn str;\n\n\t\t//First try appending a number from 2 to 999\n\t\tvar i;\n\t\tfor(i=2;i<1000;i++){\n\t\t\tlet str2=str+'_'+String(i);\n\t\t\tif(!existing.includes(str2))\n\t\t\t\treturn str2;\t\t\n\t\t}\n\n\t\t//Then try 10 times to append a random string\n\t\ti=10;\n\t\twhile(i--){\n\t\t\tlet str2=str+'_'+randomString(10);\n\t\t\tif(!existing.includes(str2))\n\t\t\t\treturn str2;\t\t\t\n\t\t}\n\n\t\t//This is veeeeeeeeeeery unlikely...\n\t\t_log.throw(\"Could not find unique string\",arguments);\n\t}\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/string.util.js?");

/***/ }),

/***/ "./util/common/time.util.js":
/*!**********************************!*\
  !*** ./util/common/time.util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {//simpleSourceMap=/my_modules/util/common/time.util.js\n//simpleSourceMap2=/lib/util/common/time.util.js\n/*\n* This module should only be required by util.common.js in NodeJS. If using in browser, please bundle\n* util.browser.js with eg. Browserify\n*\n* This module exports an object with functions on it. \n*\n* This is a helper module for time and date related functions\n*/\n\nmodule.exports=function export_tX({vX,_log}){\n\n\t//Methods to export\n\tvar _exports={\n\t\tBetterDate\n\t\t,makeDate\n\n\t\t,formatDate\n\t\t,formatDatetime\n\n\t\t,now\n\t\t,today\n\t\t,tomorrow\n\t\t,todayMs\n\t\t,tomorrowMs\n\t\t,age\n\t\t\n\t\t,timerStart\n\t\t,timerStop\n\n\t\t,timeToDate\n\t\t,compareTimes\n\t};\n\n\n\n\tvar dow_arr=['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];\n\n\tfunction BetterDate(x){\n\t\t//So we don't have to use new...\n\t\tif(this.constructor!=BetterDate){\n\t\t\treturn new BetterDate(x);\n\t\t}\n\n\t\tthis.date=makeDate((x && x.date && x.date instanceof Date) ? x.date : x)\n\n\t\tObject.defineProperties(this,{\n\t\t\tformat:{enumerable:true,get:()=>formatDate(this.date)}\n\t\t\t,dom:{enumerable:true, get:()=>this.date.getDate()}\n\t\t\t,dow:{enumerable:true, get:()=>this.date.getWeek()}\n\t\t\t,month:{enumerable:true, get:()=>this.date.getMonth()}\n\t\t\t,year:{enumerable:true, get:()=>this.date.getYear()}\n\t\t\t,hour:{enumerable:true, get:()=>this.date.getHours()}\n\t\t\t,minute:{enumerable:true, get:()=>this.date.getMinutes()}\n\t\t\t,time:{enumerable:true, get:()=>this.date.toTimeString().split(' ').unshift()}\n\t\t\t,unix:{enumerable:true, get:()=>this.date.valueOf()}\n\n\t\t})\n\n\t\tthis.first={dom:{this:{},last:{},next:{}}};\n\t\tObject.defineProperties(this.first.dom.this,'week',{enumerable:true, get:()=>this.date.getDate()-this.date.getDay()});\n\t\tObject.defineProperties(this.first.dom.next,'week',{enumerable:true, get:()=>(new Date(this.first.dom.this.week+7)).getDate()});\n\t\tObject.defineProperties(this.first.dom.last,'week',{enumerable:true, get:()=>(new Date(this.first.dom.this.week-7)).getDate()});\n\n\t\tthis.last={dom:{this:{},last:{},next:{}}};\n\t\tObject.defineProperties(this.last.dom.this,'week',{enumerable:true, get:()=>this.first.dom.this.week+6});\n\t\tObject.defineProperties(this.last.dom.next,'week',{enumerable:true, get:()=>this.first.dom.next.week+6});\n\t\tObject.defineProperties(this.last.dom.last,'week',{enumerable:true, get:()=>this.first.dom.last.week+6});\n\n\t\tthis.copy=()=>new BetterDate(this.date);\n\n\n\t\tthis.compare={\n\t\t\ttime:(str)=>compareTimes(str,this.time)\n\t\t\t,date:(str)=>{var d=makeDate(str);return d>this.date?1:d<this.date?-1:0;}\n\t\t}\n\n\n\t\tfunction checkWhat(what){\n\t\t\t//Start by making sure we have a string with first letter capitalized\n\t\t\tvX.checkType('string',what);\n\t\t\twhat=what.substr(0,1).toUpperCase()+what.substr(1);\n\n\t\t\t//Now check if this specific guy wants an 's'\n\t\t\tif(typeof this.date['get'+what]=='function')\n\t\t\t\treturn what\n\t\t\telse if(what.substr(-1)=='s'){\n\t\t\t\t//We don't know that there is a func when removing the s, but we return anyway\n\t\t\t\t//for consistency. ie. If we got 'Weeks' we want to return 'Week', that way we\n\t\t\t\t//don't have to check for both when converting to days (see this.add())\n\t\t\t\treturn what.slice(0,-1);\n\t\t\t}else if(typeof this.date['get'+what+'s']=='function'){\n\t\t\t\treturn what+'s';\n\t\t\t}\n\t\t}\n\n\t\tthis.set=(what,to)=>{\n\t\t\twhat='set'+checkWhat(what);\n\t\t\tthis.date=new Date(this.date[what](to));\n\t\t\treturn this;\n\t\t}\n\t\tthis.set.dom=this.set.dayofmonth=this.set.bind(this,'date');\n\t\tthis.set.dow=this.set.dayofweek=(dow)=>this.set('date',this.first.dow.this.week+dow);\n\t\tthis.set.months=this.set.month=this.set.bind(this,'month');\n\t\tthis.set.years=this.set.year=this.set.bind(this,'year');\n\t\tthis.set.hours=this.set.hour=this.set.bind(this,'hours');\n\t\tthis.set.minutes=this.set.minute=this.set.bind(this,'minutes');\n\t\tthis.set.time=(str)=>{\n\t\t\tif(typeof str!='string')\n\t\t\t\t_log.makeTypeError('string time HH:MM',str).throw();\n\n\t\t\tvar m=str.match(/^(\\d{2}):(\\d{2}):?(\\d{2})?$/);\n\t\t\tif(m){\n\t\t\t\tthis.set.hour(m[1]);\n\t\t\t\tthis.set.minute(m[2]);\n\t\t\t\tthis.set.second(m[3]||0);\n\t\t\t}else{\n\t\t\t\t_log.makeError('Bad time format. Expected HH:MM, got: '+str).setCode('EINVAL').throw();\n\t\t\t}\n\t\t}\n\n\t\tthis.goto={};\n\t\tthis.goto.upcoming=(what)=>{\n\t\t\tvar dow=what;\n\t\t\tif(vX.checkType(['string','number'],dow)=='string'){\n\t\t\t\tdow=dow_arr.indexOf(dow.toLowerCase());\n\t\t\t}\n\t\t\tif(dow<0 || dow>6)\n\t\t\t\t_log.makeError('Expected a string weekday or number between 0-6, got:',what).setCode('EINVAL').throw();\n\t\t\t\t\n\t\t\t//If the day has passed or is today, to do next week\n\t\t\tif(this.dow>=dow){\n\t\t\t\tthis.add.week(1);\n\t\t\t}\n\t\t\treturn this.set.dow(dow);\n\t\t}\n\t\t\n\n\t\tthis.add=(what,much)=>{\n\t\t\tvX.checkType('number',much);\n\t\t\twhat=checkWhat(what);\n\t\t\tif(what=='Week'){\n\t\t\t\tmuch=much*7\n\t\t\t\twhat='Date'\n\t\t\t}else if(what=='Day'){\n\t\t\t\twhat='Date';\n\t\t\t}\n\t\t\tthis.date=new Date(this.date['set'+what](this.date['get'+what]()+much));\n\t\t\treturn this;\n\t\t}\n\t\tthis.add.days=this.add.day=this.add.bind(this,'date');\n\t\tthis.add.weeks=this.add.week=this.add.bind(this,'week');\n\t\tthis.add.months=this.add.month=this.add.bind(this,'month');\n\t\tthis.add.years=this.add.year=this.add.bind(this,'year');\n\t\tthis.add.hours=this.add.hour=this.add.bind(this,'hours');\n\t\tthis.add.minutes=this.add.minute=this.add.bind(this,'minutes');\n\n\t\tthis.sub=(what,much)=>this.add(what,-1*much)\n\t\tthis.sub.days=this.sub.day=this.sub.bind(this,'date');\n\t\tthis.sub.weeks=this.sub.week=this.sub.bind(this,'week');\n\t\tthis.sub.months=this.sub.month=this.sub.bind(this,'month');\n\t\tthis.sub.years=this.sub.year=this.sub.bind(this,'year');\n\t\tthis.sub.hours=this.sub.hour=this.sub.bind(this,'hours');\n\t\tthis.sub.minutes=this.sub.minute=this.sub.bind(this,'minutes');\n\n\t}\n\n\n\n\n\t/*\n\t* @param mixed dateOrDatetime\n\t* @opt string time\n\t*\n\t* @return <Date>\n\t*/\n\tfunction makeDate(dateOrDatetime,time=null){\n\t\tif(typeof dateOrDatetime=='undefined')\n\t\t\treturn Date.now();\n\t\telse{\n\t\t\tif(time){\n\t\t\t\tvar d=new Date(formatDate(dateOrDatetime)+'T'+formatTime(time))\n\t\t\t}else{\n\t\t\t\td=new Date(dateOrDatetime);\n\t\t\t}\n\t\t\tif(d=='Invalid Date'){\n\t\t\t\t_log.throwCode('EINVAL',\"Invalid Date:\",_log.constructor.logVar(x));\n\t\t\t}\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t/*\n\t* @return string \tYYYY-MM-DD\n\t*/\n\tfunction formatDate(x){\n\t\tx=makeDate(x);\n\t\tvar YYYY = x.getFullYear(),\n\t\t\tMM = String(x.getMonth() + 1).padStart(2, '0'), //+1 => january is month 0\n\t\t\tDD = String(x.getDate()).padStart(2, '0')\n\t\t;\n\n\t\treturn `${YYYY}-${MM}-${DD}`;\n\t}\n\n\n\t/*\n\t* @return string \tHH:MM\n\t*/\n\tfunction formatTime(x){\n\t\tswitch(vX.checkType(['<Date>','string','number'],x)){\n\t\t\tcase 'string':\n\t\t\t\t//There are a number of options here, we could have eg:\n\t\t\t\t//    1970-01-01T12:13\n\t\t\t\t//    12:30\n\t\t\t\t//    Wed May 06 2020 02:00:00 GMT+0200 (Central European Summer Time)\n\t\t\t\t//so the easiest thing is to try if Date can recognize it...\n\t\t\t\tif(new Date(x)=='Invalid Date'){\n\t\t\t\t\t//...and otherwise assume it's '17:30' to which we just add a date and vv will do the rest\n\t\t\t\t\tx='1970-01-01T'+x;\n\t\t\t\t}\n\t\t\tcase 'number':\n\t\t\t\t//This will be a timestamp, which can be handled like a Date\n\t\t\t\tx=new Date(x);\n\t\t\tdefault:\n\t\t\t\tvar HH=String(x.getHours()).padStart(2, '0')\n\t\t\t\t\t,MM=String(x.getMinutes()).padStart(2, '0')\n\t\t\t\t\n\t\t\t\treturn `${HH}:${MM}`;\n\t\t}\n\t}\n\n\n\t/*\n\t* @params @see makeDate()\n\t*\n\t* @return string YYYY-MM-DDTHH:MM\n\t*/\n\tfunction formatDatetime(){\n\t\tvar dt=makeDate.apply(this,arguments);\n\t\treturn formatDate(dt)+'T'+formatTime(dt);\n\t}\n\n\n\n\n\n\n\n\n\n\tfunction now(){\n\t\treturn formatDatetime();\n\t}\n\n\tfunction today(){\n\t\treturn formatDate();\n\t}\n\n\tfunction tomorrow(){\n\t\treturn formatDate(new Date(Date.now() + (24 * 60 * 60 * 1000)));\n\t}\n\n\t/*\n\t* @return number \tMilliseconds from epoch to midnight this morning (past)\n\t*/\n\tfunction todayMs(){\n\t\treturn Date.parse(today()).getTime();\n\t}\n\n\t/*\n\t* @return number \tMilliseconds from epoch to midnight tonight (future)\n\t*/\n\tfunction tomorrowMs(){\n\t\treturn Date.parse(tomorrow()).getTime();\n\t}\n\n\n\n\tfunction age(ts, unit='best',short=false){\n\t\tvar ms=Date.now()-ts;\n\n\t\tswitch(unit){\n\t\t\tcase 'best':\n\t\t\t\tif(ms<1000)\n\t\t\t\t\treturn 'now';\n\t\t\t\telse if(ms<(1000*60))\n\t\t\t\t\treturn String(age(ts,'sec'))+(short ? ' sec':' seconds');\n\t\t\t\telse if(ms<(1000*60*60))\n\t\t\t\t\treturn String(age(ts,'m'))+(short ? ' min':' minutes');\n\t\t\t\telse if(ms<(1000*60*60*24))\n\t\t\t\t\treturn String(age(ts,'h'))+(short ? ' hrs':' hours');\n\t\t\t\telse\n\t\t\t\t\treturn String(age(ts,'days'))+(short ? ' days':' days');\n\n\t\t\tcase 'ms':\n\t\t\tcase 'millisec':\n\t\t\tcase 'millisecond':\n\t\t\tcase 'milliseconds':\n\t\t\t\treturn ms;\n\t\t\tcase 's':\n\t\t\tcase 'sec':\n\t\t\tcase 'second':\n\t\t\tcase 'seconds':\n\t\t\t\treturn Math.round(ms/1000,1);\n\t\t\tcase 'm':\n\t\t\tcase 'min':\n\t\t\tcase 'minute':\n\t\t\tcase 'minutes':\n\t\t\t\treturn Math.round(ms/1000/60,1);\n\t\t\tcase 'h':\n\t\t\tcase 'hours':\n\t\t\tcase 'hour':\n\t\t\t\treturn Math.round(ms/1000/60/60,1);\n\t\t\tcase 'd':\n\t\t\tcase 'days':\n\t\t\tcase 'day':\n\t\t\t\treturn Math.round(ms/1000/60/60/24,1);\n\t\t}\n\t}\n\n\n\tfunction timerStart(){\n\t\tif(process)\n\t\t\treturn process.hrtime();\n\t\telse\n\t\t\treturn window.performance.now()\n\t}\n\n\tfunction timerStop(start,format){\n\t\tvar nano;\n\t\tif(process){\n\t\t\tlet durr = process.hrtime(start);\n\t\t\tnano=(durr[0]*1000000000)+durr[1];\n\t\t}else{\n\t\t\tnano=(window.performance.now()-start)*1000000;\n\t\t}\n\t\tswitch(format){\n\t\t\tcase 's':\n\t\t\tcase 'sec':\n\t\t\tcase 'seconds':\n\t\t\t\treturn round(nano/1000000000);\n\t\t\tcase 'ms':\n\t\t\tcase 'milli':\n\t\t\tcase 'milliseconds':\n\t\t\t\treturn round(nano/1000000);\n\t\t\tcase 'us':\n\t\t\tcase 'micro':\n\t\t\tcase 'microseconds':\n\t\t\t\treturn round(nano/1000); \n\t\t\tcase 'ns':\n\t\t\tcase 'nano':\n\t\t\tcase 'nanoseconds':\n\t\t\t\treturn nano;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Please specify format (arg #2)\");\n\t\t}\n\t}\n\n\n\tfunction timeToDate(str){\n\t\treturn new Date('1970-01-01 '+str);\n\t}\n\n\n\t/*\n\t* Compare 2 string times\n\t*\n\t* @param string a\n\t* @param string b\n\t*\n\t* @return number \t1 if $a is later, 0 if same time, -1 if $a is earlier\n\t*/\n\tfunction compareTimes(a,b){\n\t\tif(a==b)\n\t\t\treturn 0;\n\n\t\ta=timeToDate(a);\n\t\tb=timeToDate(b);\n\n\t\treturn a>b?1:a<b?-1:0\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js */ \"../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./util/common/time.util.js?");

/***/ }),

/***/ "./util/common/timer.class.js":
/*!************************************!*\
  !*** ./util/common/timer.class.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/timer.class.js\n//simpleSourceMap2=/lib/timer.class.js\n/*\n* This module exports a constructor. It can be required by nodeJS but is optimized to run \n* in browser by not using nodeJS native EventEmitter\n*/\n\n;'use strict';\nmodule.exports=function exportTimer(dep={}){\n    \n    function missingDependency(which){throw new Error(\"Missing dependency for timer.class.js: \"+which);}\n    const BetterLog = dep.BetterLog                || missingDependency('BetterLog');\n    const BetterEvents = dep.BetterEvents          || missingDependency('BetterEvents');\n\n    /*\n    * Object which keeps track of an interval and timeout timer, allowing for pause and\n    * resume, emitting events as it goes\n    *\n    * @emit interval(number,number) Emits on every interval (arg #1) with elapsed and remaining time.\n    * @emit timeout(number)         Emits once when timer ends with arg #2\n    * @emit event(evt)              Emits along with both ^^, arg is event name\n    *\n    * @param number interval    Milliseconds between emiting interval events\n    * @param number timeout     Milliseconds to wait before emiting 'timeout' event\n    * @param number startFrom   Milliseconds that have already passed. Both _private.elapsed and _private.remaining\n    *                             will be adjusted, but when resetting the timer it will start from 0 and last the\n    *                             full value of timeout \n    */\n    function Timer(interval=null,timeout=null, startFrom){\n        \n\n        var self=this;\n\n        //Inheritence step 1\n        BetterEvents.call(this);\n\n\n        this.running=false;\n\n        Object.defineProperty(this,'_log',{value:new BetterLog(this)});\n\n        Object.defineProperty(this,'_private',{value:{\n            timeoutIds:[]\n        }});\n\n\n\n        function getNow(){\n            var last=self._private\n            var now={\n                now:(new Date()).getTime()\n            }\n            now.timeSinceLastStart=(last.start ? now.now - last.start : 0);\n            now.elapsed=Math.max(last.elapsed+now.timeSinceLastStart,0);\n            now.remaining=typeof last.remaining!='number' ? null : Math.max(last.remaining-now.timeSinceLastStart,0);\n            now.nextInterval=typeof last.nextInterval!='number'? null : Math.max(last.lastInterval||now.now+last.interval-now.now,0); \n            return now;\n        }\n\n        /*\n        * @return null|number>0\n        */\n        this.getRemaining=function(){\n            if(this.running)\n                return getNow().remaining;\n            else\n                return self._private.remaining;\n        }\n\n        /*\n        * @return number\n        */\n        this.getElapsed=function(now){\n            if(this.running){\n                return getNow().elapsed;\n            }else\n                return self._private.elapsed;\n        }\n\n        \n\n\n        /*\n        * @return bool        True if was previously running, else false\n        */\n        this.pause = function() {\n\n            if(this.running){\n\n                //Save remaining and elapsed time, then change flag so all future checks (until we resume) returns\n                //the values are setting here\n                var now=getNow()\n                Object.assign(this._private,now);\n                // self._log.note('PAUSED and set values:',now);\n\n                this.running=false;\n                \n                //You can clear timeouts and intervals with the same command\n                //      https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval)\n                var id;\n                while(id=this._private.timeoutIds.pop()){\n                    // self._log.info(\"clearing timeout/interval\",id);\n                    clearTimeout(id)\n                }\n                \n                return true;\n            }else{\n                // self._log.note(\"NOT RUNNING, not pausing...\")\n            }\n\n            return false;\n        };\n\n        //Since the next interval may be less than 1 interval increment away (because we may have\n        //paused in the middle of an interval), it needs to be fired in a seperate timeout, so we \n        //define the func seperately to use it twice\n        function emitInterval(){\n            var now=getNow();\n            self._private.lastInterval=now.now; \n            self.emit('interval',now.elapsed,now.remaining);\n        }\n\n\n        /*\n        * @return bool        True if was previously paused, else false\n        */\n        this.resume = function() {\n            if(!this.running){\n                // self._log.note('RESUMING...next interval',this._private.nextInterval,'  remaining',this._private.remaining);\n\n                this._private.start=getNow().now;\n                \n                this.running=true;\n\n\n                if(typeof this._private.nextInterval=='number')\n                    //We're going to fire the first timeout manually, and then set an interval staring from\n                    //that point. This is because we may have paused in between 2 intervals which implies that \n                    //the next interval is less than one interval away. NOTE: that nextInterval also get's adjusted  \n                    //by adjustElapsed()\n                    this._private.timeoutIds.push(\n                        setTimeout(()=>{\n                            // 1. Fire first manually, having waited... vv\n                            emitInterval(); //Emit right away\n\n                            //2. Start interval that will take over after first\n                            this._private.timeoutIds.push(setInterval(emitInterval,self._private.interval));\n\n                        },this._private.nextInterval)//                  ^^ ...this long\n                    ); \n                //NOTE: if no timeout is set, interval can go on forever\n\n                if(typeof this._private.remaining=='number') //so it fires right away if remaining is zero\n                    this._private.timeoutIds.push(setTimeout(()=>{\n                        self.pause();\n                        self.emit('timeout',self._private.timeout);\n                    }, this._private.remaining));\n\n                return true;\n            }else{\n                // self._log.note(\"ALREADY RUNNING, not resuming...\");\n            }\n\n            return false;\n\n            \n        };\n\n\n\n        /*\n        * Instead of creating a new Timer and having to listen for events again, this method allows resetting\n        * the two main parameters (essentially creating a new Timer)\n        *\n        * NOTE: This pauses timer if running\n        *\n        * @param number|true|null i    Milliseconds between emiting 'interval' events. True=>use value from creation\n        * @param number|true|null t    Milliseconds to wait before emiting 'timeout' event. True=>use value from creation\n        *\n        * @return boolean   True if reset succeeded, else false\n        */\n        this.reset=function(i=true,t=true, startFrom){\n            this.pause();\n            \n            //The special-case value 'true' implies we use whatever value was used when the Timer was created\n            i=(i===true ? self._private.interval : i);\n            t=(t===true ? self._private.timeout : t);\n\n            try{\n                self._log.debug(\"Resetting timer with:\",i,t,startFrom);\n                resetVars(i,t, startFrom);\n                return true;\n            }catch(err){\n                self._log.error('Failed to reset timer',err);\n                return false;\n            }\n        }\n\n        /*\n        * Like .reset() but also starts timer after\n        *\n        * @return boolean \n        */\n        this.restart=function(){\n            if(this.reset.apply(this,Object.values(arguments))){\n                this.resume();\n                return true;\n            }else{\n                return false;\n            }\n        }\n\n        /*\n        * Adjust the elapsed and remaining time by specifying how much time has actually elapsed\n        *\n        * @param number actualElapsed\n        * return void\n        */\n        this.adjustElapsed=function(actualElapsed){\n            try{\n                if(typeof actualElapsed!='number')\n                    self._log.throwType(\"number\",actualElapsed);\n                if((self._private.timeout && actualElapsed>self._private.timeout) || actualElapsed<0)\n                    throw new RangeError(\"Valid range 0-\"+self._private.timeout+', got '+actualElapsed);\n            }catch(err){\n                self._log.error('Failed to adjust elapsed time',err);\n                return;\n            }\n            \n            //Pause it. \n            var resumeAfter=this.pause();\n           \n            //If we're not changing anything, skip ahead\n            if(actualElapsed!=this._private.elapsed){\n\n                //Always set elapsed\n                this._private.elapsed=actualElapsed;\n                \n                //If there's an interval, adjust nextInterval. Here however we have to consider the change^ so\n                //the intervals keep fireing at the right time. Eg. elapsed=16, actualElapsed=18, interval=5, meaning\n                //nextInterval=4 but it should be 2. Or actualElapsed=14 meaning nextInterval should be 1\n                let i=self._private.interval;\n                if(i){\n                    self._private.nextInterval=(Math.ceil(actualElapsed/i)*i)-actualElapsed\n                }\n\n                //Adjust remaining if there's a timeout\n                if(self._private.timeout)\n                    self._private.remaining=self._private.timeout-actualElapsed;\n\n                self._log.info(`Elapsed time set to: ${this._private.elapsed} of ${self._private.timeout}`);\n            }else{\n                self._log.debug(`No change, timer is still set at: ${this._private.elapsed}`);\n            }\n\n            if(resumeAfter)\n                this.resume();\n        }\n\n\n        /*\n        * Add or delete timeout without affecting elapsed time.\n        *\n        * NOTE: If timeout < elapsed\n        *\n        * @param number|falsey timeout\n        * return void\n        */\n        this.setTimeout=function(timeout){\n            if(timeout && typeof timeout!='number')\n                self._log.throwType(\"number|falsey\",timeout);\n\n\n            var resumeAfter=this.pause();\n\n            self._private.timeout=timeout || null;\n            self._private.remaining=timeout ? timeout-this._private.elapsed : null;\n\n            if(resumeAfter)\n                this.resume();\n        }\n\n\n        /*\n        * Type-checks and sets the two main parameters\n        *\n        * @return void\n        */\n        function resetVars(i,t,startFrom){\n            if(i && typeof i!='number')\n                self._log.throwType(\"arg #1 to be falsey or a number\",i);\n            if(t && typeof t!='number')\n                self._log.throwType(\"arg #2 to be falsey or a number\",t);\n            self._private.nextInterval=self._private.interval=i || null;\n            self._private.timeout=self._private.remaining=t || null;\n            self._private.elapsed=0;\n            self._private.lastInterval=0;\n\n            if(startFrom)\n                self.adjustElapsed(startFrom);\n\n            return;\n        }\n\n\n        resetVars(interval,timeout,startFrom);\n    }\n    Timer.prototype=Object.create(BetterEvents.prototype); \n    Object.defineProperty(Timer.prototype, 'constructor', {value: Timer});\n\n\n    return Timer;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/timer.class.js?");

/***/ }),

/***/ "./util/common/validate.util.js":
/*!**************************************!*\
  !*** ./util/common/validate.util.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/validate.util.js\n//simpleSourceMap2=/lib/util/common/validate.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to validating various data, like emails etc\n*/\n\n\n\nmodule.exports=function export_validate({netmask,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\t'email':validateEmail\n\t\t,'ip':validateIP\n\t};\n\n\n\n\tfunction validateEmail(str){\n\t\tvar regexp=/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/\n\t\treturn str.match(regexp);\n\t}\n\n\n\tfunction validateIP(str,...flags){\n\t\tif(typeof str !=='string'){\n\t\t\tvX._log.makeError(\"Expected a IP string, got:\",this.log.logVar(str)).throw('TypeError');\n\t\t}\n\t\t\n\t\ttry{\t\n\t\t\ttry{\n\t\t\t\tnetmask.ip2long(str)\n\t\t\t}catch(err){\n\t\t\t\tvX._log.makeError(`Not valid IP: ${str}`).throw();\n\t\t\t}\n\t\t\t\t\n\t\t\tif(str.includes('/')){\n\t\t\t\tif(!flags.includes('allowSubnet') && !flags.includes('requireSubnet')){\n\t\t\t\t\tvX._log.makeError(`Got subnet, wanted regular IP: ${str}`).throw();\n\t\t\t\t}\n\t\t\t}else if(flags.includes('requireSubnet')){\n\t\t\t\tvX._log.makeError(`Got regular IP, wanted subnet: ${str}`).throw();\n\t\t\t}\n\n\t\t}catch(err){\n\t\t\tif(flags.includes('throw'))\n\t\t\t\tvX._log.makeError(err).throw();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n\n\n//# sourceURL=webpack:///./util/common/validate.util.js?");

/***/ }),

/***/ "./util/common/vars.util.js":
/*!**********************************!*\
  !*** ./util/common/vars.util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/common/vars.util.js\n//simpleSourceMap2=/lib/util/common/vars.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n;'use strict';\n\nmodule.exports=function export_vX({varType,logVar,_log}){\n    \n\tvar _exports={\n\t\t'varType':varType\n\t\t,'logVar':logVar\n\t\t,'checkType':checkType\n\t\t,'checkTypes':checkTypes\n\t\t,'checkProps':checkProps\n\t\t,isEmpty\n\t\t,'sameValue':sameValue\n\t\t,'compare':compare\n\t\t,'getCompareFunc':getCompareFunc\n\t\t,'isPrimitive':isPrimitive\n\t\t,'allPrimitive':allPrimitive\n\t\t,stringToPrimitive\n\t\t,stringToNumber\n\t\t,'forceType':forceType\n\t\t,'tryJsonParse':tryJsonParse\n\t\t,'tryJsonStringify':tryJsonStringify\n\t\t,'stringifySafe':stringifySafe\n\t\t,'copy':copy\n\t\t,'instanceOf':instanceOf\n\t\t,stripFullLineComments\n\t};\n\n\n\n\n\n\t/*\n\t* Check Throw a TypeError with a well formated message\n\t*\n\t* @param mixed expected \t\tString vartype, or array of <<\n\t* @param any got \t\t\t\tThe actual variable that was the wrong type\n\t* @param bool|string falseOrCaller \tIf ===true, then false is returned on error, if a string, said string \n\t*\t\t\t\t\t\t\t\t\t  is used in error (see first line of func body vv)\n\t*\n\t* @throw TypeError \t\t\t\tIf the type was bad (unless @falseOrCaller===true)\n\t* @return string|bool \t\t\tString if arg#3===true (@see helper.varType($got)) or false if arg#3==false && type is bad\n\t*/\n\tvar lookup={\n\t\t'bool':'boolean'\n\t\t,'arr':'array'\n\t\t,'obj':'object'\n\t\t,'str':'string'\n\t\t,'nr':'number'\n\t\t,'*':'any'\n\t\t,'mixed':'any'\n\t}\n\t// var primitiveObject={\n\t// \t'string':String\n\t// \t,'number':Number\n\t// \t,'boolean':Boolean\n\t// }\n\tfunction checkType(expectedType, got,falseOrCaller=false){\n\t\t//First do a very quick check so we don't waste time in non-complicated situations\n\t\tif(typeof got==expectedType){\n\t\t\t//One scenario here is that we expected 'object' but got 'array' or 'null' which shows up as 'object'\n\t\t\tif(expectedType=='object'){\n\t\t\t\tif(got && got.constructor.name=='Object'){\n\t\t\t\t\treturn expectedType;\t\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn expectedType;\n\t\t\t}\n\t\t}\n\n\t\tvar errStr=(typeof falseOrCaller=='string' ? falseOrCaller+'() e' : 'E') +\"xpected \";\n\t\tvar gotType=varType(got);\n\t\tswitch(varType(expectedType)){\n\t\t\tcase 'string':\n\t\t\t\texpectedType=lookup[expectedType] || expectedType;\n\t\t\t\tif(gotType == expectedType || expectedType=='any'){\n\t\t\t\t\t// console.log(\"SAMESAMESAME - returning\");\n\t\t\t\t\treturn gotType;\n\t\t\t\t}else if(expectedType=='primitive'){ //shortcut to check if primitive\n\t\t\t\t\tif(isPrimitive(got)){\n\t\t\t\t\t\t// console.log('PRIMITIVE success');\n\t\t\t\t\t\treturn gotType;\n\t\t\t\t\t}\n\t\t\t\t\t// console.log('PRIMITIVE but failed',gotType,typeof gotType);\n\t\t\t\t}else if(expectedType.substring(0,1)=='<'){\n\t\t\t\t\tif(gotType=='object'){\n\t\t\t\t\t\tvar name=expectedType.substring(1,expectedType.length-1);\n\n\t\t\t\t\t\t//Check all the constructors along the proto chain\n\t\t\t\t\t\tvar self=got,selves=[];\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tif(self.constructor.name==name)\n\t\t\t\t\t\t\t\treturn expectedType; //NOTE: returns the passed in string WITH '<', ie. <ClsName>\n\t\t\t\t\t\t\tselves.push(self);\n\t\t\t\t\t\t\tself=self.__proto__;\n\t\t\t\t\t\t\tif(!self.__proto__ || self.constructor==self.__proto__.constructor)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// else\n\t\t\t\t\t\t// console.log(`WRONG OBJECT:${got.constructor.name}!=${name}`);\n\t\t\t\t} \n\t\t\t\t//else{ console.log(\"NOT THE SAME -\",expectedType,gotType,gotType == expectedType,got);}\n\n\t\t\t//2019-12-09: DO NOT allow String object when checking for 'string' since many native functions \n\t\t\t//will fail if given String() when expecting string\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'array':\n\t\t\t\tvar goodType=expectedType.find(t=>checkType(t,got,true))\n\t\t\t\tif(goodType)\n\t\t\t\t\treturn goodType;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\tcase 'function':\n\t\t\t\ttry{\n\t\t\t\t\tif(got instanceof expectedType)\n\t\t\t\t\t\treturn expectedType.constructor.name;\n\t\t\t\t\tbreak;\n\t\t\t\t}catch(err){\n\t\t\t\t\t_log.error(err);\n\t\t\t\t\t//2019-11-28: It seems BetterLog instances fail here\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t_log.throw(\"BUGBUG: checkType() expected arg#1 to be string/array/object/function, got:\",logVar(expectedType));\n\t\t}\n\t\tif(falseOrCaller===true)\n\t\t\treturn false;\n\t\telse{\n\t\t\tlet entry=_log.makeTypeError(expectedType,got)\n\t\t\t\t.setOptions({printFunc:true})\n\t\t\t\t.changeWhere(1)//1==remove this line from the stack\n\t\t\tentry.func=falseOrCaller;\n\t\t\tentry.throw();\n\t\t}\n\t}\n\n\n\n\tfunction checkTypes(expArr,gotArr, falseOrCaller){\n\t\tif(varType(expArr)!='array')\n\t\t\t_log.throwType(\"arg #1 to be an array\",expArr);\n\t\tswitch(varType(gotArr)){\n\t\t\tcase 'object':\n\t\t\t\tgotArr=Object.values(gotArr); //so we can pass 'arguments'. NOTE: that it only contains explicitly passed\n\t\t\t\t\t\t\t\t\t\t\t  //args, not default values or omitted\n\t\t\tcase 'array':\n\t\t\t\t//It's important we don't alter the array, in case it's used again\n\t\t\t\tgotArr=[].concat(gotArr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_log.throw(\"BUGBUG: checkTypes() expected arg#2 to be an array, got:\",logVar(gotArr));\n\t\t}\n\n\t\tvar diff=expArr.length-gotArr.length\n\t\tif(diff>0){\n\t\t\t//Fill second array with undefined (needed when passing 'arguments' where some where omitted. NOTE: default values\n\t\t\t//are not included in arguments object)\n\t\t\tgotArr.push.apply(gotArr,new Array(diff));\n\t\t}else if(diff<0){\n\t\t\t//splice second array, ie. we only check as far as we've been told\n\t\t\tgotArr.splice(expArr.length,Math.abs(diff));\n\n\t\t}\n\n\t\ttry{\n\t\t\tvar i, gotTypes=[];\n\t\t\tfor(i=0;i<expArr.length;i++){\n\t\t\t\tgotTypes.push(checkType(expArr[i],gotArr[i],false)); //false==throw\n\t\t\t}\n\t\t\treturn gotTypes;\n\n\t\t}catch(err){\n\t\t\tif(falseOrCaller===true)\n\t\t\t\treturn false;\n\t\t\telse{\n\t\t\t\ttry{\n\t\t\t\t\t// err.message=(typeof falseOrCaller=='string' ? falseOrCaller+'() a' : 'A')+'rg #'+(i+1)+': '+err.message\n\t\t\t\t\t// throw(err);\n\t\t\t\t\tvar BLE=_log.makeError(err);\n\t\t\t\t\tBLE.msg=(typeof falseOrCaller=='string' ? falseOrCaller+'() a' : 'A')+'rg #'+(i+1)+': '+BLE.msg;\n\t\t\t\t\tBLE.changeWhere(1); //remove another line from the stack\n\t\t\t\t}catch(e){\n\t\t\t\t\tconsole.error(\"BUGBUG checkTypes(): something was wrong with <BetterLogEntry>:\",e,typeof BLE,BLE);\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t\tthrow BLE;\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t* @param object obj \tAny object\n\t* @param object types \tKeys are same as obj, values are expected types (string or array or strings)\n\t*\n\t* @throws TypeError \tIf args passed to this func is wrong\n\t* @throws TypeError \t@see $falseOrCaller\n\t* @return object|false\n\t*/\n\tfunction checkProps(obj,types,falseOrCaller){\n\t\tif(!checkType('object',types,true)) \n\t\t\t_log.makeError(\"BUGBUG: checkProps expects arg#2 to be an object, got:\",types).throw(\"TypeError\");\n\t\t\n\t\ttry{\n\t\t\tcheckType('object',obj);\n\t\t\tvar key;\n\t\t\tfor(key in types){\n\t\t\t\ttry{\n\t\t\t\t\ttypes[key]=checkType(types[key],obj[key],false); //false==>throw or return type\n\t\t\t\t}catch(err){\n\t\t\t\t\tif(falseOrCaller===true){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar msg=` prop '${key}'`;\n\t\t\t\t\tif(obj.hasOwnProperty(key)){\n\t\t\t\t\t\tmsg='Bad'+msg+': '+logVar(obj[key]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg='Missing'+msg;\n\t\t\t\t\t}\n\t\t\t\t\tif(falseOrCaller){\n\t\t\t\t\t\tmsg=falseOrCaller+'(): '+msg;\n\t\t\t\t\t}\n\t\t\t\t\t_log.makeError(msg,err).throw();\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn types;\n\t\t}catch(ble){\n\t\t\tble.changeWhere(1).throw();\n\t\t}\n\t}\n\n\n\n\n\t/*\n\t* Check if a variable contains information, ie. everything except: undefined, null, empty string,\n\t* empty object, empty array\n\t*\n\t* @param any v\n\t*\n\t* @flags ...considerEmpty \tSeveral things can be considered empty or not. By default none\n\t*\t\t\t\t\t\t\tof them are, but you can change this by passing one or more of \n\t*\t\t\t\t\t\t\tthem as args, or pass '*' to consider them all empty. Available\n\t*\t\t\t\t\t\t\titems are:\n\t*\t\t\t\t\t\t\t\t\t0, null, false\n\t*\t\t\t\t\t\t\t\t\t\t\t\n\t* Note: String that match /^\\s*$/ are also considered empty\n\t*\n\t* @return boolean\n\t*/\n\tfunction isEmpty(v,...considerEmpty){\n\t\t\n\t\tlet t= varType(v);\n\t\tswitch(t){\n\t\t  //Objects and arrays are considered empty if they don't have any items\n\t\t\tcase 'nodelist':\n\t\t\tcase 'array':\n\t\t\t\treturn (v.length ? false : true);\n\n\t\t\tcase 'object':\n\t\t\t\treturn (Object.keys(v).length ? false : true);\n\n\t\t  //Undefined has no informational value and is by definition not anything\n\t\t\tcase 'undefined':\n\t\t\t\treturn true;\n\n\t\t  //Strings with only whitespace characters are considered empty\n\t\t  \tcase 'string':\n\t\t  \t\treturn (!v || v.match(/^\\s*$/) ? true : false);\n\n\t\t  //Here we have an option, by default zero, null and false are NOT considered empty...\n\t\t  \tcase 'boolean':\n\t\t  \tcase 'number':\n\t\t  \tcase 'null':\n\t\t  \t\tif(v)\n\t\t  \t\t\treturn false;\n\t\t  \t\tif(considerEmpty.includes('*')||considerEmpty.includes(v))\n\t\t  \t\t\treturn true;\n\t\t  \t\telse\n\t\t  \t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn (v ? false : true)\n\t\t}\n\t}\n\n\n\t\t\n\tfunction sameValue(a,b){\n\t// _log.traceFunc(arguments,'sameValue');\n\t\tif(typeof a!=typeof b)\n\t\t\treturn false;\n\t\t\n\t\tif(a===b)\n\t\t\treturn true;\n\n\t\tif(a===null || b===null)\n\t\t\treturn false; //if both were null, they'd return true ^^, now only one is, which means !=\n\t\t\n\t\tswitch(varType(a)){\n\t\t\tcase 'number':\n\t\t\tcase 'string':\n\t\t\tcase 'boolean':\n\t\t\tcase 'node':\n\t\t\tcase 'function':\n\t\t\tcase 'undefined':\n\t\t\t\treturn false; //since we tried ^^, we know they're not the same\n\n\t\t\tcase 'array'://Order and values are important\n\t\t\t\tif(a.length!=b.length)\n\t\t\t\t\treturn false;\n\t\t\t\treturn stringifySafe(a)==stringifySafe(b); \n\t\t\t\n\t\t\tcase 'object'://Order could have changed, without properties having changed... still same value\n\t\t\t\t//As a fast first check, just like with array ^^, check that we have the same number of keys\n\t\t\t\tvar aKeys=Object.keys(a), bKeys=Object.keys(b);\n\t\t\t\tif(aKeys.length!=bKeys.length)\n\t\t\t\t\treturn false;\n\n\t\t\t\t//Then check that the keys are the same (sorting first since order doesn't matter here)\n\t\t\t\taKeys.sort();\n\t\t\t\tbKeys.sort();\n\t\t\t\tif(!sameValue(aKeys,bKeys))\n\t\t\t\t\treturn false;\n\n\t\t\t\t//Finally compare every value\n\t\t\t\treturn aKeys.every(key=>a[key]===b[key])\n\t\t\t\n\n\t\t\tcase 'nodelist':\n\t\t\t\tif(a.length!=b.length)\n\t\t\t\t\treturn false;\n\t\t\t\tfor(let i=a.length-1; i>=0;i--){\n\t\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/*\n\t* @return bool\n\t*/\n\tfunction compare(a,operator,b,c){\n\t\treturn getCompareFunc(operator)(a,b,c);\n\t}\n\tcompare.operators=['===','==','!=','!','!==','<','>','<=','>=','in','between','startsWith','endsWith','contains','regexp']\n\tcompare.isOperator=(operator)=>compare.operators.includes(operator);\n\tcompare.startsWithOperator=(string)=>{\n\t\tif(typeof string!='string'){\n\t\t\treturn undefined;\n\t\t}\n\t\treturn compare.operators.find(op=>string.indexOf(op)==0);\n\t}\n\t/*\n\t* @return [operator,rest of string turned into real value]\n\t*/\n\tcompare.splitOnOperator=(string)=>{\n\t\tlet op=compare.startsWithOperator(string)\n\t\tif(op)\n\t\t\treturn [op,stringToPrimitive(string.substr(op.length))]\n\t\telse\n\t\t\treturn [undefined,string];\n\t}\n\tfunction getCompareFunc(operator){\n\t\tswitch(operator){\n\t\t\tcase 'undefined':\n\t\t\tcase undefined:\n\t\t\tcase '===' : return (a,b)=>a===b;\n\t\t\tcase '==' : return (a,b)=>a==b;\n\t\t\tcase '!=' :\n\t\t\tcase '!' : return (a,b)=>a!=b;\n\t\t\tcase '!==' : return (a,b)=>a!==b;\n\t\t\tcase '<' : return (a,b)=>a<b;\n\t\t\tcase '>' : return (a,b)=>a>b;\n\t\t\tcase '<=' : return (a,b)=>a<=b;\n\t\t\tcase '>=' : return (a,b)=>a>=b;\n\t\t\tcase 'in' : return (a,b)=>(Array.isArray(b) ? b : [b]).includes(a);\n\t\t\tcase 'between' : return (a,b,c)=>typeof a=='number' && a>=b && a<=c;\n\t\t\tcase 'startsWith' : return (a,b)=>typeof a=='string' && a.startsWith(b);\n\t\t\tcase 'endsWith' :return (a,b)=>typeof a=='string' && a.endsWith(b);\n\t\t\tcase 'contains' : return (a,b)=>typeof a=='string' && a.indexOf(b)>-1;\n\t\t\tcase 'regexp' : return (a,b)=>typeof a=='string' && a.search(b)>-1;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown operator: \"+logVar(operator));\n\t\t}\n\t}\n\n\n\n\n\t/*\n\t* Check if a var is primitive or not\n\t*\n\t* NOTE: null is an object in javascript, but we're including it as a primitive as it can be considered 'not complex' \n\t* \t\tand can easily be written to a log, file or stream without formating/encoding. \n\t*\n\t* @param any x\n\t*\n\t* @return boolean\n\t*/\n\tfunction isPrimitive(x){\n\t\tif(x===null)\n\t\t\treturn true\n\t\tswitch(typeof x){\n\t\t\tcase 'string':\n\t\t\tcase 'number':\n\t\t\tcase 'boolean':\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/*\n\t* Check if all values inside an array or object are primitives\n\t*\n\t* @param any x\n\t*\n\t* @return boolean\n\t*/\n\tfunction allPrimitive(x){\n\t\tif(isPrimitive(x))\n\t\t\treturn true;\n\n\t\tswitch(varType(x)){\n\t\t\tcase 'object':\n\t\t\t\tx=Object.values(x);\n\t\t\tcase 'array':\n\t\t\t\treturn x.every(isPrimitive);\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\n\t/*\n\t* Check if a string is a representation of a native javascript value, eg. true/false\n\t*\n\t* @param primitive str \t\tA primitive or a string representing a primitive\n\t* \n\t* @throw <ble TypeError>\n\t*\n\t* @return primitive\n\t*/\n\tfunction stringToPrimitive(str){ \n\t\tif(typeof str!='string'){\n\t\t\tif(!isPrimitive(str))\n\t\t\t\tcX.makeTypeError('string or primitive',str).throw();\n\t\t\treturn str;\n\t\t}\n\n\t\tswitch(str){\n\t\t\tcase 'true':return true;\n\t\t\tcase 'false':return false;\n\t\t\tcase 'null':return null;\n\t\t\tcase 'undefined':return undefined;\n\t\t\tcase '':return '';\n\t\t}\n\n\t\tlet i = stringToNumber(str,true); //true==no throw, we're just testing\n\n\t\treturn (i===undefined ? str : i);\n\t}\n\n\t/*\n\t* Turn a string number with sign into an actual number, eg. '+1'=>1 '-3'=>-3, optionally\n\t* using it to increment a current number\n\t*\n\t* @param string \tchange\n\t* @param boolean \tnoThrow \tIf true, return undefined if not a number\n\t*\n\t* @throw Error \t\t\t\t\tIf not a number. Or @see $noThrow\n\t* @return number \t\t\t\tOr @see $noThrow\n\t*/\n\tfunction stringToNumber(str,noThrow=false){\n\t\tswitch(typeof str){\n\t        case 'number':\n\t            return str;\n\t        case 'string':\n\t\t\t\tlet number=Number(str);\n\t\t\t\tif(typeof number=='number' && !isNaN(number))\n\t\t\t\t\treturn number;\n\n\t            //don't break here, let it fall through to bad value vv\n\t        default:\n\t        \tif(noThrow)\n\t        \t\treturn undefined\n\t        \telse\n\t            \tthrow new Error(\"Bad value, expected a numerical string with an optional sign, got: \"+ vX.logVar(str));\n\t    }\n\t}\n\n\t/*\n\t* Force a specific type, eg. turn \"1\" into 1\n\t*\n\t* @param string \texpectedType\n\t* @param mixed \t\tvalue\n\t*\n\t* @throw TypeError\n\t* @return mixed\n\t*/\n\tfunction forceType(expectedType,value){\n\t\tif(checkType(['string','array'],expectedType)=='array'){\n\t\t\tvar value2;\n\t\t\tif(expectedType.find(type=>{try{value2=forceType(type,value);return true;}catch(err){return false;}})){\n\t\t\t\treturn value2;\n\t\t\t}\n\t\t}else{\n\n\t\t\tvar gotType=varType(value);\n\t\t\tswitch(expectedType){\n\t\t\t\tcase gotType:\n\t\t\t\t\treturn value;\n\t\t\t\tcase 'undefined':\n\t\t\t\tcase 'null':\n\t\t\t\t\t//If we got the string 'undefined', return undefined etc\n\t\t\t\t\tif(typeof value=='string' && value==expectedType)\n\t\t\t\t\t\treturn value=='null' ? null : undefined;\n\n\t\t\t\t\t//If we got any empty value, return undefined etc\n\t\t\t\t\tif(empty(value))\n\t\t\t\t\t\treturn expectedType=='null' ? null : undefined;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tswitch(value){\n\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\tcase 'TRUE':\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\tcase 'FALSE':\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn value ? true : false;\n\t\t\t\t\t}\n\t\t\t\tcase 'number':\n\t\t\t\t\tvar num=Number(value); //this will convert booleans and strings, but not null, undefined etc...\n\t\t\t\t\tif(!isNaN(num))\n\t\t\t\t\t\treturn num;\n\t\t\t\t\t//If we didn't make a number, throw at bottom...\n\n\t\t\t\tcase 'string':\n\t\t\t\t\tif(gotType=='array'||gotType=='object')\n\t\t\t\t\t\treturn tryJsonStringify(value);\n\n\t\t\t\t\treturn String(value);\n\t\t\t\tcase 'array':\n\t\t\t\t\t//turn objects with numerical keys into arrays... \n\t\t\t\t\tif(gotType=='object'){\n\t\t\t\t\t\tif(Object.keys(value).every(Number.isInteger))\n\t\t\t\t\t\t\treturn Object.values(value);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak; //any other type of object is bad\n\t\t\t\t\t}\n\t\t\t\t\t//don't break so we can try for json vv\n\t\t\t\tcase 'object':\n\t\t\t\t// return JSON.parse(value)\n\t\t\t\t\tlet x=tryJsonParse(value,true);\n\t\t\t\t\tif(checkType(expectedType,x,true))\n\t\t\t\t\t\treturn x\n\t\t\t\t\t\n\t\t\t\t\t//Any other scenario is bad\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'promise':\n\t\t\t\t\treturn Promise.resolve(value);\n\t\t\t\tcase 'error':\n\t\t\t\t\treturn new Error(String(value));\n\t\t\t\tcase 'function':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_log.throwCode(\"BUGBUG\",\"BetterUtil.forceType() expected arg #1 to be a return value of BetterUtil.varType(), got:\",expectedType);\n\t\t\t}\n\t\t}\n\t\t//If we're still running, throw a TypeError\n\t\t_log.throwType(expectedType,value);\n\t}\n\n\n\t/*\n\t* This function attempts to parse a JSON string without throwing errors\n\t*\n\t* @param any x \n\t* @param bool onlyReturnObject\tDefault false. If true, this function will only return @x if it was successfully parsed into\n\t*\t\t\t\t\t\t\t\tan object, or if it was an object to begin with\n\t*\n\t* @return object|undefined\n\t*/\n\n\t\t\t\t\t\t\t \n\tfunction tryJsonParse(x, onlyReturnObject=false){\n\t\tif(x && typeof x=='object')\n\t\t\treturn x;\n\n\t\tif(typeof x=='string'){\n\t\t\tvar err;\n\t\t\ttry{\n\t\t\t\treturn JSON.parse(x.trim());\n\t\t\t} catch(e){err=e}\n\n\n\n\t\t\t//Try removing comments, and if something changes take that as a sign and run this\n\t\t\t//function again\n\t\t\tvar stripped=stripFullLineComments(x);\n\t\t\tif(stripped!=x){\n\t\t\t\tif(stripped==''){\n\t\t\t\t\t_log.note(\"Was the whole string a comment? Because BetterUtil.stripFullLineComments() thought it was:\",x,String(err));\n\t\t\t\t}else{\n\t\t\t\t\t_log.debug(\"Removed comments from string and trying again\");\n\t\t\t\t\treturn tryJsonParse(stripped);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//At this point we know we're going to fail, the question is just what we log and what we return\n\n\n//STOPSTOP 2020-05-08: why is the whole string being printed and not trimmed?!?!\n\n\n\n\t\t\tlet xx=x.trim(), wrapper=xx.substr(0,1)+xx.substr(-1); //NOTE substring() and substr() don't work the same!\n\t\t\tif(wrapper=='{}'||wrapper=='[]'){\n\t\t\t\tvar warn=_log.makeEntry('warn',\"This is probably a poorly formated JSON obj/arr:\");\n\t\t\t\tlet e=String(err),p=e.lastIndexOf(' '),pos=Number(e.substr(p));\n\t\t\t\tif(!isNaN(pos)){\n\t\t\t\t\twarn.highlightBadCode(x,pos);\n\t\t\t\t}else{\n\t\t\t\t\twarn.addExtra(x,err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(onlyReturnObject && (!x || typeof x !='object')){\n\t\t\tif(warn)\n\t\t\t\twarn.exec();\n\t\t\telse\n\t\t\t\t_log.debug('Not a JSON string:',x,String(err)); //don't debug if we've already warned\n\t\t\t\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn x\n\t\t}\n\t}\n\n\n\t/*\n\t* This function attempts to stringify any value, checking first if it is already stringified.\n\t* @param any x\n\t* @return string \tA string that can be passed to JSON.parse() (possibly an empty string)\n\t*/\n\n\t\t\t\t\t\t\t \n\tfunction tryJsonStringify(x){\t\n\t\ttry{\n\t\t\tJSON.parse(x)\n\t\t\treturn x; //x is already a JSON string\n\t\t} catch(e){\n\t\t\ttry{\n\t\t\t\treturn JSON.stringify(x)||''\n\t\t\t}catch(e){\n\t\t\t\treturn ''\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/*\n\t* Turn object into JSON-like string, ie. not valid JSON just something that looks good to log\n\t*/\n\tfunction stringifySafe(obj){\n\t\ttry{\t\t\n\t\t\t//Attempt just to use JSON. This can fail eg. if any circular refs exist (usually true in browser)\n\t\t\treturn JSON.stringify(obj);\n\t\t}catch(err){\n\t\t\tif(err.message.indexOf('circular structure')>-1){\n\t\t\t\t//In case of circ struct, just attempt to get a little bit of info about the first level\n\t\t\t\t//structure... so we have something to log\n\t\t\t\ttry{\n\t\t\t\t\tvar x='';\n\t\t\t\t\tObject.entries(obj).forEach(([key,value])=>{\n\t\t\t\t\t\tx+=key+':';\n\t\t\t\t\t\tswitch(varType(value)){\n\t\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t\tx+=value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tx+=Object.prototype.toString.call(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx+=','\n\t\t\t\t\t})\n\t\t\t\t\tif(varType(obj)=='array')\n\t\t\t\t\t\tx='['+x+']';\n\t\t\t\t\telse\n\t\t\t\t\t\tx='{'+x+'}';\n\n\t\t\t\t\tthrow 'Failed to stringify (circular structure):'+x\n\t\t\t\t}catch(e){\n\t\t\t\t\terr=e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_log.error(err);\n\t\t\treturn `<err:${err.message}>`\n\t\t}\n\t}\n\n\n\n\n\tfunction copy(x){\n\t\tswitch(varType(x)){\n\t\t\tcase 'object':\n\t\t\tcase 'array':\n\t\t\t\treturn JSON.parse(JSON.stringify(x));\n\t\t\tcase 'node':\n\t\t\t\treturn x.cloneNode(true);\n\t\t\tcase 'nodelist':\n\t\t\t\treturn Array.from(x,node=>node.cloneNode(true));\n\t\t\tdefault:\t\n\t\t\t\treturn x;\n\t\t}\n\t}\n\n\n\n\tfunction instanceOf(expected,gotObj,returnFalse){\n\t\ttry{checkType(['function','object'],expected);}\n\t\tcatch(err){\n\t\t\tthrow new TypeError(\"BUGBUG instanceOf() expected arg #1 to be a constructor or object, got: \"+logVar(expected));\n\t\t}\n\n\t\tcheckType('object',gotObj);\n\t\t\n\t\tif(gotObj instanceof expected)\n\t\t\treturn gotObj.constructor;\n\t\telse if(returnFalse)\n\t\t\treturn false;\n\t\telse{\n\t\t\tvar who=typeof expected=='function' ? expected.name : expected.constructor.name;\n\t\t\tthrow new TypeError(\"Expected instance of \"+who+\", got: \"+gotObj.constructor.name);\n\t\t}\n\t}\n\n\n\n\tvar stripper=new RegExp(/^\\s*\\/\\/.*$/mg)\n\tvar remover=new RegExp(/^\\s*\\/\\/.*$/m)\n\tfunction stripFullLineComments(str){\n\t\tcheckType('string',str);\n\n\t\t//For logging only, we first match ALL occurences...\n\t\tlet m=str.match(stripper);\n\t\tif(m){\n\t\t\tm=Object.values(m);\n\t\t\tlet entry=_log.makeEntry(`Found ${m.length} comments in:`,logVar(str,50));\n\t\t\tm.forEach(comment=>{\n\t\t\t\tentry.addHandling(\"Removing comment:\",comment)\n\t\t\t\t//...but then we use the other regexp to remove one at a time. Slow but logs good!\n\t\t\t\tstr=str.replace(remover,'');\n\t\t\t})\n\n\t\t\tstr=str.trim(); \n\t\t\t\t//^We don't trim outside this if-block so $str doesn't change if there are no comments, see tryJsonParse() and\n\t\t\t\t//try to figure our why ;)\n\t\t}else{\n\t\t\t_log.trace(\"No comments in:\",logVar(str,50));\n\t\t}\n\t\treturn str;\n\t}\n\n\n\n\n\t//Methods to export\n\treturn _exports \n\n\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/vars.util.js?");

/***/ })

/******/ });