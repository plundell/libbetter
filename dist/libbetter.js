/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build-browser.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js":
/*!*************************************************!*\
  !*** (webpack)/node_modules/process/browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///(webpack)/node_modules/process/browser.js?");

/***/ }),

/***/ "./build-browser.js":
/*!**************************!*\
  !*** ./build-browser.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * @module libbetter\n * @sub-module BetterLog\n * @sub-module BetterEvents\n * @sub-module BetterUtil.browser\n * @description This file can be built with webpack to create a file that can be loaded directly\n *\t\t\t\tby the browser in a <script>. It will make the sub-modules available on window\n *\n * @author plundell\n * @license MIT\n */\n\n\n//This will set window.BetterLog\n__webpack_require__(/*! ./log */ \"./log/better_log.js\");\nwindow.BetterLog._env='browser';\n\n//This will set window.BetterEvents\n__webpack_require__(/*! ./events */ \"./events/better_events.js\");\n\n//This will set window.BetterUtil\n__webpack_require__(/*! ./util/bu-browser.js */ \"./util/bu-browser.js\")(window);\n\n//# sourceURL=webpack:///./build-browser.js?");

/***/ }),

/***/ "./events/better_events.js":
/*!*********************************!*\
  !*** ./events/better_events.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//simpleSourceMap=/my_modules/better_events.js\n//simpleSourceMap2=/lib/better_events.js\n;'use strict';\n/**\n * @module BetterEvents\n * @author plundell \n * @email qmusicplayer@protonmail.com\n * @license MIT\n * @description Advanced event emitter for NodeJS and browsers. \n *\n * This file can be 'required' or loaded directly in browser with <script src=\"/path/to/better_events.js\">\n */\n(function(globalObj){\n    \n    //Export from module if available\n    if( true && module.exports){\n        module.exports = BetterEvents;\n    }\n\n    //Set on window if available\n    if(typeof window === 'object'){\n        window.BetterEvents=BetterEvents;\n    }\n    \n\n\n    const defaultOptions={\n        bufferDelay:1000\n        ,groupTimeout:0 \n        ,defaultIndex:0\n        ,onProgress:()=>{}\n        ,runAs:'this'       //Available: this, global, empty=>an empty object,shared=>a shared new object, status=>the object returned by emitEvent\n    }\n\n    function BetterEvents(options={}){\n        \n        //Make sure we've been new'ed\n        if(!this instanceof BetterEvents)\n            throw new Error(\"BetterEvents() should be new'ed or called as object which inherits from BetterEvents\");\n\n\n        Object.defineProperty(this,'_betterEvents',{value:{\n            emitted:{}\n            ,after:{}\n            ,buffer:{}\n            ,intercept:{}\n            ,options:parseOptions(options)\n            ,onerror:typeof options.onerror=='function'\n                ?options.onerror\n                :BetterEvents.prototype._defaultEmitErrorHandler\n        }});\n        \n\n        this.removeAllListeners(); //resets/sets default values of additional properties on this._betterEvents\n    }\n\n    /*\n    * This method can be changed to another function to set the default value\n    * for each instance subsequently created.\n    */\n    BetterEvents.prototype._defaultEmitErrorHandler=console.error;\n\n\n    /*\n    * Removes all listeners for all events\n    * @return this\n    */\n    BetterEvents.prototype.removeAllListeners = function(){\n        this._betterEvents.events={};\n        this._betterEvents.regexp=[];\n            //^Just like events^, one regexp can have multiple listeners, but regexps are objects so can't\n            // be keys, and we don't want to use a Map since we want to compare their toString()s, so we\n            // will store them on array as [[regex1,func1],[regex2,func2],...]\n        this._betterEvents.onAll=[];\n        this._betterEvents.onUnhandled=null;\n        return this;\n    };\n\n\n\n\n    /*\n    * Turn any value into a string suitable to put into an error msg\n    *\n    * @param any value\n    *\n    * @return string    Finite length string (max ~70 characters)\n    * @private\n    */\n    function typeString(value){\n        if(value==null || value==undefined){\n            return `<${''+value}>`\n        }else{\n            var str=value.toString();\n            if(str.length>50)\n                str=str.slice(0,25)+'...'+str.slice(-25)\n            var type=typeof value;\n            if(type=='object')\n                type=value.__proto__.constructor.name\n            return `(${type})${str}`\n        }\n    }\n\n    /*\n    * Create pretty output to go in new TypeError (but leave the creation of said error in\n    * the calling function so the stack is accurate)\n    *\n    * @param number i\n    * @param string expected\n    * @param any value\n    *\n    * @return string\n    * @private\n    */\n    function errString(i,expected,value){\n        switch(expected){\n            case 'listener': expected='a listener function'; break;\n            case 'interceptor': expected='an interceptor function'; break;\n            case 's_evt': expected='a string event'; break;\n            case 'r_evt': expected='a <RegExp> event'; break;\n            case 'evt': \n            case 'event':\n                expected='a string or <RegExp> event'; break;\n        }\n        return `Arg #${i} should be ${expected}, got: ${typeString(value)}`;\n    }\n\n\n\n    function parseOptions(a,b){\n        var dirty=Object.assign({},a,b);\n        var parsed=Object.assign({},defaultOptions);\n        \n        if(dirty.bufferDelay){\n            if(typeof dirty.bufferDelay=='number')\n                parsed.bufferDelay=dirty.bufferDelay;\n            else\n                throw new TypeError(\"Option 'bufferDelay' should be a number, got:\"+typeString(dirty.bufferDelay))\n        }\n\n        if(dirty.groupTimeout){\n            if(typeof dirty.groupTimeout=='number')\n                parsed.groupTimeout=dirty.groupTimeout;\n            else\n                throw new TypeError(\"Option 'groupTimeout' should be a number, got:\"+typeString(dirty.groupTimeout))\n        }\n\n\n        if(dirty.onProgress){\n            if(typeof dirty.onProgress=='function')\n                parsed.onProgress=dirty.onProgress;\n            else\n                throw new TypeError(\"Option 'onProgress' should be a function, got:\"+typeString(dirty.onProgress))\n        }\n\n        if(dirty.exclude){\n            if(typeof dirty.exclude=='function')\n                parsed.exclude=[dirty.exclude];\n            else if(Array.isArray(dirty.exclude) && dirty.exclude.all(f=>typeof f=='function'))\n                parsed.exclude=dirty.exclude;\n            else\n                throw new TypeError(\"Option 'exclude' should be a function or array of functions, got:\"+typeString(dirty.exclude))\n        }\n\n        if(dirty.emitAs){\n            if(Array('this','global','empty','status').includes(dirty.emitAs)){\n                parsed.emitAs=dirty.emitAs\n            }else{\n               throw new RangeError(\"Option 'emitAs' should be one of 'this','global','empty','status', got:\"+typeString(dirty.emitAs)); \n            }\n        }\n\n        return parsed;\n    }\n\n\n\n    /*\n    * Add a listener for a specific event, or using regexp for an unspecified number of possible events.\n    *\n    * NOTE: Duplicate listeners for the same event cannot be added. Will return current index if attempted\n    * NOTE2: If using regexp, duplicate listener calls will be avoided when emitting\n    * NOTE3: If any listeners in a 'sooner' group returns a Promise that never resolves, then no later groups will run!\n    * NOTE4: Params can be passed in any order\n    *\n    * @param string|<RegExp> evt    Reserved values are 'once' and only '-' or '+'\n    * @param function listener      Method to be called when the event is emitted. If the method returns 'off' on\n    *                                any call then it will be removed after that call\n    * @opt boolean|string once      Boolean or string 'once'. The listener will be removed after the first time it's called.  \n    *                                ProTip: is to use string 'once' so it's clear what we're doing...\n    * @opt number|string index      The order in which to run the listener. All listeners with same index run\n    *                                 concurrently. Lower numbers run sooner. Use one or multiple '+'/'-' to run in relation\n    *                                 to options.defaultIndex\n    *\n    *\n    * @throw TypeError\n    * @return object        {e,o,l,i,r}   \n    */\n    BetterEvents.prototype.addListener=function(...args) {\n        \n        var _b=this._betterEvents;\n        var obj={o:false, i:_b.options.defaultIndex};\n\n        //Allow args in any order\n        args.forEach(arg=>{switch(typeof arg){\n            case 'function':obj.l=arg; break;\n            case 'boolean':obj.o=arg; break;\n            case 'number':obj.i=arg; break;\n            case 'string': \n                if(arg.match(/^\\++$/)){\n                    obj.i=_b.options.defaultIndex+arg.length; \n                }else if(arg.match(/^\\-+$/)){\n                    obj.i=_b.options.defaultIndex-arg.length; \n                }else{\n                    obj.e=arg;\n                }\n                break;\n            case 'object':\n                if(arg instanceof RegExp)\n                    obj.e=arg\n                else\n                    obj=arg;\n        }})\n\n        if(typeof obj.l!='function')\n            throw new TypeError(\"No listener function passed, got: \"+JSON.stringify(obj));\n\n\n        if(typeof obj.e=='string'){\n            if(_b.events.hasOwnProperty(obj.e)){\n                var _obj=_b.events[obj.e].find(({l})=>l===obj.l)\n                if(_obj)\n                    obj=_obj\n                else\n                    _b.events[obj.e].push(obj)\n            }else{\n                _b.events[obj.e]=[obj];\n            }\n\n        }else if(obj.e instanceof RegExp){\n            //If the exact combo has already been added, don't duplicate, however getListeners() used by\n            //emitEvent() will return a unique array so no need to panic here\n            var _obj=_b.regexp.find(({l,e})=>l===obj.l && e==obj.e)\n            if(_obj)\n                obj=_obj;\n            else\n                _b.regexp.push(obj)\n        }else{\n            throw new TypeError(\"No event string or RegExp was passed, got: \"+JSON.stringify(obj));\n        }\n\n        //Finally, add a method that can always be used to remove this listener from this object\n        obj.r=this.removeListener.bind(this,obj.l,obj.e);\n\n        return obj;\n    };\n\n    /*\n    * @shortcut addListener(,,false)   \n    * @return object        {e,o,l,i}\n    */\n    BetterEvents.prototype.on=function(evt,listener){\n        return this.addListener(evt,listener,false);\n    }\n\n    /*\n    * @shortcut addListener(,,true)\n    * @return object        {e,o,l,i}\n    */\n    BetterEvents.prototype.once=function(evt,listener){\n        return this.addListener(evt,listener,true);\n    }\n\n\n\n    /*\n    * Set a listener for all otherwise unhandled events\n    *\n    * NOTE: Calling this method multiple times will only replace the previous listener\n    * NOTE2:The onAll listeners will NOT make an event count as 'handled' and this\n    *       listener will still fire\n    *\n    * @param function|false listener    False removes any set listener\n    *\n    * @return void\n    */\n    BetterEvents.prototype.onUnhandled=function(listener){\n        if(listener===false || listener===null){\n            this._betterEvents.onUnhandled=null;\n            return false;\n        }else if(typeof listener!='function')\n            throw new TypeError(errString(1,'listener',listener));\n\n        //NOTE: this object has no 'e' prop, which means that emitEvent() will call it\n        //with the evt string as first arg and it will be ignored by removeEvent()\n\n        this._betterEvents.onUnhandled={l:listener};\n\n        return;\n    }\n\n    /*\n    * Add a listener for all events without preventing listener set by this.onUnhandled().\n    *\n    * PROTIP: If you what to prevent onUnhandled, try using a catch-all regex, eg. addListener(/./,()=>{...})\n    *\n    * NOTE: Listeners added this way can still be excluded when emitting\n    * NOTE2:Listeners added this way ARE NOT CHECKED FOR DUPLICATE against those set with addListener\n    * NOTE3:Listeners added this way can still be removed with removeListeners()\n    *\n    * @param function|false listener    False removes any set listener\n    * @param @opt number index          @see defaultIndex. The order in which to run the listener.\n    *\n    * @return object|false        {l,i}\n    */\n    BetterEvents.prototype.onAll=function(listener,index=undefined){\n        if(typeof listener!='function')\n            throw new TypeError(errString(1,'listener',listener));\n\n        var _b=this._betterEvents, obj=_b.onAll.find(obj=>obj.l==listener);\n        if(obj){\n            //If it already exists, just change the number if another is given here\n            if(typeof index=='number')\n                obj.i=index;\n        }else{\n            //NOTE: this object has no 'e' prop, which means that emitEvent() will call it\n            //with the evt string as first arg and it will be ignored by removeEvent()\n\n            _b.onAll.push({l:listener,i:(typeof index=='number' ? index : _b.options.defaultIndex)});\n        }\n\n        return;\n    }\n\n\n\n\n    /*\n    * Check if an event has already been emitted\n    *\n    * @param string|<RegExp> evt   NOTE: A regex will be used to match regular events, it will not match\n    *                               the string version of itself, eg. '/test/'\n    *\n    * @return string|undefined    The name of the first matching emitted event, or undefined\n    */\n    BetterEvents.prototype.alreadyEmitted=function alreadyEmitted(evt){\n        if(evt instanceof RegExp){\n            return Object.keys(this._betterEvents.emitted)\n                .find(_evt=>_evt.match(evt))\n        }else if(typeof evt=='string'){\n            return this._betterEvents.emitted.hasOwnProperty(evt)?evt:undefined;\n        }else{\n            throw new TypeError(errString(1,'evt',evt));\n        }\n    }\n\n    /*\n    * Remove stored emitted events. This will affect emitOnce(), alreadyEmitted() and after()\n    *\n    * @param string|<RegExp> evt   NOTE: A regex will be used to match regular events, it will not match\n    *                               the string version of itself, eg. '/test/'\n    * @throw TypeError\n    * @return boolean|array     Boolean if $evt is string, array of strings if $evt is RegExp\n    */\n    BetterEvents.prototype.clearEmitted=function(evt){\n        if(evt instanceof RegExp){\n            return Object.keys(this._betterEvents.emitted)\n                .filter(_evt=>{return (_evt.match(evt) ? delete this._betterEvents.emitted[_evt] : false)})\n        }else if(typeof evt=='string'){\n            return (this._betterEvents.emitted.hasOwnProperty(evt) ? delete this._betterEvents.emitted[evt] : false);\n        }else{\n            throw new TypeError(errString(1,'evt',evt));\n        }\n    }\n\n\n\n    /*\n    * Like addListener, but checks if $evt it has already been emitted and triggers $listener immediately\n    * in that case\n    *\n    * NOTE: This doesn't wait for other listeners for $evt to finish running before running $listener\n    *\n    * @param string|<RegExp> evt    @see addListener()\n    * @param function listener      @see addListener()\n    * @opt truthy once              @see addListener(). ProTip: use string 'once'\n    * @opt number index             @see addListener(). NOTE: will not be respected for previously emitted event\n    *                                 \n    * @throws TypeError\n    * @return object|undefined      If already emitted and $once==true then undefined is returned, else the \n    *                                 registered listener object  {e,o,l,i,r}\n    */\n    BetterEvents.prototype.after=function after(evt,listener,once,index){\n        //First we check if it's been emitted. If evt is regex, then _evt will be the\n        //string of the first matched emitted event.\n        var _evt=this.alreadyEmitted(evt);\n\n        //Then we possibly add it\n        if(!_evt || !once)\n            var ret=this.addListener(evt,listener,once,index);\n             //^if evt is regexp, this listener will fire every time a matching event is emitted\n\n        //Then we possibly emit right away\n        if(_evt){\n            try{\n                var args=this._betterEvents.emitted[_evt]\n                \n                //if evt is regexp, then the listener is expecting _evt to be the first arg, just \n                //like it would/will when called from emitEvent, however the stored args will\n                //not contain the event, so we need to do the same thing here that we do in emitEvent()\n                if(evt instanceof RegExp)\n                    args=[_evt].concat(args);\n\n                listener.apply(this,args);\n            }catch(err){\n                this._betterEvents.onerror(`after() event listener '${_evt}' failed:`,err\n                        ,'Called with args:',args)\n            }\n        }\n\n        return ret;\n    }\n\n    \n\n\n    /*\n    * Execute a callback once after all events in a list have been fired. \n    *\n    * @param array events\n    * @param function callback  Called with single object. Keys are event names, values are \n    *                           arrays of args emitted for that event\n    *\n    * @throws TypeError\n    * @return void\n    */\n    BetterEvents.prototype.afterAll=function(events,callback){\n        if(!events instanceof Array)\n            throw new TypeError(errString(1,'an array of events',events));\n        if(typeof callback!='function')\n            throw new TypeError(errString(2,'a callback function',callback));\n\n        //Register a listener which stores each emitted event's args and counts down until our\n        //callback can be called. \n        //2019-11-25 DEAR FUTURE ME: don't define the function seperately since we need the 'evt' which\n        //                      comes from the forEach()\n        var callbackArgs={},remaining=events.length;\n        events.forEach(evt=>this.after(evt,(...args)=>{\n            callbackArgs[evt]=args;\n\n            //...then decrement the counter and check if it's reached zero...\n            remaining--;\n            if(remaining<1){\n                //...if it has, that means all events have fired and we can now call the passed in listener\n                try{\n                    // console.log(callback);\n                    callback.call(this,callbackArgs);\n                }catch(err){\n                    console.log(err);\n                    // this._betterEvents.onerror(err);\n                }\n            }\n\n        },true));\n       \n        return;\n        \n    }\n\n\n\n\n\n\n\n\n\n    /*\n    * Get a single unique list of listeners for one or multiple events\n    *\n    * @param string|<RegExp> evt \n    *\n    * @throw TypeError\n    * @return array[function]   \n    */\n    BetterEvents.prototype.getListeners=function(evt){\n\n        var listeners;\n        if(typeof evt=='string'){\n            //Get listeners for the exact event, eg. 'shutdown_network'\n            listeners=this._betterEvents.events[evt] || [];\n\n            //...+ get listeners that have been registered with a regex to match this event \n            //and more, eg. /shutdown_.*/\n            this._betterEvents.regexp.forEach(listener=>{\n                if(evt.match(listener.e))\n                    listeners.push(listener);\n            })\n        }else if(evt instanceof RegExp){\n            var regex=evt,events=this._betterEvents.events;\n            listeners=[];\n            for(evt in events){\n                if(evt.match(regex))\n                    listeners=listeners.concat(events[evt]);\n            }\n        }else{\n            throw new TypeError(errString(1,'evt',evt));\n        }\n\n        //Get unique array\n        listeners=listeners.filter((listener,i)=>listeners.indexOf(listener)==i);\n\n        return listeners;\n    }\n\n\n    /*\n     * Count the number of listeners for a given event\n     *\n     * @param string|<RegExp>   evt             \n     * @param @opt boolean countUnhandled   Default false. If true, will return -1 if only an onUnhandled/onAll listener \n     *                                       exists for this listener\n     *\n     * @return number               \n     */\n    BetterEvents.prototype.countListeners = function countListeners(evt, countCatchAll=false) {\n        let l=this.getListeners(evt).length\n\n        if(l)\n            return l+this._betterEvents.onAll.length;\n        else if(countCatchAll && (this._betterEvents.onUnhandled||this._betterEvents.onAll.length))\n            return -1*(this._betterEvents.onAll.length+(this._betterEvents.onUnhandled?1:0));\n        else \n            return 0;\n    }\n\n    /*\n    * Check if an event has any listeners at all\n    *\n    * @param string|<RegExp> evt \n    *\n    * @return bool            \n    */\n    BetterEvents.prototype.hasAnyListeners = function hasAnyListeners(evt) {\n        //Quick check if we have any catch-alls...\n        if(this._betterEvents.onAll.length || this._betterEvents.onUnhandled)\n            return true;\n\n        //...then check for specific ones\n        return this.hasListener(evt);\n    }\n\n\n    /*\n    * Check if an event has a specific listener\n    * \n    * @param string|<RegExp> evt \n    * @param function listener\n    *\n    * @throw TypeError\n    * @return bool            \n    */\n    BetterEvents.prototype.hasListener = function hasListener(evt,listener) {\n        switch(typeof listener){\n            case 'function':\n                return this.getListeners(evt).find(obj=>obj.l==listener) ? true : false;\n            case 'object':\n                if(listener.hasOwnProperty('l') && typeof listener.l =='function'){\n                    return this.getListeners(evt).includes(listener);\n                }\n                //Else let fall through\n            default:\n                throw new TypeError(\"Expected listener function or object returned by hasListener(), got: \"+String(listener));\n        }\n    }\n\n\n\n\n\n\n    /*\n    * Get all events (incl regexp events) or string events matching a given regexp\n    *\n    * @param @opt <RegExp> evt\n    * @throw TypeError\n    * @return array[string|<RegExp>]    Array of all registered events\n    */\n    BetterEvents.prototype.getEvents=function(regexp=undefined){\n        var events=[];\n        if(regexp instanceof RegExp){\n            var evt;\n            for(evt in this._betterEvents.events){\n                if(evt.match(regexp))\n                    events.push(evt);\n            }\n\n        }else if(typeof regexp == 'undefined'){\n            events=events.concat(\n                Object.keys(this._betterEvents.events)\n                ,Object.values(this._betterEvents.regexp).map(([regexp])=>regexp).filter((r,i,a)=>a.indexOf(r)==i)\n            );\n\n        }else{\n            throw new TypeError(errString(1,'a <RegExp> or undefined',evt));\n        }\n\n        return events\n            \n    }\n\n\n\n\n\n    /*\n    * Removes a single registered evt-listener combo. Ie. if regexp is used, only a registered\n    * regexp will be removed, not every event matching that regexp\n    *\n    * @param object|function listener   A listener function, or an object with props e and l\n    * @param @opt string|<RegExp> evt\n    *\n    * @throws TypeError\n    * @throws Error     If the listener doesn't exist\n    *\n    * @return {e,o,l,i}|undefined      The removed listener objects, or undefined\n    */\n    BetterEvents.prototype.removeListener=function(listener,evt){\n        // console.log('REMOVING',listener,evt);\n        if(listener instanceof Object && evt==undefined){\n            if(!listener.e){\n                // console.log('non-standard listener:',arguments)\n                return undefined //ie. a non-standard listener, not stored on .events or .regexp\n            }\n\n            evt=listener.e\n            listener=listener.l\n        }\n\n        var arr;\n        if(typeof evt=='string')\n            if(this._betterEvents.events[evt] instanceof Array)\n                arr=this._betterEvents.events[evt]\n            else\n                throw new Error(\"No such event: \"+evt);\n        else if(evt instanceof RegExp)\n            arr=this._betterEvents.regexp;\n        else\n            throw new TypeError(errString(2,'evt',evt));\n\n\n        let i=arr.findIndex(({e,l})=>l==listener && e==evt);\n        if(i>-1){\n            // console.log(\"Removing \", arr[i])\n            return (arr.splice(i,1))[0];\n        }\n        else\n            throw new Error(\"No such listener: \"+typeString(listener));\n\n\n    }\n\n    /*\n    * Removes all instances of a listener function from everywhere\n    *\n    * @param function listener\n    *\n    * @throws TypeError\n    *\n    * @return array[string|<RegExp>]    An array of the events the listener\n    *                                   was removed from (can be empty)\n    */\n    BetterEvents.prototype.removeListeners=function(listener){\n        if(typeof listener !='function')\n            throw new TypeError(errString(1,'listener',listener));\n        \n        var events=[];\n\n        function remove(arr, evt){\n            var i=arr.length-1;\n            for(i;i>=0;i--){\n                if(arr[i].l==listener){\n                    events.push(evt||arr[i].e);\n                    arr.splice(i,1);\n                }\n            }\n        }\n\n        this._betterEvents.events.forEach(remove)\n\n        remove(this._betterEvents.regexp);\n        remove(this._betterEvents.onAll,'onAll');\n\n        if(this._betterEvents.onUnhandled.l==listener){\n            events.push('onUnhandled');\n            this._betterEvents.onUnhandled=null;\n        }\n\n        return events\n    }\n\n\n    /*\n    * Remove all listeners for a given event. If regexp is passed, all matching _betterEvents.regexp will be\n    * removed but _betterEvents.events won't be touched\n    *\n    * @param string|<RegExp> evt\n    *\n    * @return array[object]     An array of all the \"listener objects\" that where removed (may be empty)\n    */\n    BetterEvents.prototype.removeEvent=function(evt){\n        let b=this._betterEvents, removed=[];\n        if(typeof evt=='string'){\n            if(Array.isArray(b.events[evt])){\n                removed=b.events[evt];\n                delete b.events[evt];\n            }\n        }else if(evt instanceof RegExp){\n            //Since regexp events are stored as [[],[]] instead of {[],[]}, we have to loop through\n            //them all and remove matches\n            evt=evt.toString();\n            var i;\n            for(i=b.regexp.length; i>-1;i--){\n                if(b.regexp[i][0].toString()==evt){\n                    removed.push(b.regexp.splice(i,1))\n                }\n            }\n        }else{\n            throw new TypeError(errString(1,'evt',evt));\n        }\n        return removed;\n    }\n\n\n\n    /*\n    * Calls either removeListener or removeEvent depending on if arg#2 is passed or not\n    *\n    * @param @opt string|<RegExp> evt\n    * @param @opt function|object listener  \n    *\n    * @return number   The number of removed listeners\n    */\n    BetterEvents.prototype.off=function(){\n        var evt,listener,i,x;\n        for([i,x] of Object.entries(arguments)){\n            if(typeof x=='function')\n                listener=x;\n            else if(typeof x=='string'||x instanceof RegExp)\n                evt=x;\n            else if(x instanceof Object && typeof x.l=='function')\n                listener=x;\n\n            else\n                throw new TypeError(`Expected string, <RegExp>, function or object, arg#${i} was: `\n                    +typeString(x));\n        }\n        if(listener){\n            if(!evt && typeof listener=='function'){\n                return this.removeListeners(listener).length;\n            }else{\n                return this.removeListener(listener,evt) ? 1 : 0;\n            }\n        }else{\n            return this.removeEvent(evt).length;\n        }\n\n    }\n\n\n\n\n\n\n    BetterEvents.prototype.interceptEvent=function(evt,interceptor){\n        if(typeof evt !='string')\n            throw new TypeError(errString(1,'s_evt',evt));\n        if(typeof interceptor !='function')\n            throw new TypeError(errString(2,'interceptor',interceptor));\n\n        this._betterEvents.intercept[evt]=interceptor;\n    }\n\n    BetterEvents.prototype.stopIntercepting=function(evt){\n        if(typeof evt !='string')\n            throw new TypeError(errString(1,'s_evt',evt));\n\n        delete this._betterEvents.intercept[evt];\n    }\n\n\n\n\n\n\n\n\n\n\n    /*\n    * For internal use by emitEvent. Will add onAll and onUnhandled listeners to $listeners array\n    *\n    * @param string|<RegExp> evt\n    * @param function|array[function] exclude\n    *\n    * NOTE: this returns an object, which is un-ordered by def, so the order of the groups is \n    *       determined by sorting the keys in numerical order, which is done in _getStatusObj\n    *\n    * @return object      Keys are indexes, values are arrays listener objects.\n    *                                       { \"-1\":[{l,i:-1}]\n    *                                           ,0:[{l,o,e}]        \n    *                                           ,1:[{l,o,i,e},{l,o,i,e},...] \n    *                                            ,...\n    *                                       }\n    * @call(this)\n    * @private\n    */\n    function _getGroupedListeners(evt,exclude){\nif(evt=='settings') console.log('_getGroupedListeners exclude:',exclude)\n\n        var listeners=this.getListeners(evt)\n\n        //If no listeners were found, this is an 'unhandled' event, which merits the onUnhandled listener\n        if(!listeners.length && this._betterEvents.onUnhandled ){\n            // console.log('Adding onUnhandled')\n            listeners.push(this._betterEvents.onUnhandled)\n        }\n        // else{console.log('NOT adding onUnhandled to:',listeners)}\n\n        //If onAll has been specified, always add it (will end up first in its group, but unless the group\n        //is otherwise empty it will run concurrently with other listeners)\n        if(this._betterEvents.onAll.length){\n            // console.log('Adding onAll')\n            listeners=[].concat(this._betterEvents.onAll,listeners)\n        }\n\n         //Remove any we want to exclude (parseOptions should have made sure it's an array)\n        if(exclude){\n            exclude.forEach(listener=>{\n                let i=listeners.findIndex(({l})=>l==listener)\n                if(i>-1)\n                    listeners.splice(i,1);\n            })\n        }\n\n        //Group listeners based on their index\n        var groups={};\n        listeners.forEach(listener=>{\n            let i=(listener.hasOwnProperty('i')?listener['i']:0);\n            (groups[i]=groups[i]||[]).push(listener)\n        })\n\n        return groups;\n    }\n\n\n\n    /*\n    * @param object groups  The object returned by _getGroupedListeners()\n    * @opt boolean simple   Default false. If true the returned object will lack all bells and whistles\n    * @return object        The object populated and then returned by emitEvent\n    * @private\n    */\n    function _getStatusObj(groups,simple=false){\n        let o={};\n        Object.defineProperties(o,{\n            'results':{value:[]}\n            ,'groups':{value:Object.keys(groups).sort()}// <<---------------------------------- this is what decides group order\n        });\n\n        for(let i in groups){\n            o[i]={};\n            for(let j in groups[i]){\n                o[i][j]='waiting';\n            }\n            if(!simple){ \n                //Add sum'ers for states in the group\n                Object.defineProperties(o[i],{\n                    'length':{value:Object.keys(o[i]).length}\n                    ,'listeners':{value:groups[i]}\n                    ,'waiting':{get:()=>Object.values(o[i]).reduce((sum,state)=>sum+(state=='waiting'?1:0),0)}\n                    ,'executing':{get:()=>Object.values(o[i]).reduce((sum,state)=>sum+(state=='executing'?1:0),0)}\n                    ,'finished':{get:()=>Object.values(o[i]).reduce((sum,state)=>sum+(state=='finished'?1:0),0)}\n                    ,'started':{get:()=>o[i].length>o[i].waiting}\n                    ,'remaining':{get:()=>o[i].length-o[i].finished}\n                    ,'done':{get:()=>o[i].executing==0&&o[i].started}\n                    ,'progress':{get:()=>o[i].finished/o[i].length}\n                    ,'names':{value:Object.values(groups[i]).map(obj=>obj.l.name||'anonymous')}\n                    ,'entries':{get:()=>o[i].names.map((name,j)=>[name,o[i][j],i,j])}\n                     //^use this last one to get list of unfinished funcs... or better yet use the aggregate one vv\n                })\n            }\n\n        }\n\n        if(!simple){\n            Object.defineProperties(o,{\n                'length':{value:Object.values(o).reduce((sum,group)=>sum+group.length,0)}\n                ,'listeners':{value:groups}\n                ,'waiting':{get:()=>Object.values(o).reduce((sum,group)=>sum+group.waiting,0)}\n                ,'executing':{get:()=>Object.values(o).reduce((sum,group)=>sum+group.executing,0)}\n                ,'finished':{get:()=>o.results.length}\n                ,'progress':{get:()=>o.finished/o.length}\n                ,'groupsStarted':{get:()=>Object.values(o).reduce((sum,group)=>sum+(group.started?1:0),0)}\n                ,'groupsDone':{get:()=>Object.values(o).reduce((sum,group)=>sum+(group.done?1:0),0)}\n                ,'groupsExecuting':{get:()=>o.length-o.groupsDone}\n                ,'groupsWaiting':{get:()=>o.length-o.groupsStarted}\n                ,'entries':{get:()=>{\n                    var entries=[];\n                    for(let i of Object.keys(o)){\n                        o[i].entries.forEach(entry=>{\n                            entry.push(i);\n                            entries.push(entry);\n                        })\n                    }\n                    return entries;\n                }}\n                ,'intercepted':{value:false, writable:true}\n            })\n        }\n\n        return o;\n    }\n\n\n\n\n\n\n\n\n\n    /**\n    * Call all listeners for an event async/concurrently\n    *\n    * @param string evt\n    * @param @opt array args\n    * @param @opt object options    Props may include\n    *                                exclude - function|array    One or more listeners to exclude\n    *                                onProgress - function       A callback called after each change to the returned object\n    *                                groupTimeout - number      \n    *                                simple - boolean            If true, only status.promise will be returned, and any progress\n    *                                                             callback will only get simple status object as arg#2\n    *\n    * @throws TypeError\n    * @return object        @see _getStatusObj() + additional properties:\n    *                           results - array[array...] The response from each listener, in whatever order they finish, \n    *                                                      good/bad/undefined all mixed together. Child arrays contain:\n    *                                                        ['success boolean', 'return value', 'group id', 'in-group id']\n    *                           promise - <Promise>       Resolves (always) with $results after ALL listeners have run \n    *                                                       to end.\n    *\n    * @return-if($options.simple==true) promise                              \n    */\n    BetterEvents.prototype.emitEvent = function(evt, args=undefined, options=undefined) {\n        //Only allow string events. For emitting all events that match a regexp, use emitEvents()\n        if(typeof evt!='string')\n            throw new TypeError(errString(1,'s_evt',evt));\n\n        var _b=this._betterEvents\n        options=parseOptions(_b.options,options)\n        var prog=options.onProgress; //will always be a func, possibly an empty one\n\n\n        var groups=_getGroupedListeners.call(this,evt,options.exclude);\n        var status=_getStatusObj(groups,options.simple); //<-- this is the object returned\n\n        //Determine what all the emitters will be called as (remember, if they've bound to something else, this won't matter)\n        switch(options.emitAs){\n            case 'global':\n                options.emitAs=globalObj; break;\n            case 'shared':\n                options.emitAs={}; break;\n            case 'status':\n                options.emitAs=status; break;\n            case 'empty':\n                Object.defineProperty(options,'emitAs',{get:()=>{return {};}}); break;\n            default: //there should be no other choises... but whatever\n            case 'this':\n                options.emitAs=this; break;\n        }\n        // console.log('EMITTING:',evt)\n        //Make sure we have an array. This also copies delinks it from the passed in array\n        args=[].concat(args);\n\n        //Allow possibility to intercept an event, either changing the args or preventing it from propogating at all\n        if(_b.intercept.hasOwnProperty(evt)){\n            args=_b.intercept[evt](args);\n            if(!Array.isArray(args)){\n                status.intercepted=true;\n                prog(evt,status);\n            }\n        }\n\n        var self=this\n        var allDone= new Promise(async function p_emitEvent(resolve){\n            try{\n\n                //Set event as emitted\n                _b.emitted[evt]=args;\n\n                //Loop through all groups, calling all listener in them concurrently/asynchronously, then\n                //wait for the group to finish before moving on to next group, OR timeout a group if opted\n                var i,last=status.groups.slice(-1),argsRegexp,_args;\n                for(i of status.groups){\n                    var promises=groups[i].map(async function c_emitEvent(listener,j){\n                        try{\n                            status[i][j]='executing'\n                            prog(evt,status,i,j)\n                            //First check if this is a a one-time listener (do this before calling in case\n                            //the callback emits the event again). NOTE: This will have no effect\n                            if(listener.o === true)\n                                self.removeListener(listener);\n\n                            //For all listeners that don't have an 'exact match' string event, add\n                            //the event to the args\n                            if(typeof listener.e =='string')\n                                _args=args;\n                            else\n                                _args=argsRegexp||(argsRegexp=[evt].concat(args));                            \n\n                            //Then run the listener and add the result to the resolve-array\n                            let res=await listener.l.apply(options.emitAs,_args);\n                            status.results.push([true,res,i,j]);\n                            \n\n                            //Finally check if the result implies that we turn off the listener\n                            if(res=='off')\n                                self.removeListener(listener);\n\n                        }catch(err){\n                            // console.log(err);\n                            _b.onerror('Listener failed.',{evt, listener, _args},err)\n                            status.results.push([false,err,i,j]);\n                        }\n                        status[i][j]='finished'\n                        prog(evt,status,i,j)\n                        return; //Always return, never throw, since these promises are used to determine \n                                //when all listeners are done\n                    })\n                    \n                    //...then wait for them all to finish OR add a timeout\n                    var groupedPromises=Promise.all(promises);\n                    if(_b.options.groupTimeout && i!=last){ //last group cannot timeout\n                        try{\n                            let timeout=new Promise((nada,expireGroup)=>{setTimeout(expireGroup,_b.options.groupTimeout)})\n                            await Promise.all([groupedPromises,timeout])\n                        }catch(err){\n                            _b.onerror(`Group ${i} timed out, triggering next group...`);\n                        }\n                    }else{\n                        await groupedPromises;\n                    }\n                }\n            \n            }catch(err){\n                console.error('BUGBUG BetterEvents.emitEvent():',err);\n            }\n            return resolve(status.results); //resolves the 'allDone' promise with the 'results'\n        });\n\n        if(options.simple){\n            return allDone;\n        }else{\n            Object.defineProperty(status,'promise',{value:allDone}); //so it doesn't get counted by getter, @see getStatusObj()\n            return status;\n        }\n    }\n\n\n   \n\n    /*\n    * Trigger all listeners that match a regexp. \n    *\n    * @param string evt\n    * @param @opt array args\n    * @param @opt object options\n    *\n    * @throws TypeError\n    * @return Promise(void,n/a)     //TODO 2020-02-25: resolve with array just like emit()\n    */\n    BetterEvents.prototype.emitEvents=function(regexp,args,options){\n        \n        if(!regexp instanceof RegExp)\n            throw new TypeError(errString(1,'r_evt',evt));\n       \n        var self=this;\n        return new Promise(function _emitEvents(resolve){\n\n            var events=self.getEvents(regexp);\n\n            var promises=events.map(evt=>self.emitEvent(evt,args,options).promise);\n\n            Promise.all(promises).then(()=>resolve());\n\n        }).catch(err=>{\n            self._betterEvents.onerror('BUGBUG BetterEvents.emitEvents():',err);\n        })\n\n    }\n\n\n\n    /*\n    * Calls emitEvent or emitEvents with multiple args concated into an array\n    *\n    * @throw TypeError\n    * @return Promise(array|void)    Resolves when all listeners are done. If a string $evt was used it resolves \n    *                                  with an array of arrays, each child containing: \n    *                                   [(bool)success,(any)returned value ,(number) group id, (number) within-group id]\n    *                                  else it resolves with void\n    */\n    BetterEvents.prototype.emit=function emit(evt,...args){\n// if(evt=='shutdown'){console.log('emit called',args)}\n        if(evt instanceof RegExp)\n            return this.emitEvents(evt,args);\n        else if(typeof evt=='string')\n            return this.emitEvent(evt,args).promise;\n        else\n            throw new TypeError(errString(1,'evt',evt));\n        \n    }\n\n    /*\n    * Emit an event once, not doing anything if it's already been emitted\n    * @throw TypeError\n    * @return Promise(array|void)   Resolves right away with void (if previously emitted), or when emit() resolves\n    */\n    BetterEvents.prototype.emitOnce=function emitOnce(...args){\n        if(!this.alreadyEmitted(args[0])){\n            return this.emit.apply(this,args);\n        }else{\n            return Promise.resolve();\n        }\n    }\n\n\n\n\n    /*\n    * Add an event to a buffer and call emit() after a delay. If the same event is buffered\n    * again within that delay the newer args are emitted instead. \n    *\n    * @throw TypeError\n    * @return void\n    */\n    BetterEvents.prototype.bufferEvent=function bufferEvent(evt,...args){\n        if(typeof evt !='string')\n            throw new TypeError(errString(1,'s_evt',evt));\n\n        var _b=this._betterEvents\n\n        _b.buffer[evt]=args;\n\n        //Check if we've already triggered the timeout\n        if(!_b.delayTimeout){\n\n            var triggered = Date.now();\n        \n            _b.delayTimeout=setTimeout(()=>{\n                //Log...\n                var actualDelay=Date.now()-triggered;\n                if((actualDelay-_b.options.bufferDelay)>Math.min(_b.options.bufferDelay*0.1,100))\n                    console.warn(\"WARNING: Delayed event slow. Expected \"+_b.options.bufferDelay+\" ms, actual \"\n                        +actualDelay+\" ms\");\n\n                //Empty buffer and reset flag so it can be triggered again\n                var buffer=_b.buffer;\n                _b.buffer={};\n                _b.delayTimeout = null;\n\n                //Emit each event individually...\n                for(let evt in buffer){\n                    this.emitEvent(evt,buffer[evt]);\n                }\n\n                //...then emit the buffer as a whole\n                this.emit('_buffer',buffer);\n\n            }, _b.options.bufferDelay)\n        }\n\n        return ;    \n    }\n\n\n\n\n\n\n//TODO 2020-03-19: is 'this' the same as 'global' in nodejs?\n\n}(typeof window !== 'undefined' ? window : this || {}));\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./events/better_events.js?");

/***/ }),

/***/ "./log/better_log.js":
/*!***************************!*\
  !*** ./log/better_log.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, __filename) {//simpleSourceMap=/my_modules/better_log.js\n//simpleSourceMap2=/lib/better_log.js\n/*\n* @module BetterLog\n* @author plundell \n* @email qmusicplayer@protonmail.com\n* @license MIT\n* @exports A contructor function for {BetterLog} instances.\n*\n* This module exports a constructor for a logger. It can be required by NodeJS or loaded directly\n* in a browser with <script src=\"/path/to/better_log.js>\"\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*\n* TODO 2019-06-13: Add source map support. Look at:\n*\t\thttps://github.com/xpl/stacktracey\n*\t\thttps://github.com/xpl/get-source\n* \t\thttps://github.com/mozilla/source-map\n*\n* TODO 2020-02-07: Use more of devtools console functionality\n*\t\thttps://github.com/jaredwilli/devtools-cheatsheet\n*/\n;'use strict';\n(function(globalObj){\n\t\n\t//Export from module if available\n    if( true && module.exports){\n        module.exports = BetterLog;\n        BetterLog._env='terminal';   //will be overwritten if 'window' is also available vv\n    }\n\n    //Set on window if available\n    if(typeof window === 'object'){\n    \twindow.BetterLog=BetterLog;\n        BetterLog._env='browser'; \n    }\n\n\n\n\n\tconst logLvl=[\n\t\t{str:'trace',STR:'TRACE',nr:1,colorTerm:96,colorBrow:'background:cyan;color:black',print:console.debug}\n\t\t,{str:'debug',STR:'DEBUG',nr:2,colorTerm:94,colorBrow:'background:#5862f3;color:white',print:console.debug}\n\t\t,{str:'info',STR:'INFO',nr:3,colorTerm:92,colorBrow:'background:#3bd473;color:black',print:console.log}\n\t\t,{str:'note',STR:'NOTE',nr:4,colorTerm:93,colorBrow:'background:#f23dfb;color:white',print:console.warn}\n\t\t,{str:'warn',STR:'WARN',nr:5,colorTerm:91,colorBrow:null,print:console.warn}\n\t\t,{str:'error',STR:'ERROR',nr:6,colorTerm:101,colorBrow:null,print:console.error}\n\t]\n\n\t//For faster lookup, create a lookup table who's keys are both number and string id's of levels\n\tconst lvlLookup={};\n\tlogLvl.forEach(obj=>{lvlLookup[obj.str]=obj;lvlLookup[obj.nr]=obj;})\n\n\t\t/*\n\t\t\tTerminal color cheat sheet\n\n\t\t\tColor\t\t\tText    Background\n\t\t\tBlack           30      40\n\t\t\tRed             31      41\n\t\t\tGreen           32      42\n\t\t\tYellow          33      43\n\t\t\tBlue            34      44\n\t\t\tMagenta         35      45\n\t\t\tCyan            36      46\n\t\t\tWhite           37      47\t\n\t\t\tBright Black    90      100\n\t\t\tBright Red      91      101\n\t\t\tBright Green    92      102\n\t\t\tBright Yellow   93      103\n\t\t\tBright Blue     94      104\n\t\t\tBright Magenta  95      105\n\t\t\tBright Cyan     96      106\n\t\t\tBright White    97      107\n\t\t*/\n\tconst highlightColor={\n\t\t'red':{colorTerm:41,colorBrow:'red'}\n\t\t,'blue':{colorTerm:44,colorBrow:'blue'}\n\t\t,'magenta':{colorTerm:45,colorBrow:'magenta'}\n\t\t,'green':{colorTerm:42,colorBrow:'green'}\n\t\t,'yellow':{colorTerm:43,colorBrow:'yellow'}\n\t}\n\n\n\tfunction getLogLvl(x=3,d=3){\n\t\treturn (lvlLookup.hasOwnProperty(x) ? lvlLookup[x].nr : d);\n\t}\n\n\tconst defaultOptions={\n\t\tautoPrintLvl:5 //Lowest level to get printed automatically when entry in created, default everything, 0==off\n\t\t,lowestLvl:1 //Lowest level to even process, used only by the shortcuts this.debug|info etc... (set to at least 2 in production)\n\t\t,appendSyslog:true\n\t\t,printStackLvl:0 //0==off, the lowest level at which to print stack\n\t\t,printStackLines:0 //0==all, or rather see Error.stackTraceLimit. number of lines of stack to print at most\n\t\t,hideParentStack:false //true==when printing bubbled stacks, remove lines also present it parent stack\n\t\t,printColor:true\n\t\t,printWhere:true //appends each line with file:line:index of log\n\t\t,printFunc:true\n\t\t,printId:false\n\t\t,printTime:false\n\t\t,printMs:true //will override printTime\n\t\t,printSelfOnLvl:0 //0==off. only available in browser, prints BLE object as last extra if lvl >=\n\t\t,name:null //Overrides this.toString(). Gets printed with each message. May be appeneded with interger if not unique\n\t\t,namePrefix:false //Printed before name. Default nothing. Suitable for default options or one-time use, else just use 'name'\n\t\t,breakOnError:false\n\t\t,extraLength:400\n\n\t\t,hideInternalStack:true //true==remove stack entries that refers to internal stuff. Only works as static option\n\t\t,rootPath:(typeof process=='object'&&process&&process.cwd?process.cwd():false) //root path that will be replaced by '.' from ALL paths (stack + end of line)\n\t\t,fileOnly:true //overrides rootPath, only prints the file, not entire path\n\t\t,hideThisFileStack:true //true==remove stack entries comming from this file. Can be turned off if packing into single file removes too much\n\t}\n\n\t//This will get set by the first instance to be created \n\tvar startTime;\n\n\t//Since this file can add a bunch of lines to the stack, change it from default of 10 to 20\n\ttry{\n\t\tif(Error.stackTraceLimit==10)\n\t\t\tError.stackTraceLimit=20\n\t}catch(err){console.error(err)}\n\n\t/*\n\t* Constructor\n\t*\n\t* @param any \tunit \t\t\tSomething to identify the log when filtering later. MUST BE UNIQUE\n\t* @param object options\n\t*/\n\tfunction BetterLog(unit,options={}){\n\n\t\tconst self=this;\n\n\t\tObject.defineProperty(this,'_isBetterLog',{value:true});\n\n\t\tthis.options=Object.assign({},defaultOptions,options);\n\n\t\t//These are 2 ways to uniquely identify a log instance:\n\t\t// \t1. this.unit   arg#1        any      unique       Preferably an object instance (which are unique by def)\n\t\t//  2. this.name   arg#2.name   string   unique       The string that will be printed in each log. Defaults to \n\t\t//                                                      this.toString()+integer. \n\t\tif(BetterLog._instances.has(unit)){\n\t\t\tconsole.error('Existing BetterLog unit ',unit,BetterLog._instances.get(unit));\n\t\t\tthrow new Error('BetterLog unit already exists (see previous console.error)');\n\t\t}else{\n\t\t\tthis.unit=unit;\n\t\t\tBetterLog._instances.set(unit,this); //so we can always find it + keep things unique\n\t\t}\n\n\t\t//Find and set a unique name for this instance\n\t\tthis.changeName(this.options.name)\n\n\n\n\t\t//First instance => set start time\n\t\tif(!startTime)\n\t\t\tthis.resetStartTime();\n\n\t\t/*\n\t\t* @prop array entries \tAll entries of this array. Gets appeneded by BetterLogEntry.exec()\n\t\t*/\n\t\tthis.entries=Array();\n\n\n\t\t//Secret array to hold all listeners to this log\n\t\tObject.defineProperty(this,'_listeners',{value:[]});\n\n\n\t\t/*\n\t\t* @prop object codes \tKeys are short strings, values are longer descriptions.\n\t\t*\n\t\t* NOTE: Used by this.throwCodes. If specific key isn't found, see BetterLog.prototype._codes\n\t\t*/\n\t\tthis.codes={}\n\n\n\n\t\t//To enable passing logging functions to iterators or as callbacks we define several shortcuts\n\t\t//on this instance, bound to this instance (or using self-object)\n\n\t\t\t//Define methods for each of the log levels on 'this', bound to this instance, so we don't have \n\t\t\t//to worry about context when calling them (eg. when passing them)\n\t\t\tfunction callBetterLogFunc(obj,msg,...extra){\n\t\t\t\t//^ NOTE: So we can easily filter away calls to within this file even in complex circumstances \n\t\t\t\t//        we make sure the name of the func includes 'BetterLog'\n\t\t\t\ttry{\n\t\t\t\t\t//If we're ignoring below this level, just return the fakeEntry\n\t\t\t\t\tif(obj.nr>=this.options.lowestLvl){\n\t\t\t\t\t\tthis.makeEntry.apply(this,[obj.nr,msg].concat(extra)).exec();\n\t\t\t\t\t}\n\n\t\t\t\t}catch(err){\n\t\t\t\t\tconsole.error(`BUGBUG BetterLog.${obj.str}():`);\n\t\t\t\t\tconsole.error(err, err.stack);\n\t\t\t\t\tconsole.error(\"Arguments:\",msg,extra)\n\t\t\t\t}\n\n\t\t\t\t//Unlike makeEntry/makeError etc. this func doesn't return anything... so we never expect them to \n\t\t\t\t//return anything... so when ignoring lower levels of logs in production we know not to use thse\n\t\t\t\t//shorthands, if we need the entry we just makeEntry explicitly\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogLvl.forEach(obj=>{\n\t\t\t\tObject.defineProperty(this, obj.str, {\n\t\t\t\t\tenumerable:true\n\t\t\t\t\t,value:callBetterLogFunc.bind(this,obj)\n\t\t\t\t})\n\t\t\t})\n\n\n\t\t/*\n\t\t* @see this.makeTrace()\n\t\t*\n\t\t* @return void \t\tLike this.trace, this method returns nothing\n\t\t*/\n\t\tthis.traceFunc=function(...args){\n\t\t\ttry{\n\t\t\t\tif(self.options.lowestLvl==1){\n\t\t\t\t\t//Make a trace, then proceed like regular logging, appending it, emitting it, printing it...\n\t\t\t\t\tself.makeTrace.apply(self,args).exec();\n\t\t\t\t}\n\t\t\t}catch(err){\n\t\t\t\tconsole.error('BUGBUG',err);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\n\t\t/*\n\t\t* Log and throw a <BLE>\n\t\t* @throws <BLE>\n\t\t* @return void\n\t\t*/\n\t\tthis.throw=function(...args){\n\t\t\tself.makeError.apply(self, args).exec().throw(); //will also print if autoPrintLvl<6\n\t\t}\n\n\n\t\t/*\n\t\t* Similar to this.throw(), but .typeError() is used instead of .error() (which also implies that nothing\n\t\t* gets printed)\n\t\t*\n\t\t* @throws <ble TypeError>\n\t\t* @return void\n\t\t* @no_print\n\t\t*/\n\t\tthis.throwType=function(...args){\n\t\t\tself.makeTypeError.apply(self,args).throw();\n\t\t}\n\n\n\t\t/*\n\t\t* Log, then return rejected promise\n\t\t* @return Promise(n/a,<BLE>)\n\t\t*/\n\t\tthis.reject=function(...args){\n\t\t\tvar entry=self.makeError.apply(self, args).exec() //will also print if autoPrintLvl<6\n\t\t\t\n\t\t\t// return Promise.reject('[@ '+entry.func+'()] '+String(entry.msg)); //2019-03-16: Why only reject with string?? trying to change...\n\t\t\treturn Promise.reject(entry);\n\t\t}\n\n\t\t/*\n\t\t* Like this.throwType(), but a we return a rejected promise instead\n\t\t* @throws <BLE>\n\t\t* @return void\n\t\t*/\n\t\tthis.rejectType=function(){\n\t\t\ttry{\n\t\t\t\tself.throwType.apply(self,Object.values(arguments));\n\t\t\t}catch(err){\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t* Print out entry, making it visibly noticeble, regardless what the lowest listening level is set to\n\t\t* @return <BLE>\n\t\t*/\n\t\tthis.highlight=function(...args){\n\t\t\t//If no predefined color was specified, assume we didn't specify a color at all so arg#1 is really arg#2 as so on...\n\t\t\tvar color='red';\n\t\t\tif(typeof args[0]=='string' && highlightColor.hasOwnProperty(args[0]))\n\t\t\t\tcolor=args.shift();\n\n\t\t\t//If no level was given, default to 'note'\n\t\t\tif(!logLvl.hasOwnProperty(args[0]))\n\t\t\t\targs.unshift('note');\n\n\t\t\t//Now create, colorize, print and return the entry \n\t\t\treturn self.makeEntry.apply(self,args).highlight(color).exec();\n\t\t}\n\n\n\t\t/*\n\t\t* Create and throw a BLE with a code. @see this.makeCodeError()\n\t\t*\n\t\t* @throws <BLE>\n\t\t* @return n/a\n\t\t* @not_printed\n\t\t*/\n\t\tthis.throwCode=function(code){\n\t\t\tself.makeCodeError(code).throw();\n\t\t}\n\n\t//done defining bound shortcuts..\n\n\t\n\n\n\t}//End of BetterLog constructor\n\t\n\n\t\n\tBetterLog._BetterLogEntry=BetterLogEntry;\n\t\n\tBetterLog.varType=varType;\n\tBetterLog.logVar=logVar;\n\tBetterLog.parseStackLine=parseStackLine;\n\n\n\n\n    /*\n    * Extend version of native Map class which supports \"aliases\". This gives the ability to use multiple\n    * \"keys\" for the same value, without affecting size or iteration\n    */\n    BetterLog.BetterMap=BetterMap;\n\tfunction BetterMap(data){\n\t    var map=new Map(data);\n\t    var __has=map.has.bind(map);\n\t    var __get=map.get.bind(map);\n\t    var __set=map.set.bind(map);\n\t    var __delete=map.delete.bind(map);\n\t    var aliases=new Map();\n\t    function resolveAlias(key){return __has(key)||!aliases.has(key) ? key : aliases.get(key);}\n\t    var restricted=['set','get','has','delete'];\n\t    Object.defineProperties(map,{\n\t        aliases:{value:aliases}\n\t        ,has:{value:function _has(key){return __has(resolveAlias(key))}}\n\t        ,get:{value:function _get(key){return __get(resolveAlias(key))}}\n\t        ,set:{value:function _set(key,value){\n\t        \tkey=resolveAlias(key);\n\t        \tif(typeof key=='string'&&!map.hasOwnProperty(key))\n\t        \t\tObject.defineProperty(map,key,{configurable:true,get:()=>__get(key),set:(val)=>_set(key,val)})\n\t        \treturn __set(key,value)}\n\t        }     \n\t        ,delete:{value:function _delete(key){\n\t\t\t\tkey=resolveAlias(key);\n\t        \tif(typeof key=='string'&&!restricted.includes(key))\n\t        \t\tdelete map[key];\n\t        \treturn __delete(key)}}  \n\t    })\n\t    return map;\n\t}\n\t\n\t//...then use it to hold all created instances\t\t\t\t\t\t\t  \n\tBetterLog._instances=BetterMap();\n\n\n\n\n\n\n\n\n\tObject.defineProperty(BetterLog,'_sourceMap',{value:{}})\n\tObject.defineProperties(BetterLog._sourceMap,{\n\t\t//Stores previous lookups to speed up lines that get looked up constantly\n\t\tcache:{value:{},writable:true}\n\n\t\t/*\n\t\t* Add data to the local sourcemap. Data should be generated with:\n\t\t*\tgrep //XXXsimpleSourceMap= <path to file> -n | sed -r 's#//XXXsimpleSourceMap=##' | tr '\\n' ';' >> $TARGET\"/$1.js\"\n\t\t* (remove XXX from above command, that's just there so grep doesn't match this line)\n\t\t* which produces the format\n\t\t*\t2:\"better_events.js\"\n\t\t*\t1019:\"\"\n\t\t*\t1022:\"better_log.js\"\n\t\t*\t3012:\"\"\n\t\t* which should be passed to this method\n\t\t*\n\t\t* @param string file \tThe name of combine/ugly file\n\t\t* @param string data \tThe string generated by the above command\n\t\t*/\n\t\t,add:{value:function addSourceMap(file,data){\n\t\t\tif(typeof file!='string' || typeof data!='string')\n\t\t\t\tthrow new TypeError(\"Expected 2 strings, the full path and the sourcemap string, got: \"\n\t\t\t\t\t+logVar(file)+' , '+logVar(data));\n\n\n\t\t\tBetterLog._sourceMap[file]=data.split(';')\n\t\t\t\t.map(line=>{let arr=line.split('=');arr[0]=Number(arr[0])-1;return arr;})\n\t\t\t\t.filter(arr=>arr.length==2 && typeof arr[0]=='number' && typeof arr[1]=='string');\n\n\t\t\tBetterLog._syslog.info(\"Added simpleSourceMap for \"+file,BetterLog._sourceMap[file]);\n\t\t\t\n\t\t\t//Clear cache since we may have added previously cached missing stuff\n\t\t\tBetterLog._sourceMap.cache={};\n\n\n\t\t\treturn;\n\t\t}}\n\t\t/*\n\t\t* Use the source map to translate a fileline given by an error stack to the fileline of the original file\n\t\t*\n\t\t* @param string line \tA line like http://localhost/lib.js:1222:34\n\t\t*\n\t\t* @return string||undefined  \t\n\t\t*/\n\t\t,lookup:{value:function lookupSource(str,prependOrigin=false){\n\t\t\t// debugger;\n\t\t\t//First check if we've already found the source of this line...\n\t\t\tif(BetterLog._sourceMap.cache.hasOwnProperty(str))\n\t\t\t\treturn BetterLog._sourceMap.cache[str];\n\n\t\t\tvar arr=str.split(':')\n\t\t\t\t,pos=arr.pop()\n\t\t\t\t,line=arr.pop()\n\t\t\t\t,file=arr.join(':')\n\t\t\t;\n\n\t\t\tif(BetterLog._sourceMap.hasOwnProperty(file)){\n\t\t\t\tlet list=BetterLog._sourceMap[file];\n\t\t\t\tfor(let i=list.length-1;i>=0;i--){\n\t\t\t\t\tif(line>list[i][0]){\n\n\t\t\t\t\t\t//Empty values (which are used to mark the end of a file) implies that this\n\t\t\t\t\t\t//line is outside any map and we jump to bottom and handle as such\n\t\t\t\t\t\tif(!list[i][1])\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tvar source=`${list[i][1]}:${line-list[i][0]}:${pos}`;\n\t\t\t\t\t\tif(prependOrigin)\n\t\t\t\t\t\t\tsource=document.location.origin+source;\n\t\t\t\t\t\tBetterLog._sourceMap.cache[str]=source\n\t\t\t\t\t\treturn source;\n\t\t\t\t\t}   \t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//If we didn't find anything we don't want to search again next time, so store the string with\n\t\t\t//an empty str\n\t\t\tBetterLog._sourceMap.cache[str]=undefined\n\t\t\treturn undefined;\n\t\t}}\n\n\t\t,length:{get:function length(){\n\t\t\treturn Object.keys(BetterLog._sourceMap).length\n\t\t}}\n\t})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tBetterLog.prototype._isLog=BetterLog._isLog=function(x){\n\t\tif(x && typeof x=='object' && x.constructor.name=='BetterLog'){\n\t\t\tif(!(x instanceof BetterLog)){\n\t\t\t\tBetterLog._syslog.warn(\"BetterLog has been exported at least twice:\",BetterLog._syslog, x.constructor._syslog)\n\t\t\t}\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t} \n\t}\n\n\t/*\n\t* The string of the log is a representation of the 'unit' and is intended to be the same for\n\t* logs created with objects from the same constructor, which facilitates filtering logs for a\n\t* given class\n\t*\n\t* @return string\n\t*/\n\tBetterLog.prototype.toString=function(){\n\t\tswitch(BetterLog.varType(this.unit)){\n\t\t\tcase 'string':\n\t\t\t\treturn this.unit;\n\t\t\tcase 'object':\n\t\t\t\treturn this.unit.constructor.name;\n\t\t\tcase 'function':\n\t\t\t\treturn this.unit.name;\n\t\t\tdefault:\n\t\t\t\treturn 'BetterLog';\n\t\t}\n\n\t}\n\n\n\t/*\n\t* Set the name of this instance. Used by the constructor but can also be used later. Useful eg. if you change\n\t* the constructor of a unit etc. \n\t*\n\t* NOTE: This doesn't prevent the old name to or unit from being used to access this instance, instead an alias\n\t*\t\tis created on Binder._instances\n\t*\n\t* @opt string name \tDefaults to this.toString()\n\t*\n\t* @return string \tThe name set after this operation\n\t*/\n\tBetterLog.prototype.changeName=function(name){\n\t\tname=(typeof name=='string'?name:'')||this.toString();\n\t\tif(name!==this.unit && name!==this.name){\n\t\t\tvar base=name,i=0;\n\t\t\twhile(BetterLog._instances.has(name)){\n\t\t\t\ti++\n\t\t\t\tname=base+i;\n\t\t\t}\n\t\t\tBetterLog._instances.aliases.set(name,this.unit)\n\t\t\t//The reason we use aliases^ instead of a second seperate map is so that you can \n\t\t\t//call BetterLog._instances.get(...) with both name and unit. And the reason we\n\t\t\t//don't use a single map is because that would affect .size() and .forEach()\n\t\t}\n\t\tthis.name=name;\n\t}\n\n\tObject.defineProperty(BetterLog,'defaultOptions',{enumerable:true,value:{}})\n\tObject.defineProperties(BetterLog.defaultOptions,{\n\t\tget:{enumerable:true, value:function getDefaultOptions(){return JSON.parse(JSON.stringify(defaultOptions));}}\n\t\t\n\t\t/*\n\t\t* Change default options (which apply as defaults for every instance setup after this is called)\n\t\t*\n\t\t* @param object options\n\t\t* @opt boolean override \tDefault false. If true all previously setup instances will have their options overridden\n\t\t*\n\t\t* @return void\n\t\t*/\n\t\t,set:{enumerable:true, value:function setDefaultOptions(options, override=false){\n\t\t\tif(typeof options !='object'){\n\t\t\t\tthrow new TypeError('Expected object, got: ('+typeof options+')'+String(options));\n\t\t\t}\n\t\t\t\n\t\t\t//env is not a regular options because it needs to be the same even for instances loaded before this method\n\t\t\t//is called... so an ugly hack/backwards compatible is to do this...\n\t\t\tif(options.hasOwnProperty('env')){\n\t\t\t\tBetterLog._env=options.env;\n\t\t\t\tdelete options.env;\n\t\t\t}\n\n\t\t\t//Change the class-wide private variable...\n\t\t\tObject.assign(defaultOptions,options);\n\n\t\t\t//If opted, override options set on all previously setup logs...\n\t\t\tif(override){\n\t\t\t\tBetterLog._instances.forEach(log=>Object.assign(log.options,options));\n\t\t\t}else{\n\t\t\t\t//Else always change the already setup syslog's options (since we know it wasn't setup with any custom options)\n\t\t\t\tObject.assign(BetterLog._syslog.options,options);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}}\n\n\t})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/********************** Create entries *******************************/\n\n\n\n\n\n\t/*\n\t* Create <BLE> without printing or storing anything\n\t* @return <BLE>\n\t*/\n\tBetterLog.prototype.makeEntry=function(lvl,msg,...extra){\n\n\t\t//Get a lvl number (and deal with people forgetting lvl altogether)\n\t\tvar logLvl=getLogLvl(lvl,'a');\n\t\tif(logLvl=='a'){\n\t\t\tif(msg!=undefined)\n\t\t\t\textra.unshift(msg);\n\t\t\tmsg=lvl;\n\t\t\tlvl=3;\n\t\t}\n\n\t\t//If msg is a BLE, just...\n\t\tif(BetterLogEntry._isBLE(msg)){\n\t\t\t//...change lvl, log and add extras....\n\t\t\tmsg.lvl=logLvl;\n\t\t\tmsg.log=this;\n\t\t\tif(extra.length){\n\t\t\t\tmsg.extra=msg.extra.concat(extra);\n\n\t\t\t\t//Since we've added stuff, the whole thing is no longer printed... However this\n\t\t\t\t//will cause re-print of previously printed stuff, so try to avoid adding extras\n\t\t\t\t//this way\n\t\t\t\tmsg.printed=false;\n\t\t\t}\n\t\t\treturn msg;\n\n\t\t}else if(msg instanceof Error){\n\t\t\tif(msg instanceof SyntaxError){\n\t\t\t\tvar description='',arr=msg.stack.split(/\\r\\n|\\r|\\n/),i,l=arr.length;\n\t\t\t\tfor(i=1;i<l;i++){\n\t\t\t\t\tif(arr[i].match('SyntaxError: '))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdescription+='\\n'+arr[i] //if we put \\n after we get correct newlines, but we get problems with indents... try it...\n\t\t\t\t}\n\t\t\t\textra.unshift(description);\n\t\t\t}\n\t\t\t\t\n\t\t\tvar entry=new BetterLogEntry(this,lvl,msg.message,extra,msg.stack);\t\n\t\t\tif(msg.code)\n\t\t\t\tentry.setCode(msg.code);\n\t\t\telse if(msg.name!='Error')\n\t\t\t\tentry.setCode(msg.name);\n\t\t\t\n\t\t\treturn entry;\n\n\t\t//If we have a former JSON str, turn back into entry. \n\t\t}else if(isJsonBLE(msg)){\n\t\t\t// console.log('BLE json about to be converted:',msg);\n\t\t\tvar entry=new BetterLogEntry(this,lvl,msg.msg,msg.extra.concat(msg.bubble,extra),msg.stack);\n\t\t\t\t//^by adding bubble to extra array it automatically gets passed back to this function by BLE constructor\n\t\t\t\n\t\t\t//Set props that can't be passed to constructor\n\t\t\tentry.code=msg.code;\n\t\t\tentry.timestamp=msg.timestamp\n\t\t\tentry.handling=msg.handling\n\t\t\tentry.printed=extra.length?false:msg.printed //like above, if we've added to extra, reset print\n\n\t\t\treturn entry;\n\n\t\t} else {\n\t\t\t//...else create a new one\n\t\t\treturn new BetterLogEntry(this,lvl,msg,extra);\n\t\t}\n\t}\n\t\n\tBetterLog.prototype.makeEntryRaw=function(lvl,msg,extra,stack){\n\t\treturn new BetterLogEntry(this,lvl,msg,extra,stack);\n\t}\t\t\n\n\t/*\n\t* @see makeEntry('error',...)\n\t* @return <BLE Error>\n\t*/\n\tBetterLog.prototype.makeError=function(...args){\n\t\targs.unshift(6); //lvl 6==error\n\t\treturn this.makeEntry.apply(this,args);\n\t}\n\n\n\n\n\t/*\n\t* Creates an entry that will print (but doesn't here) like:\n\t*   [ appSocket.uniSoc.] - TRACE - receiveSmarty( (number)742354341 ) from args.callback (uniSoc3.common.js:1247:19) @ uniSoc3.common.js:1278:11.\n\t*\n\t* @param object|array args \t \tThe arguments object or an array of args\n\t* @param @opt string funcOrMsg  If it doesn't contain spaces it's used instead of entry.func at start of msg, else \n\t*\t\t\t\t\t\t\t   \t  it's appeneded to the end of the msg\n\t* @param @opt number logLvl \tDefault 1=trace\n\t*\n\t* @return <BLE>\n\t* @no_print\n\t*/\n\tBetterLog.prototype.makeTrace=function(args, funcOrMsg,logLvl=1){\n\t\t\n\t\t//Make sure we have a number\n\t\tlogLvl=getLogLvl(logLvl);\n\n\t\t//Allow legacy, ie. reverse order of arguments...\n\t\tif(typeof args=='string'){\n\t\t\tvar a=args;\n\t\t\targs=funcOrMsg;\n\t\t\tfuncOrMsg=a;\n\t\t}\n\n\t\tvar logStr;\n\t\tif(typeof args!='object'){ //includes array, arguments-object and null\n\t\t\tlogStr='( ? )'\n\t\t}else{\n\t\t\t//Turn the args array into a string that can be logged/stored without worrying\n\t\t\t//that it'll take up space or change later\n\t\t\targs=Object.values(args).map(arg=>logVar(arg,40));\n\t\t\tvar argStr=args.length==0 ? ' void ' :args.join(' , '); \n\t\t\tlogStr=`( ${argStr} )`;\n\t\t}\n\t\t\t\n\t\t//Then just like with regular logging, create the this...\n\t\tvar entry=this.makeEntry(logLvl,logStr,undefined);\n\n\t\t//...but modify it a bit before proceeding\n\t\tif(funcOrMsg && typeof funcOrMsg=='string'){\n\t\t\t//If arg #2 contains spaces, it's a message, else a func name\n\t\t\tif(funcOrMsg.includes(' ')){\n\t\t\t\tentry.extra.push(funcOrMsg);\n\t\t\t}else{\n\t\t\t\tentry.func=funcOrMsg;\n\t\t\t\tentry._options.printFunc=true;\n\t\t\t}\n\t\t}\n\n\t\tentry.addFrom();\n\n\t\treturn entry;\n\t}\n\n\n\n\t/*\n\t* Create an error with code 'TypeError'. Handles differently for terminal and browser.\n\t*\n\t* @param string|array|object|function expected \tGets turned into a string and goes after 'Expected ' in the msg\n\t*\n\t* @return <ble TypeError>\n\t* @no_print\n\t*/\n\tBetterLog.prototype.makeTypeError=function(expected,...got){\n\t\tswitch(varType(expected)){\n\t\t\tcase 'array':\n\t\t\t\texpected=expected.join('|');\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\texpected='instanceof '+expected.constructor.name;\n\t\t\t\tbreak;\n\t\t\tcase 'function':\n\t\t\t\texpected='instanceof '+expected.name;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texpected='(bugbug)'+String(expected); //this should not happen, but best effort...\n\t\t}\n\t\treturn this.makeError(`Expected ${expected}, got: `).addExtra(...got).setCode('TypeError');\n\t\t// let msg=`Expected ${expected}, got: `;\n\t\t// if(BetterLog._env=='terminal'){\n\t\t// \tvar all=[msg].concat(got.map(arg=>logVar(arg,100)));\n\t\t// }else{\n\t\t// \tall=[msg].concat(got);\n\t\t// }\n\t\t// console.warn(BetterLog._env,all);\n\t\t// return this.makeError.apply(this,all).setCode('TypeError');\n\t}\n\n\n\n\t/*\n\t* Create a BLE with a code previously stored on this instance (or the default ones defined on \n\t* this constructor. Message will be code description if any. \n\t*\n\t* @throws <BLE>\n\t* @return n/a\n\t* @not_printed\n\t*/\n\tBetterLog.prototype.makeCodeError=function(code, details){\n\t\tvar desc='';\n\t\tif(this.codes && this.codes[code])\n\t\t\tdesc=this.codes[code]\n\t\t\n\t\treturn this.makeError(desc).setCode(code).append(details);\n\t}\n\n\n\n\n\n\n//---------------------- ^^ Create entries ^^ ---------------------------/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n/****Rudimentry event emitter, used to emit log entries****/\n\n\t/*\n\t* Emit an entry\n\t* @return void\n\t*/\n\tBetterLog.prototype.emit=function(entry){\n\t\ttry{\n\t\t\t//Quick check to see if there's anyone to emit to\n\t\t\tif(!this._listeners.length)\n\t\t\t\treturn;\n\n\t\t\t//Emit to the last added first, that way we can add handlers later to preempt earlier logging (good\n\t\t\t//if we want to add extra detail to something at a later stage, and don't want duplicates because of it)\n\t\t\tvar i=this._listeners.length-1\n\t\t\tfor (i; i >= 0; i--) {\n\t\t\t\tif(!this._listeners[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tvar [cb,low,high]=this._listeners[i];\n\t\t\t\t//Ignore if outside lvl span\n\t\t\t\tif(entry.lvl<low || entry.lvl>high)\n\t\t\t\t\treturn;\n\n\t\t\t\ttry{\n\t\t\t\t\tcb(entry)\n\t\t\t\t}catch(err){\n\t\t\t\t\tconsole.error(`Uncaught error in BetterLog listener ${i}:`,err,cb,entry)\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(err){\n\t\t\tconsole.error(`BUGBUG BetterLog.emit():`,err,entry);\n\t\t}\n\t}\n\t\n\t/*\n\t* Add a listener\n\t* @return number \tThe id of the listener, in case we want to remove it later\n\t*/\n\tBetterLog.prototype.listen=function(callback,lowestLvl=1,highestLvl=6){\n\t\tif(typeof callback!='function')\n\t\t\tcallback=BetterLog.prototype.print;\n\n\t\treturn this._listeners.push([callback,getLogLvl(lowestLvl,1),getLogLvl(highestLvl,6)])-1;\n\t}\n\n\t/*\n\t* Remove a listener\n\t* @return void\n\t*/\n\tBetterLog.prototype.ignore=function(id){\n\t\tif(this._listeners.hasOwnProperty(id))\n\t\t\tdelete this._listeners[id]; //NOTE: delete, don't splice, so that id of others don't change\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Add entries from another log to the current one, emitting again...\n\t*\n\t* @param <BetterLog> anotherLog \tAnother instance of BetterLog\n\t*\n\t* @return void\n\t*/\n\tBetterLog.prototype.extend=function(anotherLog){\n\t\tif(!BetterLog._isLog(anotherLog)||anotherLog===this)\n\t\t\tthrow new TypeError(\"Expected another instance of BetterLog, got: \"+logVar(anotherLog));\n\n\t\tvar self=this;\n\t\tanotherLog.listen(function extend(entry){\n\t\t\t// console.warn(\"EXTENDING LOG ENTRY:\",entry,this,self)\n\t\t\tself.entries.push(entry);\n\t\t\tself.emit(entry);\n\t\t})\n\t\t// console.warn(\"AAAAAAAA LISTENING\",this,anotherLog);\n\t\treturn;\n\t}\n\n\n\t/*\n\t* Move all entries from this log to another, changing the log-reg on them, then removing this log from _instances\n\t*\n\t* NOTE: this will NOT re-emit anything, simply move the entries over\n\t*\n\t* @param <BetterLog> anotherLog \tAnother instance of BetterLog\n\t*\n\t* @return @anotherLog \t\t\t\tThe passed in log, to enable one-liners:  obj.log=obj.log.replace(newLog)\n\t*/\n\tBetterLog.prototype.replace=function(anotherLog){\n\t\tif(!BetterLog._isLog(anotherLog)||anotherLog===this)\n\t\t\tthrow new TypeError(\"Expected another instance of BetterLog, got: \"+logVar(anotherLog));\n\n\t\tthis.note(\"This log will be replaced by: \",anotherLog.name);\n\n\t\tvar i=0;l=this.entries.length;\n\t\tanotherLog.debug(`Replacing log '${this.name}'. Grabing it's ${l} entries.`);\n\t\tfor (i;i<l;i++) {\n\t\t\tanotherLog.entries.push(this.entries[i]);\n\t\t}\n\t\t\n\t\tBetterLog._instances.delete(this.unit);\n\n\t\treturn anotherLog;\n\t}\n\n\n\n\n\n\t/*\n\t* Reset the startTime used by options.printMs\n\t* @return void\n\t*/\n\tBetterLog.prototype.resetStartTime=function(){\n\t\tstartTime=Date.now();\n\t}\n\n\n\t/*\n\t* Get entries from a specific unit or the syslog (can be called on or outside instance)\n\t*\n\t* @param string|number  lowestLvl \tLowest level to include\n\t* @param object \t\tunit \t\tLog to get from. Null=>syslog. Default this log\n\t* \n\t* @return array \t\t\t\t\tA subset of the syslog array\n\t*/\n\tBetterLog.prototype.get=function(lowestLvl=1,unit){ \n\t\tlowestLvl = getLogLvl(lowestLvl,1);\n\t\t\n\t\t//If no unit is specified and we're calling this on an instance => only look at entries \n\t\t//from the instance itself\n\t\tvar entries;\n\t\tif(unit){\n\t\t\tlet log=BetterLog._instances.get(unit);\n\t\t\tif(!log){\n\t\t\t\tconsole.warn(\"No such BetterLog unit setup:\",unit);\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tentries=log.entries;\n\t\t}else if(unit===null || !(BetterLog._isLog(this)))  \n\t\t\tentries=BetterLog._syslog.entries;\n\t\telse\n\t\t\tentries=this.entries; //default, if nothing is specified\n\n\t\treturn entries.filter(entry=>entry.lvl>=lowestLvl); \n\t}\n\n\n\t/*\n\t* Find entries in any log\n\t*\n\t* @param object criteria \tAcceptable keys and their values: \n\t*\t\t\t\t\t\t\t\tlowestLvl - number\n\t*\t\t\t\t\t\t\t\tunit - string\n\t*\t\t\t\t\t\t\t\tprinted - boolean\n\t*\t\t\t\t\t\t\t\tid - number(from)|array[from,to]\n\t*\t\t\t\t\t\t\t\ttimestamp - number(from)|array[from,to]\n\t*\t\t\t\t\t\t\t\trocks - boolean|number (true or id, get the rocks from entries found so far)\n\t*\t\t\t\t\t\t\t\tmatch - string|regexp\n\t*\n\t* @return array|false\n\t*/\n\tBetterLog.prototype.find=function(criteria={}){\n\t\tvar entries=this.get(criteria.lowestLvl||1, criteria.unit); \n\t\tif(!entries.length)\n\t\t\treturn [];\n\n\t\t\n\n\t\tif(criteria.hasOwnProperty('printed'))\n\t\t\tentries.filter(entry=>entry.printed==criteria.printed);\n\t\tif(!entries.length)\n\t\t\treturn [];\n\n\t\tif(typeof criteria.rocks=='number')\n\t\t\tcriteria.id=[criteria.rocks, criteria.rocks];\n\n\t\tArray('id','timestamp').forEach(p=>{\n\t\t\tif(criteria[p]){\n\t\t\t\tif(Array.isArray(criteria[p]))\n\t\t\t\t\tentries=entries.filter(entry=>entry[p]>=criteria[p][0] && entry[p]<=criteria[p][1]);\n\t\t\t\telse{\n\t\t\t\t\tentries=entries.filter(entry=>entry[p]>=criteria[p]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!entries.length)\n\t\t\t\t\treturn [];\n\t\t\t}\n\t\t})\n\n\n\t\t//Only get entries that have no more rocks, ie. probably the errors that have been logged, dropping\n\t\t//all their bubbles\n\t\tif(criteria.rocks){\n\t\t\tvar getRocks=(entry)=>{\n\t\t\t    var arr=[entry];\n\t\t\t\tif(entry._rocks.length){\n\t\t\t    \t// console.log('looping through',entry._rocks.length,entry)\n\t\t\t\t    entry._rocks.forEach(rock=>{\n\t\t\t            arr.push.apply(arr,getRocks(rock))\n\t\t\t\t    })\n\t\t\t\t}\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tlet entries2=[];\n\t\t\tentries.forEach(entry=>entries2.push.apply(entries2,getRocks(entry)));\n\t\t\tentries=entries2.filter(entry=>entry._rocks.length==0);\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\tif(criteria.match){\n\t\t\tentries=entries.filter(entry=>{\n\t\t\t\ttry{\n\t\t\t\t\treturn entry.msg.match(criteria.match);\n\t\t\t\t}catch(err){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\n\t/*\n\t* Print the whole log (or syslog if called not-on-instance)\n\t* \n\t* @return void\n\t*/\n\tBetterLog.prototype.dump=function(options={},criteria=undefined){\n\t\t//Set some default options, letting passed in ones overrule...\n\t\toptions=Object.assign({\n\t\t\tprintMs:false //printing ms will give negative numbers if startTime has been reset, so just turn it off\n\t\t},options);\n\t\t\n\t\tvar entries=(typeof criteria=='object' ? this.find(criteria) : this.get());\n\t\tif(!entries.length)\n\t\t\tconsole.log(\"No matching entries found.\");\n\t\telse\n\t\t\tentries.forEach(entry=>{entry.printed=false; entry.print(options)});\n\t\treturn;\t\t\n\t}\n\n\n\t/*\n\t* Get the last entry from this log\n\t* @return <BLE>\n\t*/\n\tBetterLog.prototype.last=function(){\n\t\treturn this.entries[this.entries.length-1];\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Utility function, gives more descriptive type of variable\n\t*\n\t* @return string\n\t*/\n\tfunction varType(v){\n\t\tif(typeof v === 'object'){\n\t\t\tif(v==null){\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tswitch(v.constructor.name){\n\t\t\t\tcase 'Object':\n\t\t\t\t\treturn 'object';\n\t\t\t\tcase 'Array':\n\t\t\t\t\treturn 'array';\n\t\t\t}\n\t\t\tif(BetterLogEntry._isBLE(v)){ //adding this since BLEs now ARE an instanceof Error\n\t\t\t\treturn 'ble'\n\t\t\t} \t\t\t\t\t   \n\t\t\tif(v instanceof Error){\n\t\t\t\treturn 'error';\n\t\t\t}\n\t\t\tif(v instanceof Promise){\n\t\t\t\treturn 'promise';\n\t\t\t} \n\t\t\tvar name = Object.prototype.toString.call(v)\n\t\t\tif (name === '[object HTMLCollection]' || name ==='[object NodeList]'){\n\t\t\t\treturn 'nodelist'\n\t\t\t}else if(name.includes('[object HTML') || name.includes('[object SVG')){\n\t\t\t\treturn 'node'\n\t\t\t}else{\n\t\t\t\treturn 'object';\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\treturn typeof v\n\t\t}\n\t}\n\n\t/*\n\t* Turn any variable into a log:able string\n\t* \n\t* @return string \t\n\t*/\n\tfunction logVar(v,maxLength=300,...optional){\n\t\tif(optional.length==1 && typeof optional[0]=='number'){\n\t\t\tvar total=optional[0]\n\t\t}\n\t\tvar noType=total||optional.includes('noType');\n\t\tvar type=BetterLog.varType(v);\n\t\tvar printType=type;\n\t\tswitch(type){ \n\t\t\tcase 'undefined':\n\t\t\tcase 'null':\n\t\t\t\treturn '<'+printType+'>';\n\t\t\tcase 'ble':\n\t\t\t\treturn `<(ble)${v.toString()}>`;\n\t\t\tcase 'error':\n\t\t\t\treturn `<${v.constructor.name}:${v.message}>`;\n\n\t\t\tcase 'object':\n\t\t\t\t//\"regular\" objects like {foo:'bar'}, leave type as 'object' and stringify value\n\t\t\t\tif(v.constructor.name=='Object'){\n\t\t\t\t\t// console.log('a')\n\t\t\t\t\tv=makeJsonLikeString(v,maxLength,type,total);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(isJsonBLE(v)){\n\t\t\t\t\t// console.log('b')\n\t\t\t\t\treturn `<(ble)${BetterLog._syslog.makeEntry(v.lvl, v).toString()}>`;\n\t\t\t\t}\n\n\t\t\t\t//all other objects, set their types to the constructor, and their values \n\t\t\t\t//either custom toString() method or stringify like ^^\n\t\t\t\tprintType='<'+v.constructor.name+'>'\n\t\t\t\tvar x=String(v),y=Object.prototype.toString.call(v)\n\t\t\t\tif(y!=x){\n\t\t\t\t\t// console.log('c')\n\t\t\t\t\tv=x; //custom toString()\n\t\t\t\t\t//since ^ may have returned a too long string, and 'object' doesn't normally get handled shortened vv,\n\t\t\t\t\t//we change 'type'...\n\t\t\t\t\ttype='pleaseshortenmyobject';\n\t\t\t\t}else if(total){\n\t\t\t\t\t// console.log('d')\n\t\t\t\t\treturn printType;\n\t\t\t\t}else{\n\t\t\t\t\t// console.log('e')\n\t\t\t\t\tv=makeJsonLikeString(v,maxLength,type,total);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\n\t\t\tcase 'array':\n\t\t\t\t// console.log('going to make array to string length',maxLength)\n\t\t\t\tv=makeJsonLikeString(v,maxLength,type,total);\n\t\t\t\tbreak;\n\n\t\t\tcase 'function':\n\t\t\t\tvar fnStr=String(v)\n\t\t\t\tv=fnStr.slice(0, fnStr.indexOf(')')+1);\n\t\t\t\tif(v.indexOf('function')>-1){\n\t\t\t\t\tv+='{}';\n\t\t\t\t\tif(maxLength=='x')\n\t\t\t\t\t\treturn v;\n\t\t\t\t\tv=v.replace('function ','');\n\t\t\t\t}else\n\t\t\t\t\tv+='=>{}';\n\t\t\t\tbreak;\n\t\t\tcase 'node':\n\t\t\t\tlet id=v.id?'#'+v.id:''\n\t\t\t\tlet cls=v.classList.length?'.'+v.classList.toString().replace(' ','.'):'';\n\t\t\t\tv=v.tagName.toLowerCase()+id+cls\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\t\tv=`\"${v}\"`;\n\t\t\t\tbreak;\n\t\t\tcase 'promise':\n\t\t\tdefault:\n\t\t\t\tv=String(v);\n\t\t\t\n\t\t}\n\t\t//At this point we have a string...\n\n\n\t\t//Handle too long\n\t\tif(maxLength&&v.length>maxLength &&type!='object'&&type!='array'){\n\t\t\tlet m=v.match(/([\\}\\]\\)\"])$/);\n\t\t\tv=v.slice(0,maxLength)+'...';\n\t\t\tif(m)\n\t\t\t\tv+=m[1]\n\t\t}\n\n\t\tif(noType)\n\t\t\treturn v\n\n\t\treturn '('+printType+')'+v;\n\t}\n\t\n\n\n\n\n\t/*\n\t* Turn any var into a JSON-like string (BUT CANNOT BE PARSED TO OBJECT) that shows as much as\n\t* possible of the first level of an object\n\t*\n\t* NOTE: The maxLength can/will be exceeded by a little...\n\t*\n\t* @param object|array  \tobj\n\t* @return string \t\t\t\tJSON-like string (BUT CANNOT BE PARSED TO OBJECT), or '<err:message>'\n\t*/\n\tfunction makeJsonLikeString(obj,maxLength,type,total=0){\n\n\t\t//So we don't loop unecessarily or waste time on super short ones... but if any errors happen\n\t\t//while trying to save time, just proceed to the loooong way of doing it...\n\t\ttry{\n\t\t\tvar str;\n\t\t\tif(total){\n\t\t\t\tif(total>(maxLength*5)){\n\t\t\t\t\treturn String(obj); //just make sure we have something to write after a key...\n\t\t\t\t}else if(total>maxLength*3){\n\t\t\t\t\treturn JSON.stringify(obj); //ignore hidden stuff or method\n\t\t\t\t}\n\t\t\t}else if(maxLength<51){\n\t\t\t\t\tstr=JSON.stringify(obj);\n\t\t\t\t\treturn str.substr(0,maxLength-4)+'...'+str.substr(-1);\n\t\t\t}\n\t\t}catch(err){\n\t\t\t//see ^\n\t\t}\n\t\t\n\t\ttry{\t\t\n\t\t\ttotal++ //so that total is always >0 after the first time we've called this\n\n\t\t\t//If it contains any methods, they won't show up with stringify(), neither will non-enumerable props,\n\t\t\t//so we manually loop everything in the first level and stringify it, setting it or any errors on a \n\t\t\t//temp object...\n\t\t\tvar keys=Object.getOwnPropertyNames(obj);\n\t\t\tif(type=='array')\n\t\t\t\tkeys.splice(keys.indexOf('length'),1)//ignore the 'length' prop on arrays\n\t\t\tvar temp={},over=[],extra=0,i=0,l=keys.length,even=Math.floor(maxLength/l);\n\t\t\tfor(i;i<l;i++){\n\t\t\t\tlet key=keys[i];\n\t\t\t\ttry{\n\t\t\t\t\tstr=logVar(obj[key],maxLength,total);\n\t\t\t\t}catch(err){\n\t\t\t\t\tstr=`<err:${err.message}>`\n\t\t\t\t}\n\t\t\t\ttemp[key]=str;\n\t\t\t\tlet sl=str.length\n\t\t\t\ttotal+=sl\n\t\t\t\tif(sl<even)\n\t\t\t\t\textra+=(even-sl)\n\t\t\t\telse\n\t\t\t\t\tover.push(key); //these props will be shortened or ignored\n\t\t\t}\n\n\t\t\t//Now shorten each item that exceeds the 'even' if we've exceeded the maximum\n\t\t\tif(type=='object'){\n\t\t\t\tlet kl=keys.join('').length; //object keys will obviously take up space too\n\t\t\t\ttotal+=kl\n\t\t\t\textra=Math.max(extra-kl,0);\n\t\t\t}\n\n\t\t\tif(total>maxLength){\n\t\t\t\t//Redestribute the extra (could be a lot if lots of props just have a single word/number). Since a bunch of tiny \n\t\t\t\t//strings doesn't give us much info, only shorten the first 6\n\t\t\t\tvar rest=over.splice(5,over.length);\n\t\t\t\tif(rest.length){\n\t\t\t\t\tkeys=keys.filter(key=>rest.includes(key)==false);\n\t\t\t\t\teven=Math.floor(maxLength/over.length);\n\t\t\t\t}else{\n\t\t\t\t\trest=undefined;\n\t\t\t\t}\n\t\t\t\teven+=Math.floor(extra/over.length);\n\t\t\t\tover.forEach((key,i)=>{\n\t\t\t\t\tif(temp[key].length>even){\n\t\t\t\t\t\tlet short=temp[key].substr(0,even-3)+'...'+temp[key].substr(-1); //just assume the last char is } ] \"\n\t\t\t\t\t\t// console.log(i,key,temp[key].length,' --> ',short.length)\n\t\t\t\t\t\ttemp[key]=short;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tvar add=(key)=>{\n\t\t\t\tif(!obj.propertyIsEnumerable(key))\n\t\t\t\t\tstr+='*'\n\t\t\t\tstr+=`${key}:${temp[key]}, `;\n\t\t\t}\n\t\t\t//Now build a JSON-like string from the parts\n\t\t\tif(type=='array'){\n\t\t\t\tstr='[';\n\t\t\t\tkeys.forEach(key=>{\n\t\t\t\t\tif(!isNaN(Number(key))){\n\t\t\t\t\t\tstr+=temp[key]+', '\n\t\t\t\t\t}else{ \n\t\t\t\t\t\tadd(key)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}else{\n\t\t\t\tstr='{';\n\t\t\t\tkeys.forEach(key=>add(key))\n\t\t\t}\n\t\t\t\n\t\t\tif(rest)\n\t\t\t\tstr+=`<${rest.length} more>`\n\t\t\telse\n\t\t\t\tstr=str.replace(/, $/,'');\n\n\t\t\tstr+=(type=='array' ? ']' : '}');\n\n\t\t\treturn str;\n\n\t\t}catch(err){\n\t\t\ttry{\n\t\t\t\tconsole.warn(err);\n\t\t\t\tconsole.verbose(obj);\n\t\t\t\tstr=JSON.stringify(obj);\n\t\t\t\treturn str.substr(0,maxLength-4)+'...'+str.substr(-1);\n\t\t\t}catch(err){\n\t\t\t\treturn `<err:${err.message}. See console.verbose^>`\n\t\t\t}\n\t\t}\n\t}\n\n    \n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* @param <Error>|undefined errOrStack\t\tAn error who's stack to use, else one will be generated here\n\t*\n\t* @return object{where:string, func:string, stack:array}\n\t*/\n\tBetterLog.prototype.getStackArray=function(errOrStack){\n\t\tvar stackArr,stackStr;\n\t\tlet nostack='[original stack lost]';\n\t\tif(Array.isArray(errOrStack) && typeof errOrStack[0]=='object'){\n\t\t\t//We assume that an array passed in has already gone through this process...\n\t\t\tstackArr=errOrStack;\n\t\t\tif(errOrStack.original==nostack)\n\t\t\t\tstackStr='[original stack lost by parent]'\n\t\t\telse\n\t\t\t\tstackStr=errOrStack.original||'[BUGBUG: prop \"original\" not set on pre-processed stack array]';\n\n\t\t}else{\n\t\t\tif(typeof errOrStack=='string')\n\t\t\t\tstackStr=errOrStack\n\t\t\telse if(errOrStack instanceof Error)\n\t\t\t\tstackStr=errOrStack.stack\n\t\t\telse\n\t\t\t\tstackStr=Error().stack;\n\n// var a;\n\t\t\t//SyntaxError and ReferenceError are different...\n\t\t\tif(stackStr.match('SyntaxError: ')){\n\t\t\t\treturn handleSyntaxErrorStack(stackStr);\n\t\t\t}else if(stackStr.match('ReferenceError: ')){\n// a=true\n\t\t\t\tstackArr=handleReferenceErrorStack(stackStr);\n\t\t\t}else{\n\t\t\t\t//Now we either have an array or a string, the later must become the former\n\t\t\t\tstackArr = splitStackString(stackStr);\n\t\t\t}\n\t\t// console.log(stackArr);\n\t\t\t\n\t\t\t//Turn strings into array of objects\n\t\t\tstackArr=stackArr.map(parseStackLine)\n\n// if(a)console.log('BEFORE:',stackArr);\n\t\t\t//Now handel depending on env. The first (only) job here is to remove references to this file\n\t\t\tif(BetterLog._env=='terminal'){\n\t\t\t\tstackArr=stackArr.filter(obj=>obj.where.includes(__filename)==false)\n// if(a)console.log('AFTER FIRST FILTER:',stackArr);\n\t\t\t\t//Optionally remove stack entries that refer to internal modules and have little informative\n\t\t\t\t//value to a developer of other modules\n\t\t\t\tif(this.options.hideInternalStack){\n\t\t\t\t\tstackArr=stackArr.filter((obj,i)=>{\n\t\t\t\t\t\t//always keep first line of stack\n\t\t\t\t\t\tif(i===0)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tif(obj.where.includes('internal/modules'))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\tif(obj.where.indexOf('vm.js:')==0)\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\tif(obj.where.indexOf('module.js:')==0)\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\tif(obj.where.includes('bootstrap_node.js:'))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t})\n\t\t\t\t}\n// if(a)console.log('AFTER SECOND FILTER:',stackArr);\n\t\t\t\t//Now either use filename only or replace rootPath\n\t\t\t\tif(this.options.fileOnly)\n\t\t\t\t\tstackArr.forEach(line=>line.where=line.where.slice(line.where.lastIndexOf('/')+1))\n\t\t\t\telse\n\t\t\t\t\tstackArr.forEach(line=>line.where.replace(this.options.rootPath,'.'))\n\n\t\t\t}else{\n\t\t\t\t//If a simpleSourceMap exists, apply it\n\t\t\t\tif(BetterLog._sourceMap.length){\n\t\t\t\t\tstackArr.forEach(obj=>obj.where=BetterLog._sourceMap.lookup(obj.where,true)||obj.where);\n\t\t\t\t}\n\t\t\t\tif(this.options.hideThisFileStack){\n\t\t\t\t\tremoveTopLinesFromThisFile.call(this,stackArr);\n\t\t\t\t}else{\n\t\t\t\t\tstackArr=stackArr(stackArr).filter(obj=>obj.func.includes('BetterLog'))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for debug purposes, save the original stack. (NOTE: if you change here, also change in handleSyntaxErrorStack())\n\t\tObject.defineProperty(stackArr,'original',{value:stackStr||nostack});\n\n\t\t//Always make sure there is at least on one item in stack, that way we don't have to worry about errors\n\t\tif(!stackArr.length)\n\t\t\tstackArr.push({'empty':true})\n\n\t\treturn stackArr\n\t}\n\t\n\t/*\n\t* NOTE: The returned array from this method DOES NOT get further processed by getStackArray(), as such\n\t*\t\twe add the same 'original' prop to it like would otherwise have been done by ^\n\t*\n\t* @return array[object]\n\t*/\n\tfunction handleSyntaxErrorStack(str){\n\t\tvar stackArr = str.split(/\\r\\n|\\r|\\n/)\n\t\tstackArr=[{func:'unknown', where:stackArr[0]}];\n\t\tObject.defineProperty(stackArr,'original',{value:str});\n\t\treturn stackArr;\n\t}\n\n\n\t/*\n\t* NOTE: The returned array from this method continues to be processed by getStackArray()\n\t*\n\t* @return array[string,...]\n\t*/\n\tfunction handleReferenceErrorStack(str){\n// console.log(str);\n\t\tvar arr = str.split(/\\r\\n|\\r|\\n/), stackArr;\n\n\t\t//The Reference stack can look in 2 ways:\n\t\t/*\n\t\t\t<FIRST LINE OF STACK>\n\t\t\t\t<the string that is the problem>\n\t\t\t\t\t<indication where the problem is ^^^^^>\n\n\t\t\tReferenceError: ......\n\t\t\t\tat <SECOND LINE OF STACK>\n\t\t\t\tat ...\n\t\t*/\n\t\t//  or\n\t\t/*\n\t\t\tReferenceError: ......\n\t\t\t\tat <FIRST LINE OF STACK>\n\t\t\t\tat ...\n\t\t*/\n\t\t//and in both cases we need all the lines, so check which one we have\n\t\tif(arr[0].substr(0,15)=='ReferenceError:'){\n\t\t\t//Just discard first line and return rest\n\t\t\tarr.shift(); \n// console.log('returning all but first line',arr)\n\t\t\treturn arr;\n\t\t\n\t\t}else{\n// console.log('FIRST',arr)\n\t\t\t\n\t\t\t//first line contains exact where\n\t\t\tstackArr=[arr.shift()]; \n// console.log('BEFORE',arr)\n\n\t\t\t//Then comes the garbadge lines...\n\t\t\twhile(true){\n\t\t\t\tlet line=arr.shift();\n\t\t\t\t// console.log('DISCARDING',line);\n\t\t\t\tif(line==undefined || line.includes('ReferenceError:')){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//TODO 2019-12-09: Use a regex to grab all '  at' lines instead...\n\t\t\t}\n// console.log('REMAINING',arr)\n\n\t\t\treturn stackArr.concat(arr);\n\t\t}\n\t}\n\n\n\t/*\n\t* @param string line\t\tA line single line from the stack which contains calling function, file, line\n\t*\n\t* @return object{where:string, func:string}\n\t* @no_throw\n\t*/\n\tfunction parseStackLine(line){\n\t\ttry{\n\t\t\tif(!line)\n\t\t\t\treturn {where:'unknown', func:'unknown'};\n\t\t\t\n\t\t\tline=line.replace(/^\\s*at /,'').trim();\n\n\t\t\tvar s=line.indexOf('(');\n\t\t\tvar w=line.substring(s+1);\n\n\n\t\t\treturn obj={\n\t\t\t\twhere:(w.substring(w.length-1)==')' ? w.substring(0,w.length-1) : w) //fileline\n\t\t\t\t,func:line.substring(0,s-1)//calling func\n\t\t\t}\n\n\t\t}catch(err){\n\t\t\treturn {where:'unknown', func:'unknown'};\n\t\t}\n\t}\n\n\tfunction splitStackString(stackStr){\n\t\treturn stackStr.split(/\\r\\n|\\r|\\n/) //Turn into array (windows and unix compatible)\n\t\t\t.slice(1) //first row just says 'Error'\n\t}\n\n\n\t/*\n\t* Remove the first lines from the stack that come from this same file. \n\t*\n\t* NOTE: This will remove too much if you've bundled all your scripts and \n\t*\t\thave not applied simpleSourceMaps\n\t*\n\t* @param array[object] stackArr\n\t* @return array \t\t\t\t\t\tAlters and returns live $stackArr\n\t* @call(<BetterLog>)\n\t*/\n\tfunction removeTopLinesFromThisFile(stackArr){\n\t\tif(typeof this.options.hideThisFileStack!='string'){\n\t\t\tlet stack=Error().stack\n\t\t\t\t,first=splitStackString(stack)[0]\n\t\t\t\t,where=parseStackLine(first).where\n\t\t\t\t,i=where.indexOf('.js:')\n\t\t\t;\n\t\t\tif(i==-1)\n\t\t\t\ti=where.indexOf('.js?:');\n\t\t\tif(i==-1){\n\t\t\t\tconsole.warn(\"Could not determine the first filename of this stack:\",stack);\n\t\t\t\treturn stackArr;\n\t\t\t}\n\t\t\tthis.options.hideThisFileStack=where.substr(0,i)+'.js';\n\t\t}\t\t\n\t\tvar i=0,l=stackArr.length;\n\t\tfor(i;i<l;i++){\n\t\t\tif(stackArr[i].where.indexOf(this.options.hideThisFileStack)!=0)\n\t\t\t\tbreak;\n\t\t}\n\t\tstackArr.splice(0,i);\n\t\treturn stackArr;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* @param string lvl \t\tA string describing the level at which to log\n\t* @param mixed message \t\tThe main logging content\n\t* @param array extra \t\tAs many additional variables as you like\n\t* @param object log \t\tThe log this entry belongs to, so we can find the log via the entry...\n\t*\n\t* @prop number id\n\t* @prop number|string code \tTry to use these where possible: \n\t*\t\t\t\thttps://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html\n\t* @prop number lvl\n\t* @prop string msg\n\t* @prop extra array\n\t* @prop <BLE>|null bubble\n\t* @prop number timestamp\n\t* @prop <BetterLog> log \tDefaults to syslog\n\t* @prop boolean printed\n\t* @prop array handling \t\tThink of these as 'notes' or 'steps' performed before the current entry was reached\n\t*\n\t* \n\t* @return object \t\t\tThe log entry\n\t* @access private\n\t*/\n\tfunction BetterLogEntry(log,lvl,msg,extra,stack){\n\t\tthis.id=null; //set by this.exec() which adds it to a log\n\t\tObject.defineProperties(this,{ //set by reject() or throw();\n\t\t\t_code:{enumerable:false,configurable:true,writable:true,value:null}\n\t\t\t,code:{enumerable:true,get:this.getCode.bind(this),set:this.setCode.bind(this)}\n\n\t\t\t,_options:{value:{}}\n\t\t\t,options:{enumerable:true,get:()=>Object.assign({},this.log.options,this._options),set:this.setOptions.bind(this)}\n\n\t\t\t,_isBetterLogEntry:{value:true}\n\t\t\t,_rocks:{value:[]} //inverted bubbles, so we can track...\n\t\t\t,_age:{get:()=>Date.now()-this.timestamp}\n\t\t})\n\t\tthis.lvl=getLogLvl(lvl,4); //Can be changed later manually before printing...\n\t\tthis.msg=msg; \n\t\tthis.extra=(Array.isArray(extra)?extra:(extra!=undefined?[extra]:[]));\n\t\t//NOTE: these 5 props ^^ are defined first so they show up first in Chrome DevTools when expanding entries in console...\n\n\t\tthis.timestamp=Date.now();\n\t\tthis.handling=[]; //call this.addHandling() will append this list. NOT for bubbling up.\n\t\tthis.log=(BetterLog._isLog(log) ? log : BetterLog._syslog);\n\t\tthis.setStack(stack); //sets 'stack', 'func' and 'where' on this entry\n\t\tthis.printed=false;\n\t\t\n\t\tthis.bubble=null;\n\t\tvar i;\n\t\tfor(i=0;i<this.extra.length;i++){\n\t\t\tlet x=this.extra[i]; \n\t\t\tif(typeof x=='object'){\n\t\t\t\tif(BetterLogEntry._isBLE(x)) {\n\t\t\t\t  //^we have to check for BLE before Error, since BLE is an error... that's why we have a little duplication\n\t\t\t\t  //of code vv\n\t\t\t\t\tthis.bubble=this.extra.splice(i,1)[0];\n\t\t\t\t\t// this.code=this.bubble.code; //code bubbles up as well //2019-11-05: see vv\n\t\t\t\t}else if(x instanceof Error || isJsonBLE(x)){\n\t\t\t\t\tthis.bubble=this.log.makeEntry(x.lvl||6,this.extra.splice(i,1)[0]);\n\t\t\t\t\t// this.code=this.bubble.code; //2019-11-05: Doesn't make sense to bubble, we can still get it with getCode()\n\t\t\t\t}\n\n\t\t\t\tif(this.bubble){\n\t\t\t\t\tthis.bubble._rocks.push(this); \t\t\t\n\t\t\t\t\tbreak; //we assume only a single Error or BLE is passed in\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t}//end of BetterLogEntry\n\tBetterLogEntry.prototype=Object.create(Error.prototype); \n\tObject.defineProperty(BetterLogEntry.prototype, 'constructor', {value: BetterLogEntry}); \n//2019-10-10: Trying to make BLE's pass for Errors so we can start using them as such... Right now checking in uniSoc\n//\t\t\t  if 'err instanceof Error'\n\tBetterLogEntry.prototype._isBLE=BetterLogEntry._isBLE=function(x){\n\t\tif(x && typeof x=='object' && x.constructor.name=='BetterLogEntry' && typeof x.changeWhere=='function'){\n\t\t\tif(x.log && !(x.log instanceof BetterLog)){\n\t\t\t\tBetterLog._syslog.warn(\"BetterLog has been exported at least twice:\",BetterLog._syslog, x.log.constructor._syslog)\n\t\t\t}\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t} \n\t}\n\n\n\t/*\n\t* Only certain things are suitable to turn into json string, get there here\n\t*\n\t* @return object\n\t*/\n\tBetterLogEntry.prototype.toJSON=function(){\n\t\tvar obj={\n\t\t\tlog:this.log.name\n\t\t\t,id:this.id\n\t\t\t,code:this.code\n\t\t\t,lvl:this.lvl\n\t\t\t,msg:this.msg\n\t\t\t,extra:this.extra\n\t\t\t,timestamp:this.timestamp\n\t\t\t,printed:this.printed\n\t\t\t,handling:this.handling\n\t\t\t,stack:this.stack\n\t\t\t,where:this.where\n\t\t\t,func:this.func\n\t\t\t,bubble:this.bubble?this.bubble.toJSON():null\n\t\t\t,__ble:true\n\t\t}\n\t\t// console.log('BLE json str:',JSON.stringify(obj));\n\t\treturn obj;\n\t}\n\n\n\tfunction isJsonBLE(obj){\n\t\treturn (obj && typeof obj=='object' && obj.__ble);\n\t}\n\n\n\t/*\n\t* @return string \tThe\tcode+message+extras of this entry (no where,bubble or handling) \n\t*/\n\tBetterLogEntry.prototype.toString=function(){\n\t\t//Start by grabbing the message and the extras\n\t\treturn addInfo([],null,this._code,this.msg,null,this.extra,this.options)\n\t\t\t.map(x=>logVar(x,300,'noType')).join(' ').replace('\\n',' ');\n\t}\n\n\n\t/*\n\t* @return string|number|null \tThe first code of this or any bubbled entry, or null\n\t*/\n\tBetterLogEntry.prototype.getCode=function(){\n\t\tvar self=this\n\t\twhile(self){\n\t\t\tif(self._code)\n\t\t\t\treturn self._code;\n\t\t\tself=self.bubble\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t* Set the code of this entry. Optionally only set it if none was set on bubbled err\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.setCode=function(code=null,onlyBackup=false){\n\t\tif(!onlyBackup || !this.getCode()){ //if the code isn't a backup, or if no code can be found on bubbles...\n\t\t\t//...then we're going to set the code now\n\t\t\tif(typeof code=='string' || typeof code=='number'){\n\t\t\t\tthis._code=code;\n\t\t\t}else{\n\t\t\t\tconsole.warn(\"BetterLogEntry.code can only be string or number, got:\",logVar(code));\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t/*\n\t* Assign options for this entry. \n\t* @param object options \n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.setOptions=function(options){\n\t\tif(options && typeof options=='object'){\n\t\t\tObject.assign(this._options,options);\n\t\t}else{\n\t\t\tconsole.warn(new TypeError(\"Cannot set options on BetterLogEntry. Expected object.\"),options);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/*\n\t* Add color options to entry, and set it to always be automatically printed\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.highlight=function(color,otherOptions=null,asLog=null){\n\t\n\t\t//Default to red\n\t\tcolor=(typeof color=='string' && highlightColor.hasOwnProperty(color)) ? color:'red'\n\t\t\n\n\t\t//Set options\n\t\tvar c=highlightColor[color];\n\t\tthis.setOptions({\n\t\t\tcolorTerm:String(`${c.colorTerm};${lvlLookup['note'].colorTerm}`)\n\t\t\t,colorBrow:`background:${c.colorBrow}` //NOTE: replaces default\n\t\t\t,autoPrintLvl:1\n\t\t})\n\n\t\treturn this;\n\t}\n\n\n\tBetterLogEntry.prototype.setStack=function(errOrStack){\n\t\tthis.stack=this.log.getStackArray(errOrStack);\n\t\t// console.log(this.stack[0])\n\t\tthis.where=this.stack[0].where\n\t\tthis.func=this.stack[0].func\n\t\treturn this;\n\t}\n\n\t/*\n\t* Slice off x rows in the begining of the stack. Also change this.where and this.func\n\t*\n\t* @param number removeLines \tThe number of lines to remove from the stack\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.changeWhere=function(removeLines){\n\t\tthis.stack.splice(0,removeLines); //remove lines WITHOUT re-creating the array which would remove hidden prop 'original'\n\t\treturn this.setStack(this.stack);\n\t}\n\n\t/*\n\t* Add 'from ${stack[1]}' to this entry\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.addFrom=function(){\n\t\tif(this.stack.length>1){\n\t\t\t//stack[0] should be the first func outside this file, so stack[1] will be the the func that\n\t\t\t//called that guy...\n\t\t\tvar {func,where}=this.stack[1];\n\t\t\tthis.append(` from ${func} (${where})`);\n\t\t}else{\n\t\t\tconsole.warn(\"Why is stack so short? Cannot trace...\",this);\n\t\t\tthis.append(` from UNKNOWN`);\n\t\t}\n\t\treturn this;\n\t}\n\n\n\n\n\n\n\t/*\n\t* Slice off x rows in the begining of the stack. Also change this.where and this.func\n\t*\n\t* @param number removeLines \tThe number of lines to remove from the stack\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.changeLvl=function(lvl){\n\t\tthis.lvl=getLogLvl(lvl);\n\t\treturn this;\n\t}\n\n\n\t/*\n\t* Add handling information to entry\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.addHandling=function(handling,...extra){\n\t\ttry{\n\t\t\t//Get passed in stack or generate one here\n\t\t\tvar stack=this.log.getStackArray((typeof handling=='object' && handling.stack) ? handling.stack:undefined);\n\n\t\t\t// this.handling.unshift({where:where,what:handling,extra:extra}); //Add to top of handling stack\n\t \t  //2019-10-10: Changing this to bottom of stack. Thinking: Original error is on top, so any later added \n\t \t  //\t\t\tmessages (even if the error is bubbling up), is added later => lower down in list\n\t\t\tthis.handling.push({where:stack[0].where,what:handling,extra:extra}); \n\t\t}catch(err){\n\t\t\tconsole.error('Not adding handling to entry.',err);\n\t\t}\n\t\treturn this;\n\t}\n\n\n\n\tBetterLogEntry.prototype.prepend=function(pre){\n\t\tif(typeof pre!='string')\n\t\t\treturn this;\n\n\t\tif(typeof this.msg=='string'){\n\t\t\t//Make sure msg doesn't already contain the same string\n\t\t\tif(this.msg.toLowerCase().replace(/[.:,;]/g,'').includes(pre.toLowerCase().replace(/[.:,;]/g,'')))\n\t\t\t\treturn this;\n\n\t\t\t//Make sure it ends in a whitespace\n\t\t\tif(!pre[pre.length-1].match(/\\s/))\n\t\t\t\tpre+=' '\n\n\t\t\tthis.msg=pre+this.msg\n\t\t}else{\n\t\t\tthis.extra.unshift(this.msg);\n\t\t\tthis.msg=pre;\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t/*\n\t* Add a string to as the last thing to be printed on the first line. It will be appended to the message if no \n\t* extras are strings, else it'll get inserted into the extra array at the right point\n\t*\n\t* @param string end\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.append=function(end){\n\t\tif(typeof end!='string')\n\t\t\treturn this;\n\n\t\tif(typeof this.msg=='string' && (!this.extra.length || typeof this.extra[0]!='string')){\n\t\t\tthis.msg+=end;\n\t\t}else{\n\t\t\tvar addToEnd=true, i=0,l=this.extra.length;\n\t\t\tfor(i; i<l;i++){\n\t\t\t\tif(typeof this.extra[i]!='string'){\n\t\t\t\t\tthis.extra.splice(i,end);\n\t\t\t\t\taddToEnd=false;\n\t\t\t\t}else if(this.extra[i].match(/\\/n/)){\n\t\t\t\t\tlet arr=this.extra[i].split('/n');\n\t\t\t\t\tarr.splice(1,end);\n\t\t\t\t\tthis.extra[i]=arr.join('/n');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(addToEnd)\n\t\t\t\tthis.extra.push(end);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/*\n\t* Make sure a string exists somewhere in the error, else add it as an extra\n\t*\n\t* @param string str\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.somewhere=function(str){\n\t\t//Check along the entire bubble chain...\n\t\tvar self=this;\n\t\twhile(self){\n\t\t\t//Does the message contain it?\n\t\t\tif(typeof self.msg=='string' && self.msg.includes(str))\n\t\t\t\treturn this;\n\n\t\t\t//Is it one of the extras??\n\t\t\tif(self.extra.find(xtra=>typeof xtra=='string' && xtra.includes(str)))\n\t\t\t\treturn this;\n\n\t\t\tself=self.bubble;\n\t\t}\n\n\t\t//If we're still running, add it!\n\t\tthis.extra.push(str);\n\n\t\treturn this;\n\n\t}\n\n\n\t/*\n\t* Add one or more items to the .extra array, handling differently for terminal and browser since\n\t* you can't see large complex variables in terminal\n\t*\n\t* @params... any\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.addExtra=function(...items){\n\t\tif(BetterLog._env=='terminal'){\n\t\t\titems=items.map(arg=>logVar(arg,100));\n\t\t}\n\t\tthis.extra.push.apply(this,items);\n\t\treturn this;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* 'Handle an entry', ie. add it to log/syslog, emit it, print it\n\t*\n\t* @param <BetterLog> asLog \tOptional. Log to add it to/emit from. If omitted the log set on the entry will be used\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.exec=function(asLog){\n\n\t\t//If our log appends the syslog or is a seperate log altogether...\n\t\tif(this.options.appendSyslog){\n\t\t\t//Add to syslog and use returned 'length' value as id for entry \n\t\t\t// entry.id=BetterLog._syslog.push(entry); //changed to vv when we changed syslog to BetterLog\n\t\t\tthis.id=BetterLog._syslog.entries.push(this)-1; \n\t\t\tthis.log.entries.push(this);\n\t\t}else{\n\t\t\tthis.id=this.log.entries.push(this)-1;\n\t\t}\n\n\t\t//Emit on our log before emitting on syslog so that listening on this log takes\n\t\t//presidence in printing\n\t\tthis.log.emit(this); //Filtering on lvl happens inside...\n\t\tif(this.options.appendSyslog)\n\t\t\tBetterLog._syslog.emit(this); //Filtering on lvl happens inside...\n\n\n\t\t//Possible auto-printing happens AFTER the entry has been emitted. If it's\n\t\t//printed there it won't be printed again...\n\t\tif(this.options.autoPrintLvl && this.lvl>=this.options.autoPrintLvl && this.printed==false)\n\t\t\tthis.print();\n\n\t\tif(this.lvl==6 && this.options.breakOnError)\n\t\t\tdebugger;\n\t\n\n\t\treturn this;\n\t}\n\n\t\n\t\n\n\n\n\t/*\n\t* Wrap entry in rejected promise\n\t*\n\t* @return Promise.reject(this)\n\t*/\n\tBetterLogEntry.prototype.reject=function(code,onlyBackup){\n\t\tcode && this.setCode(code,onlyBackup);\n\t\tvar rej=Promise.reject(this);\n\t\t// console.error(\"ble.reject() called, going to return:\",rej);\n\t\treturn rej;\n\t}\n\n\t/*\n\t* Throw the entry\n\t*\n\t* @throws BLE\n\t* @return n/a\n\t*/\n\tBetterLogEntry.prototype.throw=function(code,onlyBackup){\n\t\tif(code) this.setCode(code,onlyBackup);\n\t\tthrow this;\n\t}\n\n\n\n\t/*\n\t* @param object options \tThe options to use\n\t* @return array[string] \tArray of all the lines of the entry\n\t* @call(ble)\n\t*/\n\tfunction toPrintArray(options){\n\t\t//Mark the entry as printed, so anyone else getting it will know it's been...\n\t\tthis.printed=true;\n\n\t\t//Create the array to hold all the pieces we'll print\n\t\tvar arr=[];\n\n\t\toptions=Object.assign({},lvlLookup[this.lvl],options);\n\n\t\t//Start filling the array\n\t\tif(options.printId){\n\t\t\tarr.push('#'+String(this.id),'-');\n\t\t}\n\n\t\tif(options.printMs){\n\t\t\tarr.push(String(this.timestamp-startTime),'-');\n\t\t}else if(options.printTime){\n\t\t\tvar ts=((typeof options.printTime) == 'function' ? options.printTime(this.timestamp) : this.timestamp);\n\t\t\tarr.push(ts,'-');\t\t\t\t\n\t\t}\n\n\t\t//name of who is doing the printing... could be the \"unit\", could be the function...\n\t\t\tvar name=options.name||this.log ? this.log.name:'';\n\t\t\tif(name){\n\n\t\t\t\tif(options.printFunc && this.func){ \n\t\t\t\t\tvar func=this.func.replace(name,'') //if func contains name, remove so we don't get duplicates\n\t\t\t\t\t\t\t\t\t   .replace(/Object\\.<anonymous>/,''); //this gives zero information... just remove\n\n\t\t\t\t\t//Remove the \"unit string\" from the func since the name is what we're using (if unit is Foo{}, then \n\t\t\t\t\t//the name will either be \"Foo\" (set by constructor) or \"Bar\" (option), and we don't want\n\t\t\t\t\t//\"Foo.Foo\" or \"Foo.Bar\", we just want \"Foo\" or \"Bar\"\n\t\t\t\t\tif(this.log && typeof this.log.unit=='object') \n\t\t\t\t\t\tfunc=func.replace(this.log.unit.constructor.name,'')\n\t\t\t\t\t\n\t\t\t\t\tif(func)\n\t\t\t\t\t\tname=(name+'.'+func).replace('..','.');\n\t\t\t\t}\n\t\t\t\n\t\t\t}else if(options.printFunc){ \n\t\t\t\tname=this.func+'()';\n\t\t\t}else{\n\t\t\t\tname=this.where;\n\t\t\t}\n\n\n\t\t\tif(options.namePrefix)\n\t\t\t\tname=options.namePrefix+name\n\t\t\t\n\t\t\t\n\t\t\tif(name){\n\t\t\t\tname='['+name+']';\n\t\t\t\tif(options.printColor)\n\t\t\t\t\tif(BetterLog._env=='terminal')\n\t\t\t\t\t\tname=wrapInBashColor(name,33);\n\t\t\t\t\telse{\n\t\t\t\t\t\t//NOTE: this works together with the block below, where colorBrow is used \n\t\t\t\t\t\tname='%c'+name+'%c'; \n\t\t\t\t\t\toptions.colorBrow=['font-weight:bold','font-weight:initial',options.colorBrow];\n\t\t\t\t\t}\n\n\t\t\t\tarr.push(name,'-');\n\t\t\t}\n\t\t\n\t\t//log lvl string\n\t\tif(options.printColor){\n\t\t\tswitch(BetterLog._env){\n\t\t\t\tcase 'browser':\n\t\t\t\t\tif(options.colorBrow) //in browsers, warn and error are already colored, so colorBrow=null at top ^^\n\t\t\t\t\t\t//NOTE: The console.log in browsers has a requirement - only the first string can \n\t\t\t\t\t\t//be colorized, so we combine anything already in arr and add the level\n\t\t\t\t\t\tarr=[arr.join(' ')+` %c ${options.STR} `].concat(options.colorBrow); //works both if colorBrow is string as default, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t //or array created above ^^\n\t\t\t\t\telse\n\t\t\t\t\t\tarr.push(options.STR)\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'terminal':\n\t\t\t\tdefault:\n\t\t\t\t\tarr.push(wrapInBashColor(options.STR,options.colorTerm));\n\t\t\t}\n\t\t}else{\n\t\t\tarr.push(options.STR); \n\t\t}\n\t\tarr.push('-')\n\n\n\t\t//Main msg\n\t\taddInfo(arr,'',this._code,this.msg,this.where,this.extra,options,3);\t\t\n\n\t\t//Stack\n\t\tif(options.printStackLvl && this.lvl>=options.printStackLvl){\n\t\t\toneNewline(arr)\n\t\t\tlet indent=' '.repeat(3);\n\t\t\tvar stack=this.stack.slice(0,options.printStackLines||100);\n\t\t\tif(stack.length){\n\t\t\t\tarr.push(`${indent}[Stack]`)\n\t\t\t\tarr.push.apply(arr,stack.map(({func,where})=>`\\n${indent} | ${func} (${where})`))\n\t\t\t}\n\t\t}\n\n\t\t//Handling \n\t\tvar pre=' -->';\n\t\tif(this.handling){\n\t\t\tthis.handling.forEach(({what,where,extra})=>{\n\t\t\t\toneNewline(arr) \n\t\t\t\taddInfo(arr,pre,null,what,where,extra,options,pre.length+2)\n\t\t\t})\n\t\t}\n\n\n\t\t\n\t\t//If opted, in browser, add log so we can easily check previous messages\n\t\tif(options.printSelfOnLvl && options.printSelfOnLvl<=this.lvl && BetterLog._env=='browser'){\n\t\t\toneNewline(arr)\n\t\t\tarr.push(this);\n\t\t}\n\n\t\t\n\t\t//In Chromiums console, if the first item in arr is a number, all the string items get quoted,\n\t\t//so just to make it look pretty, make sure the first item is a string\n\t\tarr[0]=String(arr[0]);\n\n\n\t\t//Finally add a print method to the array and return it\n\t\tObject.defineProperty(arr,'print',{value:lvlLookup[this.lvl].print});\n\t\treturn arr;\n\n\t}\n\n\n\n\n\n\t/*\n\t* Print the entry.\n\t*\n\t* NOTE: This method prints the entry even if it's been previously printed\n\t* NOTE2: This method group-prints all bubbles that have not yet been printed\n\t*\n\t* @return this\n\t*/\n\tBetterLogEntry.prototype.print=function(oneTimeOptions={},asLog=null){\n\t\ttry{\n\t\t\t//Start by combining all options\n\t\t\tvar log=BetterLog._isLog(asLog) ? asLog : this.log \n\t\t\tvar options=Object.assign({},log.options,this._options,oneTimeOptions);\n\n\t\t\t//Then loop through any bubbled entries and get their output...\n\t\t\tvar bubbles=[], self=this;\n\t\t\twhile(self.bubble){\n\t\t\t\tself=self.bubble;\n\t\t\t\tif(self.printed){\n\t\t\t\t\tlet arr=[\"See previously printed entry \",(self.id ? \"#\"+self.id : logVar(self.msg,18,'noType'))]\n\t\t\t\t\tarr.print=lvlLookup[self.lvl].print;\n\t\t\t\t\tbubbles.push(arr);\n\t\t\t\t}else\n\t\t\t\t\tbubbles.push(toPrintArray.call(self,options));\n\t\t\t}\n\t\t\t//...and if any exists then group them and print the oldest one first\n\t\t\tif(bubbles.length){\n\t\t\t\tconsole.group(`--- ${lvlLookup[this.lvl].STR} ---`);\n\t\t\t\tvar i;\n\t\t\t\tif(BetterLog._env=='terminal'){\n\t\t\t\t\tfor(var i=bubbles.length-1; i>=0;i--){\n\t\t\t\t\t\tconsole.group();\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(var i=bubbles.length-1; i>=0;i--){\n\t\t\t\t\t\tconsole.group(' ');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(var i=bubbles.length-1; i>=0;i--){\n\t\t\t\t\tbubbles[i].print.apply(null,bubbles[i]);\n\t\t\t\t\tconsole.groupEnd();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Now print the current entry\n\t\t\tvar arr=toPrintArray.call(this,options);\n\t\t\tarr.print.apply(null,arr);\n\n\t\t\t//If we had a group before, print a closing line\n\t\t\tif(bubbles.length){\n\t\t\t\tconsole.groupEnd();\n\t\t\t\tif(BetterLog._env=='terminal')\n\t\t\t\t\tconsole.log('--- end ---');\n\t\t\t}\n\t\t}catch(err){\n\t\t\tconsole.error(\"BUGBUG: BetterLogEntry.print() failed.\",err,this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\n\n\t/*\n\t* Wrap string in bash color codes\n\t* @return string\n\t*/\n\tfunction wrapInBashColor(str,...colors){\n\t\treturn colors.map(c=>'\\x1b['+c+'m').join('')+str+'\\x1b[0m';\n\t}\n\n\n\n\t/*\n\t* Make sure the log array doesn't have duplicate newlines so we get a bunch of empty rows when printing\n\t* @return void;\n\t*/\n\tfunction oneNewline(arr,indent=0){\n\t\tlet l=arr.length-1;\n\t\tlet last=arr[l];\n\t\tindent=typeof indent=='string' ? indent : (' ').repeat(indent); //turn into string\n\n\t\tif(typeof last!='string'){\n\t\t\tarr.push('\\n'+indent);\n\t\t}\n\n\t\t//Add just indentation if that's missing\n\t\telse if(indent && last.match(/\\n$/)){\n\t\t\tarr[l]+=indent;\n\t\t\t\n\t\t}\n\n\t\t//Add newline and indent... \n\t\telse if(!last.match(/\\n$/)) {\n\t\t\tarr.push('\\n'+indent);\n\t\t}\n\t\t\n\t\t//...we're not dealing with all scenarios, so this may obviously cause bugs...\n\n\t\treturn;\n\t}\n\n\n\n\n\n\t//Based on if we're in terminal or browser, we'll need some special methods. But since that variable may\n\t//set set after this instance is created we simply define both for easy lookup when needed\n\tvar pushItem={\n\t\tbrowser:function(len,arr,item){arr.push(item);}\n\t\t,terminal:function(len,arr,item){arr.push(typeof item=='object' ? logVar(item,len) : item);}\n\t}\n\n\n\t/*\n\t* Add msg/extra/handling/bubble to the array\n\t*\n\t* @return $arr \t\tThe same array that was passed in\n\t*/\n\tfunction addInfo(arr,pre,code,msg,where,extra,options,extraIndent){\n\t\tvar push=pushItem[BetterLog._env].bind(arr,options.extraLength)\n\n\t\t//First we combine pre and code\n\t\tpre=String(pre||'')\n\t\tif(code||code===0)\n\t\t\tpre+=String(code)+': '\n\n\t\tif(typeof msg=='string')\n\t\t\tpush(arr,pre+msg);\t\n\t\telse if(pre){\n\t\t\tpush(arr,pre);\n\t\t\tpush(arr,msg);\n\t\t}else\n\t\t\tpush(arr,msg);\n\n\t\t//As long as all we're logging is primitives they can go on the same row, otherwise we want each on it's own row.\n\t\tvar useNewline=false;\n\t\tif(typeof msg=='object'){\n\t\t\taddWhere(where,options,arr);\n\t\t\tuseNewline=true;\n\t\t\toneNewline(arr);\n\t\t}\n\t\tif(extra){\n\t\t\t(Array.isArray(extra) ? extra : [extra]).forEach((xtra,i)=>{\n\t\t\t\tif(useNewline || (typeof xtra=='string' && xtra.match(/\\n/))||(typeof xtra=='object' && (i>0 || !(xtra instanceof Error) ) )){\n\t\t\t\t\tif(!useNewline) //on the first newline, also add the where\n\t\t\t\t\t\taddWhere(where,options,arr);\n\t\t\t\t\toneNewline(arr,extraIndent);\n\t\t\t\t\t// arr.push(xtra); \n\t\t\t\t\tpush(arr,xtra);\n\t\t\t\t\tuseNewline=true;\n\t\t\t\t}else{\n\t\t\t\t\t// arr.push(xtra); \n\t\t\t\t\tpush(arr,xtra);\n\t\t\t\t}\n\t\t\t})\t\t\n\t\t}\n\n\t\t//If we still havn't added the where, do it now before handling vv\n\t\tif(!useNewline){\n\t\t\taddWhere(where,options,arr);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\n\t/*\n\t* Append \"where\" from the stack to a string. NOTE: alters passed in array\n\t*\n\t* @param object options\n\t* @param string where\n\t* @param array arr\n\t*\n\t* @return void\n\t*/\n\tfunction addWhere(where,options,arr){\n\t\tif(where==null)\n\t\t\treturn;\n\n\t\tif(options.printWhere){\n\t\t\twhere='@ '+where.trim();\n\t\t}else\n\t\t\treturn \n\t\t\n\t\tif(options.printColor && BetterLog._env=='terminal'){ //add color if opted and we're in bash\n\t\t\twhere=wrapInBashColor(where, 33,100)+wrapInBashColor('.',30); //extra dot to try and prevent color to end of terminal window\n\t\t}\n\n\t\tarr.push(where);\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t//Setup first log, the syslog!\n\tBetterLog._syslog=new BetterLog('_syslog',{appendSyslog:false});\n\n}(typeof window !== 'undefined' ? window : this || {}));\n//simpleSourceMap=\n//simpleSourceMap2=\n\t\n\n\n\n\n\n/*\nErrors: Linux System Errors\nURL https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html\nLast modified : 11/15/2019 12:59:06\nContact: Nick West (n.west1@physics.oxford.ac.uk>) \n\nHere is a copy of that file as of Aug 2004 on RedHat 7.3\nErrors: Linux System Errors\nURL https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html\nLast modified : 11/15/2019 12:59:06\nContact: Nick West (n.west1@physics.oxford.ac.uk>) \n\nHere is a copy of that file as of Aug 2004 on RedHat 7.3\n\n\nEPERM\t\t\t(1) Operation not permitted\nENOENT\t\t\t(2) No such file or directory\nESRCH\t\t\t(3) No such process\nEINTR\t\t\t(4) Interrupted system call\nEIO\t\t\t\t(5) I/O error\nENXIO\t\t\t(6) No such device or address\nE2BIG\t\t\t(7) Arg list too long\nENOEXEC\t\t\t(8) Exec format error\nEBADF\t\t\t(9) Bad file number\nECHILD\t\t\t(10) No child processes\nEAGAIN\t\t\t(11) Try again\nENOMEM\t\t\t(12) Out of memory\nEACCES\t\t\t(13) Permission denied\nEFAULT\t\t\t(14) Bad address\nENOTBLK\t\t\t(15) Block device required\nEBUSY\t\t\t(16) Device or resource busy\nEEXIST\t\t\t(17) File exists\nEXDEV\t\t\t(18) Cross-device link\nENODEV\t\t\t(19) No such device\nENOTDIR\t\t\t(20) Not a directory\nEISDIR\t\t\t(21) Is a directory\nEINVAL\t\t\t(22) Invalid argument\nENFILE\t\t\t(23) File table overflow\nEMFILE\t\t\t(24) Too many open files\nENOTTY\t\t\t(25) Not a typewriter\nETXTBSY\t\t\t(26) Text file busy\nEFBIG\t\t\t(27) File too large\nENOSPC\t\t\t(28) No space left on device\nESPIPE\t\t\t(29) Illegal seek\nEROFS\t\t\t(30) Read-only file system\nEMLINK\t\t\t(31) Too many links\nEPIPE\t\t\t(32) Broken pipe\nEDOM\t\t\t(33) Math argument out of domain of func\nERANGE\t\t\t(34) Math result not representable\nEDEADLK\t\t\t(35) Resource deadlock would occur\nENAMETOOLONG\t(36) File name too long\nENOLCK\t\t\t(37) No record locks available\nENOSYS\t\t\t(38) Function not implemented\nENOTEMPTY\t\t(39) Directory not empty\nELOOP\t\t\t(40) Too many symbolic links encountered\nEWOULDBLOCK\t\t(41) Operation would block again\nENOMSG\t\t\t(42) No message of desired type\nEIDRM\t\t\t(43) Identifier removed\nECHRNG\t\t\t(44) Channel number out of range\nEL2NSYNC\t\t(45) Level 2 not synchronized\nEL3HLT\t\t\t(46) Level 3 halted\nEL3RST\t\t\t(47) Level 3 reset\nELNRNG\t\t\t(48) Link number out of range\nEUNATCH\t\t\t(49) Protocol driver not attached\nENOCSI\t\t\t(50) No CSI structure available\nEL2HLT\t\t\t(51) Level 2 halted\nEBADE\t\t\t(52) Invalid exchange\nEBADR\t\t\t(53) Invalid request descriptor\nEXFULL\t\t\t(54) Exchange full\nENOANO\t\t\t(55) No anode\nEBADRQC\t\t\t(56) Invalid request code\nEBADSLT\t\t\t(57) Invalid slot\nEDEADLOCK\t\t(58) Dead lock \nEBFONT\t\t\t(59) Bad font file format\nENOSTR\t\t\t(60) Device not a stream\nENODATA\t\t\t(61) No data available\nETIME\t\t\t(62) Timer expired\nENOSR\t\t\t(63) Out of streams resources\nENONET\t\t\t(64) Machine is not on the network\nENOPKG\t\t\t(65) Package not installed\nEREMOTE\t\t\t(66) Object is remote\nENOLINK\t\t\t(67) Link has been severed\nEADV\t\t\t(68) Advertise error\nESRMNT\t\t\t(69) Srmount error\nECOMM\t\t\t(70) Communication error on send\nEPROTO\t\t\t(71) Protocol error\nEMULTIHOP\t\t(72) Multihop attempted\nEDOTDOT\t\t\t(73) RFS specific error\nEBADMSG\t\t\t(74) Not a data message\nEOVERFLOW\t\t(75) Value too large for defined data type\nENOTUNIQ\t\t(76) Name not unique on network\nEBADFD\t\t\t(77) File descriptor in bad state\nEREMCHG\t\t\t(78) Remote address changed\nELIBACC\t\t\t(79) Can not access a needed shared library\nELIBBAD\t\t\t(80) Accessing a corrupted shared library\nELIBSCN\t\t\t(81) .lib section in a.out corrupted\nELIBMAX\t\t\t(82) Attempting to link in too many shared libraries\nELIBEXEC\t\t(83) Cannot exec a shared library directly\nEILSEQ\t\t\t(84) Illegal byte sequence\nERESTART\t\t(85) Interrupted system call should be restarted\nESTRPIPE\t\t(86) Streams pipe error\nEUSERS\t\t\t(87) Too many users\nENOTSOCK\t\t(88) Socket operation on non-socket\nEDESTADDRREQ\t(89) Destination address required\nEMSGSIZE\t\t(90) Message too long\nEPROTOTYPE\t\t(91) Protocol wrong type for socket\nENOPROTOOPT\t\t(92) Protocol not available\nEPROTONOSUPPORT\t(93) Protocol not supported\nESOCKTNOSUPPORT\t(94) Socket type not supported\nEOPNOTSUPP\t\t(95) Operation not supported on transport endpoint\nEPFNOSUPPORT\t(96) Protocol family not supported\nEAFNOSUPPORT\t(97) Address family not supported by protocol\nEADDRINUSE\t\t(98) Address already in use\nEADDRNOTAVAIL\t(99) Cannot assign requested address\nENETDOWN\t\t(100) Network is down\nENETUNREACH\t\t(101) Network is unreachable\nENETRESET\t\t(102) Network dropped connection because of reset\nECONNABORTED\t(103) Software caused connection abort\nECONNRESET\t\t(104) Connection reset by peer\nENOBUFS\t\t\t(105) No buffer space available\nEISCONN\t\t\t(106) Transport endpoint is already connected\nENOTCONN\t\t(107) Transport endpoint is not connected\nESHUTDOWN\t\t(108) Cannot send after transport endpoint shutdown\nETOOMANYREFS\t(109) Too many references: cannot splice\nETIMEDOUT\t\t(110) Connection timed out\nECONNREFUSED\t(111) Connection refused\nEHOSTDOWN\t\t(112) Host is down\nEHOSTUNREACH\t(113) No route to host\nEALREADY\t\t(114) Operation already in progress\nEINPROGRESS\t\t(115) Operation now in progress\nESTALE\t\t\t(116) Stale NFS file handle\nEUCLEAN\t\t\t(117) Structure needs cleaning\nENOTNAM\t\t\t(118) Not a XENIX named type file\nENAVAIL\t\t\t(119) No XENIX semaphores available\nEISNAM\t\t\t(120) Is a named type file\nEREMOTEIO\t\t(121) Remote I/O error\nEDQUOT\t\t\t(122) Quota exceeded\nENOMEDIUM\t\t(123) No medium found\nEMEDIUMTYPE\t\t(124) Wrong medium type\nESEQ\t\t\tCommands out of sequence\n*/\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js */ \"../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js\"), \"/index.js\"))\n\n//# sourceURL=webpack:///./log/better_log.js?");

/***/ }),

/***/ "./util/browser/domevents.util.js":
/*!****************************************!*\
  !*** ./util/browser/domevents.util.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/browser/domevents.util.js\n//simpleSourceMap2=/lib/util/browser/domevents.util.js\n;'use strict';\n/*\n* @module bu-browser-events\n* @author plundell\n* @license MIT\n* @description Helper functions related to DOM events\n*\n* This module is required by bu-browser\n*/\nmodule.exports=function export_mobX({cX,_log,elemX}){\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\tmarkInputting\n\t\t,throttleInput\n\t}\n\t\t\n\t/*\n\t* Monitor 'input' events on <body>, setting .inputting=function and attribute flag 'inputting' on target elem WHILE \n\t* these events are firing in rapid succession\n\t*\n\t* @param number timeout \tHow long to apply the 'inputting' flag after the last 'input' has been fired\n\t*\n\t* @return function \t\t\tCallback which removes this functionality\n\t*/\n\tvar unmark;\n\tfunction markInputting(timeout=100){\n\t\t//If this was previously called, just remove the listener and add it again\n\t\tif(unmark){\n\t\t\t_log.note(\"You were already marking inputs. Removing that and running again. Check that you want\"\n\t\t\t\t+\" to be calling it this many times.\");\n\t\t\tunmark();\n\t\t\tunmark=null;\n\t\t}\n\n\t\tvar lastInput\n\t\t\t,callback=function(event){\n\t\t\t\tlet target=event.target;\n\t\t\t\t//On the 'input' from a new target, just get ready for additional ones. By not setting anything this time we avoid\n\t\t\t\t//doing anything when eg. a <select> changed once\n\t\t\t\tif(event.target!=lastInput){\n\t\t\t\t\t//Before loosing reference to it, timeout the old input\n\t\t\t\t\tif(lastInput && lastInput.inputting){\n\t\t\t\t\t\tlastInput.inputting.expire();\n\t\t\t\t\t}\n\t\t\t\t\tlastInput=event.target;\n\n\t\t\t\t\t//Now prepare the new input...\n\t\t\t\t\tevent.target.inputting=cX.betterTimeout(function(){\n\t\t\t\t\t\tevent.target.removeAttribute('inputting');\n\t\t\t\t\t\tdelete event.target.inputting;\n\t\t\t\t\t},timeout)\n\n\t\t\t\t\t//...then set the flag\n\t\t\t\t\tevent.target.setAttribute('inputting','');\n\t\t\t\t\t\n\t\t\t\t}else if(event.target.inputting){\n\t\t\t\t\t//Push the timeout to the future\n\t\t\t\t\tevent.target.inputting.postpone();\n\t\t\t\t}\n\t\t\t\t//If it's already expired then do nothing...\n\t\t\t}\n\t\t\t,options={capture:true, passive:true};\n\t\t;\n\t\t\n\t\t//Now add the listener...\n\t\tdocument.body.addEventListener('input',callback,options)\n\n\t\t//...then return another function that can be used once to remove it (additional calls will just be ignored)\n\t\tunmark=cX.once(function unmarkInputting(){document.body.removeEventListener('input',callback,options);});\n\t\treturn unmark;\n\t}\n\n\n\t/*\n\t* Throttle an input so it only emits 'input' events so often\n\t*\n\t* @param <HTMLElement> elem\n\t* @param number delay \t\t\tHow often to emit 'input' at most\n\t*\n\t* @return function \t\t\t\tA function to remove the throttle\n\t*/\n\tfunction throttleInput(elem,delay=100){\n\t\tcX.checkType(['node','number'],arguments);\n\t\t\n\t\tvar timeout=cX.betterTimeout(delay,elem,elem.dispatchEvent);\n\t\t\n\t\tfunction throttledInput(event){\n\t\t\tif(!event.throttled){\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\tevent.throttled=true;\n\t\t\t\ttimeout.throttle(event);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlet options={capture:true};\n\t\telem.addEventListener('input',throttledInput,options)\n\n\t\treturn function unthrottleInput(){elem.removeEventListener('input',throttledInput,options)};\n\t}\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/browser/domevents.util.js?");

/***/ }),

/***/ "./util/browser/elements.util.js":
/*!***************************************!*\
  !*** ./util/browser/elements.util.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/browser/elements.util.js\n//simpleSourceMap2=/lib/util/browser/elements.util.js\n\n/*\n* @module bu-browser-elements\n* @author plundell\n* @license MIT\n* @description Helper functions related to the HTMLElements and the DOM\n*\n* This module is required by bu-browser\n*/\nmodule.exports=function export_elemX({cX,_log}){\n\n\t\n\n\t//Methods to export, returned at bottom\n\tvar _exports={\n\t\t'getSubAttributes':getSubAttributes\n\t\t,'hasSubAttributes':hasSubAttributes\n\t\t,'getLiveElement':getLiveElement\n\t\t,'getLiveElements':getLiveElements\n\t\t,'stringToHtml':stringToHtml\n\t\t,'subDataset':subDataset\n\t\t,'extractDatasetProp':extractDatasetProp\n\t\t,'getDatalist':getDatalist\n\t\t,'getElementsByRegExp':getElementsByRegExp\n\t\t,'getIdsFromNodelist':getIdsFromNodelist\n\t\t,'getJsonAttr':getJsonAttr\n\n\t\t,createInput\n\t\t,toggleSliderCss\n\t\t,'setValueOnElem':setValueOnElem\n\t\t,'getValueFromElem':getValueFromElem\n\t\t,'getChildInputs':getChildInputs\n\t\t,'getChildInputsData':getChildInputsData\n\t\t\n\t\t,'setFirstTextNode':setFirstTextNode\n\t\t,'countParentNodes':countParentNodes\n\t\t,'isDescendantOf':isDescendantOf\n\t\t,'removeClass':removeClass\n\t\t,'prependChild':prependChild\n\t\t,'createTable':createTable\n\t\t,'firstParentTagName':firstParentTagName\n\t\t,createCustomEventButton\n\t\t,'getAllStyles':getAllStyles\n\t\t,'isDisplayNone':isDisplayNone\n\t\t,'hideElement':hideElement\n\t\t,'showElement':showElement\n\t\t,getOrigin\n\t\t,nodeType\n\t\t,multiQuerySelector\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Get attribute names that begin with a \n\t*\n\t* @param <htmlElement> elem \tA live element\n\t* @param string prefix \t\t\tFilter attributes to only those that begin with this\n\t* @param boolean extract \t\tDefault false. If true the attribute will be removed from the element after fetch\n\t*\n\t* @return object  \t\t\t\tKeys are attribute names (less the prefix), values have been parsed from the \n\t*\t\t\t\t\t\t\t\t string stored on the node to primitives. (empty strings are converted to undefined)\n\t*/\n\tfunction getSubAttributes(elem,prefix,extract=false){\n\t\tvar l=prefix.length;\n\t\tvar data={};\n\t\tArray.from(elem.attributes).forEach(attr=>{\n\t\t\tif(attr.name.substring(0,l)==prefix){\n\t\t\t\tlet value=elem.getAttribute(attr.name);\n\t\t\t\tvalue=(value===''?undefined:cX.stringToPrimitive(value));\n\t\t\t\tdata[attr.name.substring(l)]=value;\n\t\t\t\t\n\t\t\t\tif(extract)\n\t\t\t\t\telem.removeAttribute(attr.name);\n\t\t\t}\n\t\t});\n\t\treturn data;\n\t}\n\n\n\n\t/*\n\t* Check if a node has any attributes begining with a prefix\n\t*\n\t* @param <htmlElement> elem \tA live element\n\t* @param string prefix \t\t\tFilter attributes to only those that begin with this\n\t*\n\t* @return bool  \t\t\t\tTrue if any such attributes exist, else false\n\t*/\n\tfunction hasSubAttributes(elem,prefix){\n\t\treturn !cX.isEmpty(getSubAttributes(elem,prefix));\n\t}\n\n\n\n\n\n\n\n\t/*\n\t\tThis function matches a regular expression of node classes and returns a live nodelist.\n\n\t\t@regexp*: Regular expression\n\t\t\n\t\t@return: live nodelist\n\t*/\n\tfunction getElementsByRegExp(re){\n\n\t\tif(!re) return false\n\n\t\tvar uniqueList = {}\n\n\t\tvar allNodes = document.getElementsByTagName(\"*\");\n\t\tArray.prototype.slice.call(allNodes).forEach(function(node){\n\t\t\tArray.prototype.slice.call(node.classList).forEach(function(c){\n\t\t\t\tif(uniqueList.hasOwnProperty(c)){\n\t\t\t\t\tuniqueList[c].push(node)\t\n\t\t\t\t} else {\n\t\t\t\t\tuniqueList[c]=Array(node)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\n\t\tvar returnList = Array()\n\t\tfor(c in uniqueList){\n\t\t\treturnList = (re.test(c) ? returnList.concat(Array.prototype.slice.call(uniqueList[c])) : returnList)\n\t\t}\n\t\treturn returnList\n\t}\n\n\n\n\t/*\n\t* This function returns a live element given an id or a live element. NOTE: for HTML collections, use\n\t* getLiveElements()\n\t*\n\t* @param mixed x \t\t\t\tA string id corresponding to an HMTL id, or a live element\n\t* @param bool returnNull \t\tDefault false. If true no error will be thrown on fail and null returned instead\n\t*\n\t* @throw <ble TypeError> \t\tIf $ was bad type \n\t* @throw <ble SyntaxError> \t\tIf poorly formated htmlstring\n\t* @throw <ble> \t\t\t\t\tIf no element was found\n\t*\n\t* @return <HTMLElement>\t\t\tThe live element. By default an error is thrown on fail, but @see $returnNull\n\t*/\n\tfunction getLiveElement(x,returnNull=false){\n\t\t// _log.traceFunc(arguments,'getLiveElement');\n\t\tvar type = cX.varType(x), node,nodes; \n\t\tswitch(type){\n\t\t\tcase \"node\":\n\t\t\t\treturn x\n\t\t\tcase \"string\":\n\t\t\t\tif(x.substring(0,1)=='<'){\n\t\t\t\t\t// _log.debug(\"Got html string, turning into live node\");\n\t\t\t\t\treturn stringToHtml(x); //throws on bad html //new element is adopted into local DOM\n\t\t\t\t}else{\n\t\t\t\t\t//First check if it starts with '#' since querySelectorAll won't work if the string also\n\t\t\t\t\t//contains characters like ':'\n\t\t\t\t\tif(x.substr(0,1)=='#'){\n\t\t\t\t\t\tnode=document.getElementById(x.substr(1));\n\t\t\t\t\t\tif(node)\n\t\t\t\t\t\t\treturn node\n\t\t\t\t\t\telse if(returnNull)\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t_log.makeError(\"Found no element with id: \"+x.substr(1)).throw();\n\t\t\t\t\t}\n\n\t\t\t\t\t//Then try it as an id\n\t\t\t\t\tnode=document.getElementById(x);\n\t\t\t\t\tif(cX.varType(node)=='node')\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\t//then try it as a query selector\n\t\t\t\t\tnodes=document.querySelectorAll(x), l=nodes.length;\n\t\t\t\t\tif(l){\n\t\t\t\t\t\tif(l>1){\n\t\t\t\t\t\t\t_log.note(`Multiple elements matched css selector '${x}', only returning first:`,nodes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nodes[0];\n\t\t\t\t\t}\n\t\t\t\t\tif(returnNull)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\telse\n\t\t\t\t\t\t_log.makeError(\"Found no element matching (id or css selector): \"+x).throw();\n\t\t\t\t}\n\t\t\tcase \"nodelist\":\n\t\t\t\tnodes=Array.from(x), l=list.length;\n\t\t\t\tif(l){\n\t\t\t\t\tif(l>1){\n\t\t\t\t\t\t_log.note(`Nodelist with ${l} nodes passed in, only returning first:`,nodes);\n\t\t\t\t\t}\n\t\t\t\t\treturn nodes[0];\n\t\t\t\t}\n\t\t\t\tif(returnNull)\n\t\t\t\t\treturn null;\n\t\t\t\telse\n\t\t\t\t\t_log.makeError(\"Empty nodelist passed in\").throw();\n\t\t\tcase 'object':\n\t\t\t\t//In case it's a MouseEvent from a click\n\t\t\t\tif(x.target && cX.varType(x.target)=='node')\n\t\t\t\t\treturn x.target;\n\t\t\tdefault:\n\t\t\t\t// _log.error('Unsupported varType passed in as node:', Object.prototype.toString.call(x), x)\n\t\t\t\t// return undefined\n\t\t\t\tif(returnNull)\n\t\t\t\t\treturn null;\n\t\t\t\telse\n\t\t\t\t\t_log.throwType('html string, id, query selector, node or nodelist',x);\n\t\t}\n\t}\n\n\t/*\n\t\tThis function returns a live element given an id or a live element. NOTE: for single element/html id, use\n\t\tgetLiveElement()\n\n\t\t@x*: A string id corresponding to an HMTL class, or a live HTMLcollection\n\n\t\t@return: A live HTMLcollection\n\t*/\n\tfunction getLiveElements(x){\n\t\tvar type = cX.varType(x) \n\t\tswitch(type){\n\t\t\tcase \"string\":\n\t\t\t\t//First assume it's a class, with or without leading '.'\n\t\t\t\tvar nodes=document.getElementsByClassName(x.substr(0,1)=='.' ? x.substr(1) : x);\n\t\t\t\tif(nodes.length)\n\t\t\t\t\treturn nodes;\n\n\t\t\t\t//Then try is as a selector\n\t\t\t\tvar nodes=document.querySelectorAll(x);\n\t\t\t\tif(!nodes.length)\n\t\t\t\t\t_log.note(`No elements matched class/selector '${x}'`);\n\t\t\t\treturn nodes; //return nodelist, empty or not\n\n\t\t\tcase \"nodelist\":\n\t\t\t\tif(!x.length)\n\t\t\t\t\t_log.note(\"Empty nodelist\");\n\t\t\t\treturn x;\n\t\t\tcase \"node\":\n\t\t\t\treturn Array(x) //return an \"HTMLcollection-like\" object... ie. can be looped the same way...\n\t\t\tdefault:\n\t\t\t\t_log.throw('Unsupported varType passed in as element: '+type);\n\t\t}\n\t}\n\n\n\n\n\n\n\t/*\n\t* @param string\n\t* @throw <ble TypeError> \tNot a string\n\t* @throw <ble SyntaxError> \tMalformated html string\n\t* @return <HTMLElement>\n\t*/\n\tfunction stringToHtml(htmlStr){\n\t\tcX.checkType('string',htmlStr);\n\t\tvar wrapper=document.createElement('div');\n\t\twrapper.innerHTML=htmlStr; //NOTE: different browsers will attempt to deal with malformed html differently, so make sure to pass good HTML\n\t\tvar node=wrapper.children[0];\n\t\tvar t=cX.varType(node)\n\t\tif(t!='node')\n\t\t\tthis.log.makeError(\"Bad HTML string, could not create HTMLElement\").setCode(\"SyntaxError\").throw();\n\t\treturn node;\n\t\t\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Get data from a live html node, optionally deleting it from node.\n\t*\n\t* @param <node> node\n\t* @param string datasetAttr \tString used on html, eg for data-xxx-repeater-title, data-xxx-repeater-artist, it should be repeater-xxx\n\t* @param bool deleteAfterFetch\n\t*\n\t* @return object\n\t*/\n\tfunction subDataset(node, datasetAttr, deleteAfterFetch=false){\n\t\t_log.trace( 'subDataset() called with args: ', arguments)\n\t\tcX.checkTypes(['node','string'],[node,datasetAttr]);\n\n\t\tvar data = {} //Return object\n\t\tvar info = {entireDataset:Object.keys(node.dataset), matchedData:[], nonMatchedData:[]} //Log object to make clear what matched and what didn't\n\t\t\n\t\tvar prefix=fromDatasetAttr(datasetAttr)\n\t\tvar l = prefix.length\n\n\t\tfor(var prop in node.dataset) {\n\t\t\tif(prop.substring(0,l)==prefix){\n\t\t\t\tinfo.matchedData.push(prop)\n\n\t\t\t\tdata[prop.charAt(l).toLowerCase()+prop.substring(l+1)]=node.dataset[prop]; //set first letter to lowercase\n\n\t\t\t\tif(deleteAfterFetch) \n\t\t\t\t\tnode.removeAttribute(toDatasetAttr(prop));\n\n\t\t\t} else {\n\t\t\t\tinfo.nonMatchedData.push(prop)\n\t\t\t}\n\t\t}\n\n\t\t_log.trace('subDataset() finished with outcome: ', info)\n\t\t\n\t\tif(cX.isEmpty(data)) \n\t\t\t_log.debug('No props found on node for data attr: ',datasetAttr)\n\t\telse{\n\t\t\t_log.debug('Found sub-dataset: ', data)\n\t\t}\n\t\t\n\t\treturn data\n\t}\n\n\n\tfunction extractDatasetProp(node,key){\n\t\tif(node.dataset.hasOwnProperty(key)){\n\t\t\tvar data=node.dataset[key];\n\t\t\tdelete node.dataset[key];\n\t\t\treturn data;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\n\tfunction toDatasetAttr(key){ //usefull when removing attribute\n\t\tkey=key.replace(/([a-z])([A-Z])/g, '$1-$2'); //MyNameIs --> My-Name-Is\n\t\tkey=key.toLowerCase();//My-Name-Is -->  my-name-is\n\t\treturn 'data-'+key;\n\n\t}\n\n\tfunction fromDatasetAttr(attr){\n\t\tif(attr.substring(0,5)=='data-')\n\t\t\tattr=attr.substring(5); //data-my-name-is  -->  my-name-is\n\n\t\treturn attr.replace(/-([a-z])/g, (match,$1)=>$1.toUpperCase()); //my-name-is --> myNameIs\n\t}\n\n\n\t/*\n\t* Set multiple items on an elements dataset\n\t*\n\t* @param <HTMLElement> elem\n\t* @param object|array data\n\t*\n\t* @throw <ble TypeError>\n\t*\n\t* @return void\n\t*/\n\tfunction setDataset(elem,data){\n\t\tvX.checkTypes(['node',['object','array']],arguments);\n\t\tObject.entries(data).forEach(([key,value])=>elem.dataset[key]=(typeof value=='object'?JSON.stringify(value):value))\n\t}\n\n\n\n\t/*\n\t\tThis functions loops through a @nodelist, checking every elements dataset for a property named @datasetProperty\n\n\t\t@nodelist*: a live nodelist of elements\n\t\t@datasetProperty*: a string used to lookup a property on each elements dataset\n\n\t\t@return: an object where every property name = element id, and property value = dataset-property value\n\t*/\n\tfunction getDatalist(nodelist, datasetProperty){\n\t\tvar datalist = {} //return object\n\n\t\tArray.prototype.slice.call(nodelist).forEach(function(elem){  //Loop through nodelist\n\t\t\tdatalist[elem.id||Math.floor(Math.random()*10000)] = elem.dataset[datasetProperty]\n\t\t})\n\n\t\treturn datalist;\n\t}\n\n\n\n\n\n\n\n\n\n\t/*\n\t\tThis function loops through a nodelist and returns a corresponding array of all html id's\n\n\t\t@nodelist - A live nodelist\n\n\t\t@return - An array of strings\n\t*/\n\tfunction getIdsFromNodelist(nodelist){\n\t\tif(cX.varType(nodelist)=='nodelist'){\n\n\t\t\tvar idList = [] //return array\n\n\t\t\tArray.prototype.slice.call(nodelist).forEach(function(elem){\n\t\t\t\tidList.push(elem.id)\n\t\t\t}) \n\n\t\t\treturn idList;\n\t\t} else {\n\t\t\t_log.warn('Unsupported format ('+_vars.varType(nodelist)+') passed to getIdsFromNodelist: ', nodelist)\n\t\t\treturn false\n\t\t}\n\n\t}\n\n\n\n\n\n\t/*\n\t* Check a node for a json string in an attribute, parsing it, storing it on the node for quicker \n\t* future fetching, then returning it\n\t*\n\t* @param node \t\tnode \tThe node to check\n\t* @param string \tattr \tThe attribute name. Only lowercase and '-'\n\t*\n\t* @throw <ble TypeError>  \t\n\t* @throw <ble SyntaxError> \tIf parsing fails. NOTE: In this case the the string is saved as $attr-fail on the node for easy debug\n\t*\n\t* @return mixed|undefined \tA parsed json string, or undefined if @attr doesn't exist\n\t*/\n\tfunction getJsonAttr(node,attr,extract=false){\n\n\t\t//Validate args\n\t\tcX.checkTypes(['node','string'],[node,attr]);\n\n\t\t//...else read them a-new...\n\t\tvar str=node.getAttribute(attr)\n\t\tif(!str){\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif(extract)\n\t\t\tnode.removeAttribute(attr);\n\n\t\ttry{\n\t\t\treturn JSON.parse(str);\n\t\t}catch(err){\n\t\t\tnode.setAttribute(attr+'-fail',str);\n\t\t\tif(!extract) node.removeAttribute(attr);\n\t\t\t_log.makeEntry('warn',`Attribute '${attr}' contained bad JSON:`,err.message,node).throw('SyntaxError');\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Create an input element from instructions.\n\t*\n\t* @param string name\n\t* @opt string type \t\t\tAny valid <input type=xxx>, or 'select'/'dropdown', 'toggle', 'radioset'. Defaults to 'text'\n\t* @opt array items \t\t\tUsed to populate certain types of inputs. Values can be a string or {label, value}\n\t*\n\t* @throw <ble TypeError>\n\t*\n\t* @return <input>|<select>|<fieldset> \t\tA single element element ready to be appended somewhere. All elements have a .value\n\t*\t\t\t\t\t\t\t\t\t\t\tprop that can be set directly\n\t*/\n\tfunction createInput(name,type='text',items=[]){\n\n\t\tcX.checkTypes(['string','string','array'],[name,type,items])\n\t\t\n\n\t\tif(type=='select'||type=='dropdown'||type=='radioset'||type=='checklist'){\n\t\t\tvar input;\n\t\t\tif(type=='radioset'||type=='checklist'){\n\t\t\t\t//This is a special case that groups multiple 'radio' <input>s into one <fieldset>. It has the benifit \n\t\t\t\t//of offering a single elem to attach listeners to, while offering the standard \"form API\" way of get/set\n\t\t\t\t//the value of the grouped radio inputs\n\t\t\t\tlet fieldset=document.createElement('fieldset');\n\t\t\t\tfieldset.setAttribute('bu-input',''); //flag so we can identify it easily\n\t\t\t\tfieldset.type=type; //does not do anything for form-api, but is used by getValueFromElem() and setValueOnElem()\n\t\t\t\tfieldset.name=name;\n\n\t\t\t\t//To make it work we have to give only the <fieldset> the true $name, while the inputs get a random \n\t\t\t\t//(but same) name to ensure only one can be selected. Then we use getters/setters to bridge the gap. \n\t\t\t\t//Since we don't know if this field will be part of a form however, we CANNOT use the form-API, instead\n\t\t\t\t//use use query selectors to find the nested inputs and alter them\n\t\t\t\tvar iname=`__${name}__`\n\t\t\t\tif(type=='radioset'){\n\t\t\t\t\tObject.defineProperty(fieldset,'value',{\n\t\t\t\t\t\tenumerable:true\n\t\t\t\t\t\t,get:()=>{\n\t\t\t\t\t\t\tlet i=fieldset.querySelector('input[type=radio]:checked');\n\t\t\t\t\t\t\treturn i==null ? undefined : i.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t,set:(val)=>{\n\t\t\t\t\t\t\tcX.checkType('primitive',val);\n\t\t\t\t\t\t\tlet i=fieldset.querySelector(`input[type=radio][value=${val}]`);\n\t\t\t\t\t\t\tif(i){\n\t\t\t\t\t\t\t\ti.checked=true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//If the option doesn't exist then we unselect all (ie. the only selected one)\n\t\t\t\t\t\t\t\tlet i=fieldset.querySelector('input[type=radio]:checked');\n\t\t\t\t\t\t\t\tif(i)\n\t\t\t\t\t\t\t\t\ti.checked=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\n\t\t\t\t}else{//type==checklist\n\n\t\t\t\t\t//the checklist gets and sets an array\n\t\t\t\t\tObject.defineProperty(fieldset,'value',{\n\t\t\t\t\t\tenumerable:true\n\t\t\t\t\t\t,get:()=>{\n\t\t\t\t\t\t\treturn Array.from(fieldset.querySelectorAll('input[type=checkbox]:checked')).map(elem=>elem.value)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t,set:(arr)=>{\n\t\t\t\t\t\t\tif(cX.checkType(['primitive','array'],arr)!='array'){\n\t\t\t\t\t\t\t\tarr=[arr];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//Set the state of each checkbox according to the array (ie. unselect all not mentioned)\n\t\t\t\t\t\t\tfieldset.querySelectorAll('input[type=checkbox]').forEach(elem=>elem.checked=arr.includes(elem.value));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\n\t\t\t\t//Populate it\n\t\t\t\toptions.forEach(opt=>{\n\t\t\t\t\tlet i=document.createElement('input'), \n\t\t\t\t\t\tl=document.createElement('label')\n\t\t\t\t\t;\n\t\t\t\t\ti.type=(type=='radioset'?'radio':'checkbox');\n\t\t\t\t\tif(typeof opt=='object'){\n\t\t\t\t\t\ti.value=opt.value;\n\t\t\t\t\t\tl.innerHTML=opt.label||opt.value;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ti.value=l.innerHTML=opt;\n\t\t\t\t\t}\n\t\t\t\t\t//Mark the input so we know it's a part of the fieldset\n\t\t\t\t\ti.setAttribute('bu-ignore','');\n\n\t\t\t\t\t//the input goes inside the label so you can click the entire label, then the label goes \n\t\t\t\t\t//inside the overall fieldset\n\t\t\t\t\tl.appendChild(i);\n\t\t\t\t\tfieldset.appendChild(l);\n\t\t\t\t})\n\n\t\t\t\t//Since regard the fieldset as the ONLY input, we intercept the change and input events and \n\t\t\t\t//change their target \n\t\t\t\tfunction changeTargetToFieldset(event){\n\t\t\t\t\tif(event.target!=this){\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tsetTimeout(()=>this.dispatchEvent(evt))\n\t\t\t\t\t\t //^a timeout is required, else \"DOMException: The event is already being dispatched.\"\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfieldset.addEventListener('input',changeTargetToFieldset,{capture:true})\n\t\t\t\tfieldset.addEventListener('change',changeTargetToFieldset,{capture:true})\n\n\n\t\t\t\t//One final same handling vv\n\t\t\t\tinput=fieldset;\n\n\t\t\t}else{//type==select|dropdown\n\n\n\t\t\t\tlet select=document.createElement('select');\n\t\t\t\t\n\t\t\t\t//Create all the options and mark the default as selected\n\t\t\t\toptions.forEach(opt=>{\n\t\t\t\t\tlet o=document.createElement('option');\n\t\t\t\t\tif(typeof opt=='object'){\n\t\t\t\t\t\to.value=opt.value;\n\t\t\t\t\t\to.innerHTML=opt.label||opt.value;\n\t\t\t\t\t}else{\n\t\t\t\t\t\to.value=o.innerHTML=opt;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tselect.appendChild(o);\n\t\t\t\t})\n\t\t\t\t\n\n\t\t\t\tinput=select; //for same handling vv\n\t\t\t}\n\n\n\t\t\t//Now the 1 bit of same handling for ^^, warn if no options were given\n\t\t\tif(!items.length){\n\t\t\t\t_log.warn(\"No items will be added to your \"+type,input);\n\t\t\t}\n\n\t\t\treturn input;\n\n\t\t}else{\n\t\t\tif(type=='toggle'){\n\t\t\t\t//This is another special case where we'll need >1 elem so we wrap it in a fieldset. This also gives\n\t\t\t\t//us the oppertunity to link the .value to the underlying .checked\n\t\t\t\tlet fieldset=document.createElement('fieldset')\n\t\t\t\tfieldset.setAttribute('bu-input',''); //flag so we can identify it easily\n\t\t\t\tfieldset.type=type;\n\t\t\t\tfieldset.name=name;\n\t\t\t\tfieldset.classList.add('toggle-wrapper');\n\n\t\t\t\t//Allow accessing the checked state of the internal checkbox with a .value prop on the wrapper\n\t\t\t\tObject.defineProperty(fieldset,'value',{\n\t\t\t\t\tenumerable:true\n\t\t\t\t\t,get:()=>fieldset.querySelector('input[type=checkbox]').checked\n\t\t\t\t\t,set:(check)=>{fieldset.querySelector('input[type=checkbox]').checked=check?true:false}\n\t\t\t\t})\n\n\t\t\t\t//The actual input will be a checkbox...\n\t\t\t\tlet input=document.createElement('input');\n\t\t\t\tinput.type='checkbox';\n\t\t\t\tfieldset.appendChild(input);\n\n\t\t\t\t//...but we'll show a nice slider created by a span+css\n\t\t\t\tlet span=document.createElement('span');\n\t\t\t\tspan.classList.add('toggle-slider');\n\t\t\t\tspan.setAttribute('onclick','javascript:event.stopImmediatePropagation();')\n\t\t\t\t  //^Only the <input> should emit a click event\n\t\t\t\tfieldset.appendChild(span);\n\n\t\t\t\t//This working as a slider is now dependent on some groovy css, @see toggleSliderCss and\n\t\t\t\t//use it together with createCSSRule() from styling.util.js\n\t\t\t\t\n\t\t\t\treturn fieldset;\n\n\n\t\t\t}else{\n\t\t\t\tvar input;\n\t\t\t\tif(type=='textarea'){\n\t\t\t\t\tinput=document.createElement('textarea');\n\t\t\t\t}else{\n\t\t\t\t\tinput=document.createElement('input');\n\t\t\t\t\tinput.type=type;\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\tinput.name=name;\n\n\t\t\t\treturn input;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvar toggleSliderCss=Object.freeze({\n\t\t'.toggle-wrapper':'position: relative;display: inline-block;width: 2em;height: 1em; border:0 none;padding:0;'\n\t\t,'.toggle-wrapper input':'opacity: 0;width: 0;height: 0;display:block;' //if 'block' is removed then <span> sits under <input>\n\t\t,'.toggle-slider':'position: absolute;cursor: pointer;top: 0;left: 0;right: 0;bottom: 0;border-radius: 1em;background-color: #ccc;-webkit-transition: .4s;transition: .4s;'\n\t\t,'.toggle-slider:before':'position: absolute;content: \"\";height: 0.8em;width: 0.8em;left: 0.1em;bottom: 0.09em;background-color: white;-webkit-transition: .4s;transition: .4s;border-radius: 50%;'\n\t\t,'input:checked + .toggle-slider':'background-color: #2196F3;'\n\t\t,'input:focus + .toggle-slider':'box-shadow: 0 0 1px #2196F3;'\n\t\t,'input:checked + .toggle-slider:before':'-webkit-transform: translateX(1em);-ms-transform: translateX(1em);transform: translateX(1em);'\n\t})\n\n\n\n\n\n\n\n\n\t/*\n\t* Set the value-property (could be 'checked' for checkboxes) on various input-like nodes.\n\t*\n\t* @param <HTMLElement> elem \tThe elem to set value on\n\t* @param primitive value  \t\tThe value to set\n\t*\n\t* @throws <ble TypeError>\n\t* @throws <ble EINVAL> \t\t$elem doesn't have .value prop but does have child elements \t\n\t* @throws <ble> \t\t\tIf elem.value!=$value after trying to set\n\t*\n\t* @return $elem\n\t*/\n\tfunction setValueOnElem(elem, value){\n\t\tif(cX.checkTypes(['node',['primitive','undefined']],[elem,value])[1]=='undefined')\n\t\t\tvalue='';\n\n\n\t\tswitch(elem.tagName){\n\t\t\tcase 'TEXTAREA':\n\t\t\tcase 'SELECT':\n\t\t\t\tbreak;\n\t\t\tcase 'INPUT':\n\t\t\t\tif(elem.type=='checkbox'||elem.type=='radio'){\n\t\t\t\t\tif(typeof value=='boolean'){\n\t\t\t\t\t\telem.checked=value;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(elem.type=='radio'){\n\t\t\t\t\t\t\t//For radios, get all with the same name since that's who we're setting\n\t\t\t\t\t\t\tlet f=firstParentTagName('form'); //form or entire document\n\t\t\t\t\t\t\tlet i=f.querySelector(`input[value=${value}][name=${elem.name}]`)\n\t\t\t\t\t\t\tif(i){\n\t\t\t\t\t\t\t\t//If we have a match, select it...\n\t\t\t\t\t\t\t\ti.checked=true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//...else unselect all\n\t\t\t\t\t\t\t\tf.querySelectorAll(`input[name=${elem.name}]`).forEach(elem=>elem.checked=false);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\telem.checked=(elem.value==value)\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t\treturn;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'FIELDSET':\n\t\t\t\tif(node.type=='radioset' || node.type=='checklist'){\n\t\t\t\t\t//2020-03-23: these work like regular inputs now...\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tif(!elem.__proto__.hasOwnProperty('value')){\n\t\t\t\t\tif(!elem.childElementCount()){\n\t\t\t\t\t\t//If no children exist, the value is just set inside the elem... like an empty <span> being populated\n\t\t\t\t\t\treturn setFirstTextNode(elem,value);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t_log.makeError(`This <'${elem.tagName.toLowerCase()}'> does not have a .value prop AND it does have children`,elem)\n\t\t\t\t\t\t\t.throw('EINVAL');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t\n\t\t//Now set the value and make sure it gets changed\n\t\tlet before=elem.value;\n\t\telem.value=value\n\t\tif(elem.value!=value){\n\t\t\t//Some changes we are not allowed, like setting a range to null/false/undefined\n\t\t\tif(elem.getAttribute('type')=='range' && !value && value!==0){\n\t\t\t\t_log.warn(`You cannot set a range to '${value}'. Default behavior was to set it to:`,elem.value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t//TODO 2020-03-27: we may want to throw ^ as well\n\n\t\t\tvar str=`Failed to set value of <${elem.tagName}> to '${value}', `;\n\t\t\tstr+=(elem.value==before ? 'it remains unchanged as ':'it was instead set to ')+`'${elem.value}'`\n\t\t\t_log.makeError(str,elem).throw();\n\t\t}\n\n\n\t\t\n\n\t\treturn;\n\t}\n\n\n\n\t/*\n\t* Get a value from a node, regardless type of node\n\t*\n\t* @param <HTMLElement> node \tThe node to get value from\n\t*\n\t* @throws TypeError\n\t*\n\t* @return void\n\t*/\n\tfunction getValueFromElem(node) {\n\t\tcX.checkType('node',node);\n\t\tvar val;\n\t\tswitch(node.tagName){\n\t\t\tcase 'INPUT':\n\t\t\t\t//For check:able inputs, return either the checked status, or the value if one exists and checked==true\n\t\t\t\tif(node.type=='checkbox'||node.type=='radio'){\n\t\t\t\t\tif(typeof node.value!='undefined'){\n\t\t\t\t\t\tval=(node.checked ? node.value : undefined);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tval=node.checked;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//don't break;\n\t\t\tcase 'TEXTAREA':\n\t\t\tcase 'SELECT':\n\t\t\t\tval=node.value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'FIELDSET':\n\t\t\t\tif(node.type=='radioset' || node.type=='checklist'){\n\t\t\t\t\t//2020-03-23: these work like regular inputs now...\n\t\t\t\t\tval=node.value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//Else just fall through\n\n\t\t\tdefault:\n\t\t\t\tlet text=getFirstTextNode(node);\n\t\t\t\tval=(text?cX.stringToPrimitive(text.data):undefined);\n\t\t\t\t //TODO: maybe add json \n\t\t}\n\n\t\treturn (val===''?undefined:val);\n\t}\n\n\n\n\n\n\n\t/*\n\t* Get all inputs nested within a parent\n\t*/\n\tfunction getChildInputs(parent){\n\t\treturn [].concat(\n\t\t\tArray.from(parent.getElementsByTagName(\"SELECT\"))\n\t\t\t,Array.from(parent.getElementsByTagName(\"TEXTAREA\"))\n\t\t\t,Array.from(parent.querySelectorAll(\"fieldset[bu-input]\")) //custom inputs from createInput()\n\t\t\t,Array.from(parent.getElementsByTagName(\"INPUT\")).filter(isInput)\n\t\t)\n\t}\n\n\t/*\n\t* Check if an element is an input (based on what getChildInputs() calls an input)\n\t* @return boolean\n\t*/\n\tfunction isInput(elem){\n\t\tlet tag=elem.tagName;\n\t\tif(tag=='SELECT'||tag=='TEXTAREA')\n\t\t\treturn true;\n\t\tif(tag=='BUTTON')\n\t\t\treturn false;\n\t\tif(tag=='FIELDSET')\n\t\t\treturn elem.hasAttribute('bu-input')\n\t\tif(tag=='INPUT' ){\n\t\t\ttype=elem.type;\n\t\t\tif(type=='button'||type=='submit'||type=='reset'||type=='image')\n\t\t\t\treturn false;\n\t\t\treturn !elem.hasAttribute('bu-ignore')\n\t\t}\n\t}\n\n\n\n\t/*\n\t* Get data from a bunch of inputs, using the 'name' attribute as key\n\t*\n\t* @param <HTMLElement> parent\n\t*\n\t* @return object \t\t\t\tAn object of data\n\t*/\n\tfunction getChildInputsData(parent){\n\t\tvar data={};\n\t\tgetChildInputs(parent).forEach(input=>{\n\t\t\tlet key=input.getAttribute('name');\n\t\t\tif(key){\n\t\t\t\t//Some inputs have 2 props of interest, .value and .checked. ..\n\t\t\t\tif(input.tagName=='INPUT' && input.type=='radio'){\n\t\t\t\t\t//Only a single radio can be selected, so make sure we have a key and set it to null or the value\n\t\t\t\t\t//of the only checked option\n\t\t\t\t\tif(!data.hasOwnProperty(key))\n\t\t\t\t\t\tdata[key]=null;\n\t\t\t\t\tif(input.checked)\n\t\t\t\t\t\tdata[key]=input.value;\n\t\t\t\t}else if(input.tagName=='INPUT' && input.type=='checkbox'){\n\t\t\t\t\t//Checkboxes aren't linked in the same way radios are, ie. there is not one value for all with the\n\t\t\t\t\t//same name. Therefore we grab all the data available and let whoever's using it sort it out... ie \n\t\t\t\t\t//we create an object where keys are .value and values are .checked\n\t\t\t\t\tif(!data.hasOwnProperty(key))\n\t\t\t\t\t\tdata[key]={};\n\t\t\t\t\tdata[key][input.value]=input.checked;\n\n\t\t\t\t}else{\n\t\t\t\t\t//For all other just get the value, this includes the \"bu-input\" customs from createInput()\n\t\t\t\t\tdata[key]=input.value;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t_log.warn(\"Input missing 'name' attribute, ignoring\",input)\n\t\t\t}\n\t\t})\n\t\treturn data;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Set a text node in an element\n\t*\n\t* NOTE: If there already is one or more text nodes in the elem, the first one gets changed\n\t* NOTE2: Any other nodes in the object stay the same\n\t*\n\t* @throw <ble TypeError>\n\t*\n\t* @return #textnode \tThe newly created, or changed existing, text node. \n\t*/\n\tfunction setFirstTextNode(elem,value){\n\t\t\n\t\tvar node=getFirstTextNode(elem);\n\n\t\tif(cX.checkType(['primitive','undefined'],value)=='undefined')\n\t\t\tvalue='';\n\n\t\tif(node==undefined){\n\t\t\t//If no text nodes existed, create one at the begining of elem\n\t\t\tnode=document.createTextNode(value);\n\t\t\tprependChild(elem,node);\n\t\t}else{\n\t\t\tnode.data=value;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\n\t/*\n\t* Get the first, if any, text node in an elem\n\t* @param <HTMLElement> elem\n\t* @throw <ble TypeError>\n\t* @return node|undefined\n\t*/\n\tfunction getFirstTextNode(elem){\n\t\tcX.checkType('node',elem);\n\n\n\t\t//If there is an existing text node, set value as first text element so as not to remove any child elements\n\t\tlet l=elem.childNodes.length\n\t\tif(l){\n\t\t\tvar i=0;\n\t\t\tfor(i;i<l;i++){\n\t\t\t\tlet node=elem.childNodes[i];\n\t\t\t\tif(node.nodeName=='#text')\n\t\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\n\n\t/*\n\t* Count how deep down the DOM structure an element resides\n\t*\n\t* @param <Node> node\n\t*\n\t* @return number \t\t\t\n\t*/\n\tfunction countParentNodes(node){\n\t\tvar i=0;\n\t\twhile(node.parentNode){\n\t\t\ti++;\n\t\t\tnode=node.parentNode;\n\t\t}\n\t\treturn i;\n\t}\n\n\n\tfunction isDescendantOf(child,parent) {\n\t\tparent=getLiveElement(parent);\n\t\tchild=getLiveElement(child);\n\n\t\t\tvar node = child.parentNode;\n\t\t\twhile (node != null) {\n\t\t\t\tif (node == parent) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnode = node.parentNode;\n\t\t\t}\n\t     return false;\n\t}\n\n\n\n\t/*\n\t* Get the index of an element within it's parent\n\t* \n\t* @param <HTMLElement> child\n\t* @opt bool countTextNodes \t\tBy default we only count \"element nodes\", but set this truthy and we'll also count\n\t*\t\t\t\t\t\t\t\t text and comment nodes\n\t*\n\t* @return number\n\t*/\n\tfunction childIndex(child,countTextNodes=false){\n\t\tvar i = 0;\n\t\tif(countTextNodes){\n\t\t\twhile( (child = child.previousSibling) != null ) \n\t\t\t\ti++;\n\t\t}else{\n\t\t\twhile( (child = child.previousElementSibling) != null ) \n\t\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\n\n\n\t/*\n\t* Remove a class from an element, and if there are no more classes, remove the class attribute as well\n\t* for a nice and clean html\n\t*/\n\tfunction removeClass(elem,cls){\n\t\telem=getLiveElement(elem);\n\t\telem.classList.remove(cls);\n\t\tif(!elem.classList.length)\n\t\t\telem.removeAttribute('class');\n\t}\n\n\t/*\n\t* Insert a node at the begining of another node\n\t*\n\t* @param <node> target \tThe existing node to insert into\n\t* @param <node> node \tThe new node we wish to insert\n\t*\n\t* @return <node> \t\tThe new node we just inserted\n\t*/\n\tfunction prependChild(target,node){\n\t\treturn target.insertBefore(node,target.childNodes[0]);\n\t}\n\n\n\t/*\n\t* Create a basic table and return an object with shortcuts to header row and body, and methods to easily add/remove stuff\n\t*\n\t* @param array columns \t\tAn array of column keys (pretty names can be added later)\n\t*\n\t* @return object \tObject with props: table, head, body and methods addRow, addCol and addColClass\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcolumns : array - kept up to date with columns in table\n\t\t\t\t\t\t\t\t_table:<table>\n\t\t\t\t\t\t\t\thead:{colA:<th>, colB:<th>, _tr:<tr>}\n\t\t\t\t\t\t\t\tbody:[{colA:<td>, colB:<td>, _tr:<tr>},{}...,_tbody]\n\t\t\t\t\t\t\t\taddRow : method\n\t\t\t\t\t\t\t\tremoveRow : method\n\t\t\t\t\t\t\t\taddCol : method - Adds a column to each row (th in thead, td in tbody)\n\t\t\t\t\t\t\t\taddColClass : method - add class to each th and td in a column\n\n\t\t\t\t\t\t\t}\n\t*/\n\tfunction createTable(columns){\n\t\tvar obj={columns};\n\n\n\n\t\tobj._table=document.createElement('table');\n\n\t\t//Add head and header row\n\t\tlet thead=document.createElement('thead');\n\t\tobj._table.appendChild(thead);\n\t\tlet headrow=document.createElement('tr');\n\t\tthead.appendChild(headrow);\n\t\t\n\t\t//To get the real width, check every single row for the largest number of columns\n\t\tObject.defineProperty(obj,'width',{enumerable:true, get:()=>\n\t\t\tArray.from(obj._table.querySelectorAll('tr'))\n\t\t\t\t.reduce((max,tr)=>Math.max(max,tr.childElementCount()),0)\n\t\t})\n\n\t\t//Create a th for each column and add to return obj.head\n\t\tobj.head={};\n\t\tObject.defineProperty(obj.head,'_tr',{value:headrow});\n\t\tfunction addTh(col){\n\t\t\tlet th=document.createElement('th');\n\t\t\tth.innerHTML=col;\n\t\t\theadrow.appendChild(th)\n\t\t\tobj.head[col]=th\n\t\t}\n\t\tcolumns.forEach(addTh);\n\n\t\t//Add body\n\t\tlet tbody=document.createElement('tbody');\n\t\tobj._table.appendChild(tbody)\n\t\tObject.defineProperty(obj,'height',{enumerable:true, get:()=>tbody.childElementCount()})\n\n\n\t\tobj.body=[];\n\t\tObject.defineProperty(obj.body,'_tbody',{value:tbody});\n\n\t\t//Create a <td> with a couple of hidden methods to easily add an input or row-button\n\t\tfunction createCell(row,colName,innerHTML){\n\t\t\tlet td=document.createElement('td');\n\t\t\tObject.defineProperties(td,{\n\t\t\t\t'_addButton':{value:function addButtonToCell(...args){return td.appendChild(createCustomEventButton.apply(this,args));}}\n\t\t\t\t,'_addInput':{value:function addInputToCell(...args){return td.appendChild(createInput.apply(this,args));}}\n\t\t\t\t,'_valueTarget':{get:()=>this.firstElementChild||this,value}\n\t\t\t\t,'_setValue':{value:function setCellValue(value){setValueOnElem(this._valueTarget,value)}}\n\t\t\t\t,'_getValue':{value:function getCellValue(){return getValueFromElem(this._valueTarget)}}\n\t\t\t})\n\t\t\ttd.innerHTML=vX.isEmpty(innerHTML,null)?'':innerHTML //null is considered empty, but 0 and false are not\n\t\t\trow._tr.appendChild(td);\n\t\t\trow[colName]=td;\n\t\t\treturn td;\n\t\t}\n\n\t\tobj.addRow=function addRow(data=[]){\n\t\t\tif(typeof data !='object' || !data)\n\t\t\t\t_log.throwType(\"object or array\",data);\n\n\t\t\t//Create a row...\n\t\t\tlet row={};\n\t\t\tlet tr=document.createElement('tr');\n\t\t\tObject.defineProperty(row,'_tr',{value:tr});\n\n\t\t\t//Fill it with cells\n\t\t\tif(Array.isArray(data)){\n\t\t\t\tvar i,l=columns.length;\n\t\t\t\tfor(i=0;i<l;i++){\n\t\t\t\t\t//If we get an array, add as many items as there are columns (ie. if there are more\n\t\t\t\t\t//here the remainder get discarded, and if there are less we'll end up with empty cells\n\t\t\t\t\t//and the end of the row)\n\t\t\t\t\tcreateCell(row,columns[i],data[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//If we got an object, grab props named as the columns we already have\n\t\t\t\tcolumns.forEach(col=>createCell(row,col,data[col]))\n\t\t\t}\n\n\t\t\t//If we have any classes to add...\n\t\t\tif(colClass){\n\t\t\t\tvar col;\n\t\t\t\tfor(col in colClass){\n\t\t\t\t\trow[col].classList.add(...colClass[col]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//...and add it to the body and the shorcut on our return element\n\t\t\ttbody.appendChild(tr);\n\t\t\tobj.body.push(row);\n\t\t\treturn row;\n\t\t};\n\n\t\t/*\n\t\t* Remove a child <tr> element\n\t\t*\n\t\t* @param number i \tThe index of the row in obj.body\n\t\t*\n\t\t* @return <tr>|undefined \tThe removed row or undefined if none are left\n\t\t*/\n\t\tobj.removeRow=function removeRow(i){\n\t\t\tvar row=obj.body[i];\n\t\t\tif(row){\n\t\t\t\ttbody.removeChild(row);\n\t\t\t\treturn row;\n\t\t\t}else{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tobj.empty=function empty(i){\n\t\t\twhile(obj.body.length){\n\t\t\t\tobj.removeRow(0);\n\t\t\t}\n\t\t}\n\n\t\tobj.addCol=function addCol(name){\n\t\t\tcolumns.push(name);\n\t\t\taddTh(name);\n\t\t\tobj.body.forEach(row=>{\n\t\t\t\tlet td=document.createElement('td');\n\t\t\t\trow._tr.appendChild(td);\n\t\t\t\trow[col]=td;\n\t\t\t})\n\t\t}\n\n\t\tvar colClass; \n\t\tobj.addColClass=function addColClass(col,cls){\n\t\t\tif(!colClass)\n\t\t\t\tcolClass={};\n\n\t\t\tif(!colClass.hasOwnProperty(col))\n\t\t\t\tcolClass[col]=[];\n\t\t\tcolClass[col].push(cls);\n\t\t\tobj.head[col].classList.add(cls);\n\t\t\tobj.body.forEach(row=>row[col].classList.add(cls));\n\t\t}\n\n\n\n\n\n\n\n\n\t\t//Now return the object\n\t\treturn obj;\n\t}\n\n\n\t/*\n\t* Create a <button> that emits a custom event when clicked INSTEAD of the 'click' event. \n\t*\n\t* NOTE: This button can be cloned without loosing functionality\n\t*\n\t* @param string buttonText  \tThe caption on the button\n\t* @opt string eventName \t\tThe name of the event to emit when the button is clicked\n\t* @opt object|primitive details Any additional details to add to the custom event. NOTE: objects will be set\n\t*\t\t\t\t\t\t\t\t on the button's dataset, ie. they will not remain live\n\t*\n\t* @return <HTMLElement> \tA <button> element\n\t*/\n\tfunction createCustomEventButton(buttonText,eventName=undefined,details=undefined){\n\t\tvX.checkTypes(['string',['string','undefined']],[buttonText,eventName]);\n\n\t\tlet button=document.createElement('button');\n\t\tbutton.innerHTML=buttonText;\n\t\tbutton.type='button'; //this does the same as event.preventDefault()\n\n\t\t//Optionally add a custom event to be emitted when the button is clicked. This event will remain\n\t\t//intact if the button is cloned\n\t\tif(eventName){\n\t\t\tvar detailStr=',details:';\n\t\t\tswitch(typeof details){\n\t\t\t\tcase 'object':\n\t\t\t\t\tdetailStr+='this.dataset'\n\t\t\t\t\tsetDataset(button,details);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'string':\n\t\t\t\t\tdetailStr+=`'${details}'`;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tdetailStr+=String(details)\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdetailStr=''\n\t\t\t}\n\n\t\t\tbutton.setAttribute('onclick','javascript: event.stopImmediatePropagation();this.dispatchEvent(new CustomEvent('\n\t\t\t\t\t+`'${eventName}',{bubbles:true,cancelable:true${detailStr}))`\n\t\t\t);\n\t\t}\n\n\t\treturn button;\n\t}\n\n\n\n\t/*\n\t* Get the first parent to an elem (or the elem itself) that has a certain tag\n\t*\n\t* @param <HTMLElement> elem\n\t* @param string tagName\n\t*\n\t* @return <HTMLElement>|null\n\t*/\n\tfunction firstParentTagName(elem,tagName){\n\t\ttagName=tagName.toUpperCase();\n\t\twhile(elem && elem.tagName!=tagName){\n\t\t\telem=elem.parentElement;\n\t\t}\n\t\treturn elem;\n\t}\n\n\n\t/*\n\t* Get all styles applied to an element\n\t*\n\t* @param mixed elem \t@see getLiveElement()\n\t*\n\t* @throws \t\t\t\t@see getLiveElement()\n\t*\n\t* @return object \t\tKeys are style names, values are style values\n\t*/\n\tfunction getAllStyles(elem) {\n\t\telem=getLiveElement(elem);\n\n\t    var styles={}\n\t    \n\t    //Deal with different browsers\n\t    var win=document.defaultView||window\n\t    if(win.getComputedStyle){ // Modern browsers\n\t        let styleArr=win.getComputedStyle(elem, ''), l=styleArr.length;\n\t        var i=0;\n\t        for(i; i<l; i++) {\n\t            styles[styleArr[i]]=styleArr.getPropertyValue(styleArr[i]);\n\t        }\n\t    }else if(elem.currentStyle){ //IE\n\t        styles=elem.currentStyle;\n\n\t    }else{ //Ancient browser..\n\t        let styleArr=elem.style, l=styleArr.length;\n\t        var i=0;\n\t        for(i; i<l; i++) {\n\t             styles[styleArr[i]]=styleArr[styleArr[i]];\n\t        }\n\t    }\n\n\t    return styles;\n\t}\n\n\n\t/*\n\t* Check if an element has display none set directly on it, or at all\n\t*\n\t* @param mixed elem \t@see getLiveElement()\n\t*\n\t* @throws \t\t\t\t@see getLiveElement()\n\t*\n\t* @return number \t\t0=not set (ie. elem is not hidden)\n\t*\t\t\t\t\t\t1=set directly on element\n\t*\t\t\t\t\t\t2=set via css (old browsers will only show 1)\n\t*/\n\tfunction isDisplayNone(elem){\n\t\telem=getLiveElement(elem);\n\t    \n\t    if(elem.style.display=='none')\n\t    \treturn 1;\n\n\t    //Deal with different browsers\n\t    var win=document.defaultView||window\n\t    if(win.getComputedStyle){ // Modern browsers\n\t        return win.getComputedStyle(elem, '').display=='none'?2:0;\n\t    }else if(elem.currentStyle){ //IE\n\t    \treturn elem.currentStyle.display=='none'?2:0;\n\t    }else{ //Ancient browser..\n\t    \t//these only have elem.style.display, and we've already checked that\n\t        return 0\n\t    }\n\t}\n\n\t/*\n\t* Hide an element by setting display:none AND storing any previous display info\n\t*\n\t* NOTE: If already hidden, this will do nothing\n\t*\n\t* @param mixed elem \t\t\t@see getLiveElem\n\t* @param @opt string storeAttr \tAttribute to use for storeing existing\n\t*\n\t* @return void\n\t*/\n\tfunction hideElement(elem, storeAttr='_display'){\n\t\telem=getLiveElement(elem);\n\t\tif(!isDisplayNone(elem)){\n\t\t\t\n\t\t\t//If anything was set directly on elem, store it. \n\t\t\tif(elem.style.display)\n\t\t\t\telem.setAttribute(storeAttr,elem.style.display);\n\t\t\t\n\t\t\telem.style.display='none';\n\n\t\t\t//If still not hiding, add the important flag\n\t\t\tif(!isDisplayNone(elem)){\n\t\t\t\telem.style.display='none !important';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\n\t/*\n\t* Show an element by restoring a previous display setting, or at least removing display:none\n\t*\n\t* NOTE: If already showing, this will do nothing\n\t*\n\t* @param mixed elem \t\t\t@see getLiveElem\n\t* @param @opt string storeAttr \tAttribute used for storeing existing\n\t*\n\t* @return void\n\t*/\n\tfunction showElement(elem, storeAttr='_display'){\n\t\telem=getLiveElement(elem); //do first since we're calling isDisplayNone twice\n\t\tif(isDisplayNone(elem)){\n\t\t\t//Start by trying to restore a previous showing state, then check again\n\t\t\telem.style.display=elem.getAttribute(storeAttr); \n\t\t\tif(isDisplayNone(elem)){\n\t\t\t\t//This implies that a css rule has been applied to the elem (or that the \n\t\t\t\t//attribute also contained display:none)... in either case we want to unset\n\t\t\t\t//that value\n\t\t\t\telem.style.display=\"unset !important\";\n\n\t\t\t\t//Now the element may STILL not be showing if it's inheriting a display:none, \n\t\t\t\t//but in that case there's nothing we can/should do here because it's the\n\t\t\t\t//parent who needs showing...\n\t\t\t}\n\n\t\t\t//If there are no more style attributes, clean up after yourself\n\t\t\tif(!elem.getAttribute('style'))\n\t\t\t\telem.removeAttribute('style');\n\t\t}\n\t\treturn;\n\t}\n\n\n\n\tfunction getOrigin(elem){\n\t\tvar ref;\n\t\tif(elem.href)\n\t\t\tref=href\n\t\telse if(elem.src)\n\t\t\tref=elem.src\n\t\telse\n\t\t\treturn undefined\n\n\t\treturn (new URL(ref)).origin;\n\t}\n\n\n\n\tvar nodeTypes={\n\t\t1:'element'\n\t\t,2:'attribute'\n\t\t,3:'text'\n\t\t,8:'comment'\n\t}\n\tfunction nodeType(node){\n\t\tif(node){\n\t\t\treturn nodeTypes[node.nodeType];\n\t\t}\n\t}\n\n\n\n\n\n\t/*\n\t* Run querySelectorAll() on multiple targets and/or with multiple selectors, optionally including the\n\t* targets themselves and/or grouping targets by selectors\n\t*\n\t* @param <HTMLElement>|<Nodelist> targets\n\t* @param string|array selectors\n\t* @flag 'group' \tGroup nodes by selector\n\t* @flag 'class' \tUse getElementsByClassName instead which is faster. \n\t* @flag 'self' \t\tIf also using 'class', remember to seperate multiple classes with '.' NOT whitespace\n\t*\n\t* @throws <ble TypeError>\n\t* @throws other?\n\t*\n\t* @return array|object \t\tAnd object if flag 'group', else an array. Possibly empty. \n\t*/\n\tfunction multiQuerySelector(targets,selectors,...flags){\n\t\tvar types=cX.checkTypes([['node','nodelist'],['string','array'],['array','undefined','string']],arguments);\n\t\ttargets=(types[0]=='node' ? [targets] : Array.from(targets));\n\t\tselectors=(types[1]=='string' ? [selectors] : Array.from(selectors));\n\t\tflags=(types[3]=='string' ? [flags] : flags) || [];\n\t\t\n\t\tlet group=flags.includes('group')\n\t\t\t,self=flags.includes('self')\n\t\t\t,cls=flags.includes('class')\n\t\t;\n\n\t\tlet func=(cls?'getElementsByClassName':'querySelectorAll');\n\t\t\n\t\tconst all=group ? {} : [];\n\t\t\n\t\tfor(let selector of selectors){\n\t\t\tlet arr=all;\n\t\t\tif(group){\n\t\t\t\tif(!all.hasOwnProperty(selector))\n\t\t\t\t\tgroup[selector]=[];\n\t\t\t\tarr=group[selector]\n\t\t\t}\n\t\t\t\n\t\t\t//For the sake of .matches() we make sure single class names are prepended by a '.'. If\n\t\t\t//the user has supplied something like 'clsA clsB' then it's their own damn fault\n\t\t\tif(cls && self && selector.charAt(0)!='.'){\n\t\t\t\tselector='.'+selector;\n\t\t\t}\n\n\t\t\tfor(let target of targets){\n\t\t\t\tarr.push.apply(arr,Array.from(target[func].call(target,selector)));\n\t\t\t\t\n\t\t\t\tif(self && target.matches(selector)){\n\t\t\t\t\tarr.push(target)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn all;\n\t}\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/browser/elements.util.js?");

/***/ }),

/***/ "./util/browser/mobile.util.js":
/*!*************************************!*\
  !*** ./util/browser/mobile.util.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/browser/mobile.util.js\n//simpleSourceMap2=/lib/util/browser/mobile.util.js\n/*\n* @module bu-browser-styling\n* @author plundell\n* @license MIT\n* @description Helper functions related to mobile devices, like touch etc\n*\n* This module is required by bu-browser\n*/\n;'use strict';\nmodule.exports=function export_mobX({cX,_log,elemX}){\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\t'detectSwipe':detectSwipe\n\t\t,'getZoom':getZoom\n\t}\n\t\t\n\n\t/*\n\t 2020-03-16: \n\t There is something called 'passive events', supported by some browsers, not others. In supported \n\t browsers addEventListener()'s 3rd arg is an options object, while in the rest it is just checked for\n\t truthy to determine if the event should bubble or not. Therefore we need to know if the current \n\t browser supports it so we can act accordingly when eg detecting swipes.\n\t\t https://developers.google.com/web/tools/lighthouse/audits/passive-event-listeners\n\t\t https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n\t\t https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n\t*/\n\t// Test via a getter in the options object to see if the passive property is accessed\n\tvar supportsPassive = false;\n\ttry {\n\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tsupportsPassive = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener(\"testPassive\", null, opts);\n\t\twindow.removeEventListener(\"testPassive\", null, opts);\n\t} catch (e) {}\n\n\n\n\n\t/* \n\t* Call a func on left/right/up/down swipes\n\t* Based on this answer by 'Ulysse BN': \n\t* \thttps://stackoverflow.com/questions/15084675/how-to-implement-swipe-gestures-for-mobile-devices/58719294#58719294\n\t*\n\t* NOTE: params can be passed in any order\n\t*\n\t* @opt string|node elem \t@see getLiveElement(). Defaults to the window element\n\t* @param function cb \t\tFunction called on swipe with single string 'up','down','right' or 'left'\n\t* @param number deltaMin \tSwipe distance required to trigger. Near 0 it will almost always trigger, with a big value \n\t*\t\t\t\t\t\t\tit can never trigger.\n\t* @param bool preventScroll Default false.\n\t*/\n\tfunction detectSwipe(...args) {\n\t\t//First get the args\n\t\tvar cb=cX.getFirstOfType(args,'function')||_log.makeError('No callback function given').setCode('EINVAL').throw();\n\t\tvar elem=elemX.getLiveElement(cX.getFirstOfType(args,'node')||cX.getFirstOfType(args,'string')||window); //should not throw...\n\t\tvar deltaMin=cX.getFirstOfType(args,'number')||90;\n\t\tvar preventScroll=cX.getFirstOfType(args,'boolean')||false;\n\n\n\t\t//2020-03-16: See above\n\t\tvar passiveOrBubble=(supportsPassive ? {passive:true,capture:false} : false);\n\t\t\n\t\t//Define vars that will store where touches start and end\n\t\tvar startX=0,startY=0,endX=0,endY=0;\n\n\t\t//Now listen for the start and end events...\n\n\t\telem.addEventListener('touchstart', function ontouchstart(e) {\n\t\t\t//Set start AND end positions to the same thing... so if we don't move at all it won't look like we have...\n\t\t\tendX=startX=e.touches[0].screenX\n\t\t\tendY=startY=e.touches[0].screenY\n\t\t\t// console.log('start','x:',startX,'y:',startY)\n\n\t\t\t//If we're preventing scroll, we only have to call preventDefault() once on the first move event\n\t\t\tif(preventScroll){\n\t\t\t\t//'once' listener that works in all situations\n\t\t\t\tvar preventScroll=function(e){e.preventDefault();elem.removeEventListener('touchmove',preventScroll)}\n\t\t\t\telem.addEventListener('touchmove',preventScroll)\n\t\t\t}\n\t\t}, passiveOrBubble)\n\n\n\t\telem.addEventListener('touchend', function ontouchend(e) {\n\t\t\t//Now record the end positions\n\t\t\tendX = e.changedTouches[0].screenX\n\t\t\tendY = e.changedTouches[0].screenY\n\t\t\t\t//unlike touchstart, here 'touches' is an empty array...\n\n\t\t\t//Get the traveled distance along each axis and determine what to call the callback with (if the swipe is \n\t\t\t//diaganol it may very well be called twice)\n\t\t\tlet deltaX=endX-startX, deltaY=endY-startY;\n\t\t\t// console.log('end','x:',endX,'y:',endY)\n\n\t\t\tvar swipe=false;\n\t\t\tif(Math.abs(deltaX)>deltaMin){\n\t\t\t\tswipe=true;\n\t\t\t\tlet d= deltaX > 0 ? 'right' : 'left';\n\t\t\t\t_log.debug(\"detected swipe \"+d,{deltaX,deltaMin});\n\t\t\t\tcb(d);\n\t\t\t}\n\n\t\t\tif(Math.abs(deltaY)>deltaMin){\n\t\t\t\tswipe=true;\n\t\t\t\tlet d= deltaY > 0 ? 'up' : 'down';\n\t\t\t\t_log.debug(\"detected swipe \"+d,{deltaY,deltaMin});\n\t\t\t\tcb(d);\n\t\t\t}\n\n\t\t\t//If no swipe happened, but we DID move our finger... just say so...\n\t\t\tif(!swipe && (deltaY || deltaX)){\n\t\t\t\t_log.trace(\"no swipe, too short...\",{deltaX,deltaY,deltaMin});\n\t\t\t}\n\t\t}, passiveOrBubble)\n\t}\n\n\n\t/*\n\t* Get the current zoom level \n\t*\n\t* @return number  Decimal number of zoom, 1 == 100%\n\t*/\n\tfunction getZoom(){\n\t\t\treturn document.documentElement.clientWidth/window.innerWidth\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/browser/mobile.util.js?");

/***/ }),

/***/ "./util/browser/rest.util.js":
/*!***********************************!*\
  !*** ./util/browser/rest.util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/browser/rest.util.js\n//simpleSourceMap2=/lib/util/browser/rest.util.js\n/*\n* @module bu-browser-rest\n* @author plundell\n* @license MIT\n* @description Helper functions related to RESTful api calls\n*\n* This module is required by bu-browser\n*/\n;'use strict';\nmodule.exports=function export_restX({cX,_log}){\n\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\t'POST':POST\n\t\t// ,'queryStrToObj':queryStrToObj\n\t\t// ,'objToQueryStr':objToQueryStr\n\t}\n\t\t\n\n\n\t/*\n\t* Post an object and get a response\n\t*\n\t* Details and examples can be found here:\n\t* https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n\t*\n\t* @param string target \t\t\t\t\tWhere to send the data, usually a file on the server\n\t* @param primitive|object|array data \tThe data to send. It will be json stringified\n\t* @param @opt <BetterLog> log \t\t\tThe log to use\n\t*\n\t* @return Promise(mixed,err) \t\t\tA promise that resolves when a successfull response arrives, \n\t*\t\t\t\t\t\t\t\t\t\tor rejects in all other cases with one of these codes:\n\t*\t\t\t\t\t\t\t\t\t\t\tTypeError \t\t- The passed in args where bad\n\t*\t\t\t\t\t\t\t\t\t\t\tclienterror  \t- request never left this computer\n\t*\t\t\t\t\t\t\t\t\t\t\tservererror \t- Server responded with a negative response \n\t*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(see err.msg + err.status)\n\t*\t\t\t\t\t\t\t\t\t\t\tabort \t\t\t- The request was aborted before full response\n\t*\t\t\t\t\t\t\t\t\t\t\ttimeout \t\t- The request timed out\n\t*\t\t\t\t\t\t\t\t\t\t\tBUGBUG \t\t\t- Should not happen. Some error with this code\n\t* @logged\n\t*/\n\tfunction POST(target,data,log){\n\t\t\n\t\t//Use the passed in log or the util log\n\t\tif(!_log._isLog(log))\n\t\t\tlog=_log\n\t\t\n\t\tif(typeof target!='string')\n\t\t\treturn log.rejectType('arg#1 to be string target, eg. api.php',target);\n\t\t\n\t\t//Create promise we'll return\n\t\tvar {promise,resolve,reject,inspect}=xxx.util.exposedPromise();\n\n\t\ttry{\n\t\t\tvar xhr = new XMLHttpRequest();\n\n\t\t\t//First set event listeners\n\t\t//2020-02-20: Is this v correct? Because 'loadend' loads after error AND when load is complete, so maybe 'error'\n\t\t//\t\t\t\thappens even on bad responses??\n\t\t\t// xhr.addEventListener('error',function POST_error(err){\n\t\t\t// \treject(log.makeError('Failed to make request (ie. nothing left this computer)',err).setCode('clienterror').exec());\n\t\t\t// })\n\t\t\txhr.addEventListener('abort',function POST_abort(err){\n\t\t\t\treject(log.makeError('Request aborted.',err).setCode('abort').exec());\n\t\t\t})\n\t\t\txhr.addEventListener('timeout',function POST_timeout(err){\n\t\t\t\t//don't know if error is also fired\n\t\t\t\treject(log.makeError('Request timed out.',err).setCode('timeout').exec());\n\t\t\t})\n\t\t\txhr.addEventListener('loadend',function POST_load(){\n\t\t\t\tif(this.status>=200 && this.status<300){\n\t\t\t\t\tlog.info(`Got successfull ${this.status} response from ${target}:`,this.response);\n\t\t\t\t\tresolve(this.response);\n\t\t\t\t}else if(inspect.status=='pending'){\n\t\t\t\t\tvar err=log.makeError(target)\n\t\t\t\t\t\t.setCode(this.status)\n\t\t\t\t\t\t.somewhere(this.response)\n\t\t\t\t\t;\n\t\t\t\t\treject(err);\t\t\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t//Then make the request\n\t\t\tlog.info(`About to POST to ${target}:`,data);\n\t\t\tlet payload=JSON.stringify(data);\n\t\t\txhr.open(\"POST\", target, true); //true==async\n\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\t\t\txhr.send(payload); //ProTip: Chrome will console.error this by default. You can turn it off in DevTools 3-dots\n\n\t\t}catch(err){\n\t\t\treject(log.makeError(err).setCode('BUGBUG').exec());\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n\n\n//# sourceURL=webpack:///./util/browser/rest.util.js?");

/***/ }),

/***/ "./util/browser/styling.util.js":
/*!**************************************!*\
  !*** ./util/browser/styling.util.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/browser/styling.util.js\n//simpleSourceMap2=/lib/util/browser/styling.util.js\n\n/*\n* @module bu-browser-styling\n* @author plundell\n* @license MIT\n* @description Helper functions related to css styling\n*\n* This module is required by bu-browser\n*/\nmodule.exports=function export_styleX({cX,_log,elemX}){\n\n\t\n\n\t//Methods to export\n\tvar _exports={\n\t\t'increaseBrightness':increaseBrightness\n\t\t,'scrollBarWidth':scrollBarWidth\n\t\t,'colorNameToHex':colorNameToHex\n\t\t,'createCSSRule':createCSSRule\n\t\t,appendCSSRule\n\t\t,findCSSRule\n\t\t,getSameOriginStylesheets\n\t}\n\t  \n\n\n\tfunction increaseBrightness(hex, percent){\n\t\t// strip the leading # if it's there\n\t\thex = hex.replace(/^\\s*#|\\s*$/g, '');\n\n\t\t// convert 3 char codes --> 6, e.g. `E0F` --> `EE00FF`\n\t\tif(hex.length == 3){\n\t\t\thex = hex.replace(/(.)/g, '$1$1');\n\t\t}\n\n\t\tvar r = parseInt(hex.substr(0, 2), 16),\n\t\t\tg = parseInt(hex.substr(2, 2), 16),\n\t\t\tb = parseInt(hex.substr(4, 2), 16);\n\n\t\tpercent=percent/100\n\t\treturn '#' +\n\t\t   ((0|(1<<8) + r + (256 - r) * percent ).toString(16)).substr(1) +\n\t\t   ((0|(1<<8) + g + (256 - g) * percent ).toString(16)).substr(1) +\n\t\t   ((0|(1<<8) + b + (256 - b) * percent ).toString(16)).substr(1);\n\t}\n\n\n\tfunction scrollBarWidth(){\n\t  \tvar scrollDiv = document.createElement(\"div\");\n\t  \tscrollDiv.style = \"width: 100px;\"\n\t\t\t\t\t   +\"height: 100px;\"\n\t\t\t\t\t   +\"overflow: scroll;\"\n\t\t\t\t\t   +\"position: absolute;\"\n\t\t\t\t\t   +\"top: -9999px;\"\n\t  \t;\n\t  \tdocument.body.appendChild(scrollDiv);\n\n\t\t// Get the scrollbar width\n\t\tvar scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n\t\t// Delete the DIV \n\t\tdocument.body.removeChild(scrollDiv);\n\n\t\treturn scrollbarWidth;\n\t}\n\n\n\tfunction colorNameToHex(name){\n\t\tname=name.toUpperCase();\n\t\tif(colors.hasOwnProperty(name))\n\t\t\treturn colors[name];\n\t\telse\n\t\t\treturn colors['GRAY'];\n\t}\n\n\tvar colors={\n\t\t\"WHITE\":\"#FFFFFF\"\n\t\t,\"AZURE\":\"#FFFFFF\"\n\t\t,\"MINTCREAM\":\"#FFFFFF\"\n\t\t,\"SNOW\":\"#FFFFFF\"\n\t\t,\"IVORY\":\"#FFFFFF\"\n\t\t,\"GHOSTWHITE\":\"#FFFFFF\"\n\t\t,\"FLORALWHITE\":\"#FFFFFF\"\n\t\t,\"ALICEBLUE\":\"#FFFFFF\"\n\t\t,\"LIGHTCYAN\":\"#CCFFFF\"\n\t\t,\"HONEYDEW\":\"#FFFFFF\"\n\t\t,\"LIGHTYELLOW\":\"#FFFFFF\"\n\t\t,\"SEASHELL\":\"#FFFFFF\"\n\t\t,\"LAVENDERBLUSH\":\"#FFFFFF\"\n\t\t,\"WHITESMOKE\":\"#FFFFFF\"\n\t\t,\"OLDLACE\":\"#FFFFFF\"\n\t\t,\"CORNSILK\":\"#FFFFCC\"\n\t\t,\"LINEN\":\"#FFFFFF\"\n\t\t,\"LIGHTGOLDENRODYELLOW\":\"#FFFFCC\"\n\t\t,\"LEMONCHIFFON\":\"#FFFFCC\"\n\t\t,\"BEIGE\":\"#FFFFCC\"\n\t\t,\"LAVENDER\":\"#CCCCFF\"\n\t\t,\"PAPAYAWHIP\":\"#FFFFCC\"\n\t\t,\"MISTYROSE\":\"#FFCCCC\"\n\t\t,\"ANTIQUEWHITE\":\"#FFFFCC\"\n\t\t,\"BLANCHEDALMOND\":\"#FFFFCC\"\n\t\t,\"BISQUE\":\"#FFFFCC\"\n\t\t,\"PALETURQUOISE\":\"#99FFFF\"\n\t\t,\"MOCCASIN\":\"#FFCCCC\"\n\t\t,\"GAINSBORO\":\"#CCCCCC\"\n\t\t,\"PEACHPUFF\":\"#FFCCCC\"\n\t\t,\"NAVAJOWHITE\":\"#FFCC99\"\n\t\t,\"PALEGOLDENROD\":\"#FFFF99\"\n\t\t,\"WHEAT\":\"#FFCCCC\"\n\t\t,\"POWDERBLUE\":\"#CCCCFF\"\n\t\t,\"AQUAMARINE\":\"#66FFCC\"\n\t\t,\"LIGHTGREY\":\"#CCCCCC\"\n\t\t,\"PINK\":\"#FFCCCC\"\n\t\t,\"LIGHTBLUE\":\"#99CCFF\"\n\t\t,\"THISTLE\":\"#CCCCCC\"\n\t\t,\"LIGHTPINK\":\"#FFCCCC\"\n\t\t,\"LIGHTSKYBLUE\":\"#99CCFF\"\n\t\t,\"PALEGREEN\":\"#99FF99\"\n\t\t,\"LIGHTSTEELBLUE\":\"#99CCCC\"\n\t\t,\"KHAKI\":\"#FFCC99\"\n\t\t,\"SKYBLUE\":\"#99CCFF\"\n\t\t,\"AQUA\":\"#00FFFF\"\n\t\t,\"CYAN\":\"#00FFFF\"\n\t\t,\"SILVER\":\"#CCCCCC\"\n\t\t,\"PLUM\":\"#CC99CC\"\n\t\t,\"GRAY\":\"#CCCCCC\"\n\t\t,\"LIGHTGREEN\":\"#99FF99\"\n\t\t,\"VIOLET\":\"#FF99FF\"\n\t\t,\"YELLOW\":\"#FFFF00\"\n\t\t,\"TURQUOISE\":\"#33CCCC\"\n\t\t,\"BURLYWOOD\":\"#CCCC99\"\n\t\t,\"GREENYELLOW\":\"#99FF33\"\n\t\t,\"TAN\":\"#CCCC99\"\n\t\t,\"MEDIUMTURQUOISE\":\"#33CCCC\"\n\t\t,\"LIGHTSALMON\":\"#FF9966\"\n\t\t,\"MEDIUMAQUAMARINE\":\"#66CC99\"\n\t\t,\"DARKGRAY\":\"#999999\"\n\t\t,\"ORCHID\":\"#CC66CC\"\n\t\t,\"DARKSEAGREEN\":\"#99CC99\"\n\t\t,\"DEEPSKYBLUE\":\"#00CCFF\"\n\t\t,\"SANDYBROWN\":\"#FF9966\"\n\t\t,\"GOLD\":\"#FFCC00\"\n\t\t,\"MEDIUMSPRINGGREEN\":\"#00FF99\"\n\t\t,\"DARKKHAKI\":\"#CCCC66\"\n\t\t,\"CORNFLOWERBLUE\":\"#6699FF\"\n\t\t,\"HOTPINK\":\"#FF66CC\"\n\t\t,\"DARKSALMON\":\"#FF9966\"\n\t\t,\"DARKTURQUOISE\":\"#00CCCC\"\n\t\t,\"SPRINGGREEN\":\"#00FF66\"\n\t\t,\"LIGHTCORAL\":\"#FF9999\"\n\t\t,\"ROSYBROWN\":\"#CC9999\"\n\t\t,\"SALMON\":\"#FF9966\"\n\t\t,\"CHARTREUSE\":\"#66FF00\"\n\t\t,\"MEDIUMPURPLE\":\"#9966CC\"\n\t\t,\"LAWNGREEN\":\"#66FF00\"\n\t\t,\"DODGERBLUE\":\"#3399FF\"\n\t\t,\"YELLOWGREEN\":\"#99CC33\"\n\t\t,\"PALEVIOLETRED\":\"#CC6699\"\n\t\t,\"MEDIUMSLATEBLUE\":\"#6666FF\"\n\t\t,\"MEDIUMORCHID\":\"#CC66CC\"\n\t\t,\"CORAL\":\"#FF6666\"\n\t\t,\"CADETBLUE\":\"#669999\"\n\t\t,\"LIGHTSEAGREEN\":\"#339999\"\n\t\t,\"GOLDENROD\":\"#CC9933\"\n\t\t,\"ORANGE\":\"#FF9900\"\n\t\t,\"LIGHTSLATEGRAY\":\"#669999\"\n\t\t,\"FUCHSIA\":\"#FF00FF\"\n\t\t,\"MAGENTA\":\"#FF00FF\"\n\t\t,\"MEDIUMSEAGREEN\":\"#33CC66\"\n\t\t,\"PERU\":\"#CC9933\"\n\t\t,\"STEELBLUE\":\"#3399CC\"\n\t\t,\"ROYALBLUE\":\"#3366CC\"\n\t\t,\"SLATEGRAY\":\"#669999\"\n\t\t,\"TOMATO\":\"#FF6633\"\n\t\t,\"DARKORANGE\":\"#FF9900\"\n\t\t,\"SLATEBLUE\":\"#6666CC\"\n\t\t,\"LIMEGREEN\":\"#33CC33\"\n\t\t,\"LIME\":\"#00FF00\"\n\t\t,\"INDIANRED\":\"#CC6666\"\n\t\t,\"DARKORCHID\":\"#9933CC\"\n\t\t,\"BLUEVIOLET\":\"#9933FF\"\n\t\t,\"DEEPPINK\":\"#FF0099\"\n\t\t,\"DARKGOLDENROD\":\"#CC9900\"\n\t\t,\"CHOCOLATE\":\"#CC6633\"\n\t\t,\"DARKCYAN\":\"#009999\"\n\t\t,\"DIMGRAY\":\"#666666\"\n\t\t,\"OLIVEDRAB\":\"#669933\"\n\t\t,\"SEAGREEN\":\"#339966\"\n\t\t,\"TEAL\":\"#009999\"\n\t\t,\"DARKVIOLET\":\"#9900CC\"\n\t\t,\"MEDIUMVIOLETRED\":\"#CC0066\"\n\t\t,\"ORANGERED\":\"#FF3300\"\n\t\t,\"OLIVE\":\"#999900\"\n\t\t,\"SIENNA\":\"#996633\"\n\t\t,\"DARKSLATEBLUE\":\"#333399\"\n\t\t,\"DARKOLIVEGREEN\":\"#666633\"\n\t\t,\"FORESTGREEN\":\"#339933\"\n\t\t,\"CRIMSON\":\"#CC0033\"\n\t\t,\"BLUE\":\"#0000FF\"\n\t\t,\"DARKMAGENTA\":\"#990099\"\n\t\t,\"DARKSLATEGRAY\":\"#336666\"\n\t\t,\"SADDLEBROWN\":\"#993300\"\n\t\t,\"BROWN\":\"#993333\"\n\t\t,\"FIREBRICK\":\"#993333\"\n\t\t,\"PURPLE\":\"#990099\"\n\t\t,\"GREEN\":\"#009900\"\n\t\t,\"RED\":\"#FF0000\"\n\t\t,\"MEDIUMBLUE\":\"#0000CC\"\n\t\t,\"INDIGO\":\"#330099\"\n\t\t,\"MIDNIGHTBLUE\":\"#000066\"\n\t\t,\"DARKGREEN\":\"#006600\"\n\t\t,\"DARKBLUE\":\"#000099\"\n\t\t,\"NAVY\":\"#000099\"\n\t\t,\"DARKRED\":\"#990000\"\n\t\t,\"MAROON\":\"#990000\"\n\t\t,\"BLACK\":\"#000000\"\n\t}\n\n\t/*\n\t* Add a rule to the first viable stylesheet of the document. Based on this answer: \n\t*\thttps://stackoverflow.com/a/8630641\n\t*\n\t* NOTE: There crossorigin issues with this, and different browsers handle it differently (eg. firefox\n\t*\t\tthrows and error, while chrome won't let you see those tags to begin with, so you can't\n\t*\t\tcause an error). Where this error is most likely to occur is with <style> tags as opposed to <link> \n\t*\t\ttags which seemingly are treated as a different origin\n\t* \n\t* @param string selector  Any css selector, ie. the part that comes before the {}\n\t* @param string style \t  Everything that goes between {} in a css file\n\t* @param boolean replace  If an identical selector already exists, replace it's contents\n\t*\n\t* @throw Error \t\tIf the document is not compatible with creating rules \n\t*\n\t* @return void\n\t*/\n\tfunction createCSSRule (selector, style, replace=false) {\n\t\tif(!document.styleSheets || document.getElementsByTagName('head').length == 0) \n\t\t\tthrow new Error(\"This document/browser doesn't support creating CSS selectors\");\n\n\t\t//Get a list of stylesheets that we are allowed to edit and that will affect the screen\n\t\tvar styleSheets=getSameOriginStylesheets().filter(ss=>{\n\t\t\t//Only include enabled stylesheets\n\t\t\tif(ss.disabled)\n\t\t\t\treturn false;\n\n\t\t\t//Only include those that affect screens (?? we may not want this behaviour)\n\t\t\tlet mediaText=typeof ss.media=='string' ? ss.media : ss.media.mediaText;\n\t\t\tif(!mediaText||mediaText=='all'||mediaText.indexOf('screen')>-1)\n\t\t\t\treturn true\n\t\t\telse\n\t\t\t\treturn false;\n\t\t});\n\n\n\t\t\n\t\ttry{\n\t\t\t//If we're replacing an existing rule, look through all rules in all stylesheets...\n\t\t\tif(replace){\n\t\t\t\tlet rule=findCSSRule(selector,styleSheets);\n\t\t\t\trule.cssText=style;\n\t\t\t\t_log.debug(\"Replaced existing CSS rule\",rule);\n\t\t\t\treturn rule;\n\t\t\t}\n\t\t}catch(err){\n\t\t\t_log.warn(\"Failed to replace existing rule, will try to append next...\",err);\n\t\t}\n\n\t\t//If none was found, try creating one as the last item of the last stylesheet (so it \n\t\t//gets highest priority)\n\t\ttry{\n\t\t\tlet sheet=styleSheets.pop();\n\t\t\tif(!sheet){\n\t\t\t\t_log.note(\"No style sheet found at all, is that correct?\");\n\t\t\t}else{\n\t\t\t\treturn appendCSSRule(sheet,selector,style);\n\t\t\t}\n\t\t}catch(err){\n\t\t\t_log.warn(\"Failed to add rule to existing stylesheet, will try creating own stylesheet next...\",err);\t\n\t\t}\n\n\t\t\t\n\t\t//If we're still running, this means we failed to use existing sheets, so create a new one\n\t\t//and insert the rule there\n\t\ttry{\n\t\t\tvar styleSheet = document.createElement('style');\n\t\t\tstyleSheet.type = 'text/css';\n\t\t\tdocument.head.appendChild(styleSheet);\n\t\t\treturn appendCSSRule(styleSheet,selector,style);\n\t\t}catch(err){\n\t\t\t_log.throw(\"Failed to create a CSS rule in an existing or new styleSheet.\",err);\n\t\t}\n\t}\n\n\n\t/*\n\t* Appends a CSS rule to the end of a stylesheet\n\t*\n\t* @param <HTMLElement>|<CSSStyleSheet> styleSheet\n\t* @param string selector\n\t* @param string style\n\t*\n\t* @throw <ble Error> \tIf no rule was appended\n\t*\n\t* @return <CSSRule>\n\t*/\n\tfunction appendCSSRule(styleSheet, selector, style){\n\t\t//If a live style elem is passed, just call this method again with the style sheet\n\t\tif(cX.varType(styleSheet)=='node'){\n\t\t\tif(styleSheet.sheet)\n\t\t\t\treturn appendCSSRule(styleSheet.sheet,selector,style);\n\t\t\telse\n\t\t\t\t_log.makeTypeError(\"a <style> elem\",styleSheet).throw();\n\t\t}\n\n\t\tcX.checkTypes(['<CSSStyleSheet>','string','string'],arguments);\n\n\t\tvar rule;\n\t\tif(typeof styleSheet.insertRule=='function'){ //modern version\n\t\t\tvar pos=styleSheet.insertRule(`${selector}{${style}}`, styleSheet.cssRules.length); //default to first, so we specify last\n\t\t\tif(pos!=styleSheet.cssRules.length-1)\n\t\t\t\t_log.warn(`A CSS rule was inserted at index ${pos}, which is not the end`,styleSheet.cssRules);\n\t\t\trule=styleSheet.cssRules[pos];\n\t\t}else if(typeof styleSheet.addRule=='function'){ //legacy from Microsoft\n\t\t\tstyleSheet.addRule(selector,style); //defaults to last position\n\t\t\trule=styleSheet.rules[styleSheet.length-1];\n\t\t}\n\t\tif(rule)\n\t\t\treturn rule;\n\t\telse\n\t\t\t_log.makeError('No rule was created. Dont know why? Called with:',arguments).throw();\n\t}\n\n\n\t/*\n\t* @param string selector\n\t* @opt array-like styleSheets \tThe style sheets to look through (remember, they need to be same origin)\n\t*\n\t* @return <CSSStyleRule>|undefined\n\t*/\n\tfunction findCSSRule(selector,styleSheets=null){\n\t\tstyleSheets=Array.from(styleSheets)||getSameOriginStylesheets();\n\t\tfor(var ss of styleSheets){\n\t\t\tlet rules=(typeof ss.media=='string' ? ss.rules : ss.cssRules), l=rules.length;\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tif(rules[i].selectorText && rules[i].selectorText.toLowerCase()==selector.toLowerCase()) {\n\t\t\t\t\treturn rules[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t* @return array[<StyleSheet>]\n\t*/\n\tfunction getSameOriginStylesheets(){\n\t\tif(!document.styleSheets || !document.styleSheets.length)\n\t\t\treturn [];\n\n\t\treturn Array.from(document.styleSheets).filter(ss=>{\n\t\t\ttry{\n\t\t\t\tss.cssRules||ss.rules\n\t\t\t\treturn true;\n\t\t\t}catch(err){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t})\n\t}\n\t/*\n\t* @return array[<StyleSheet>]\n\t*/\n\tfunction getSameOriginStylesheets2(){\n\t\tif(!document.styleSheets || !document.styleSheets.length)\n\t\t\treturn [];\n\n\t\t//Get the origin of this script\n\t\tlet origin=elemX.getOrigin(document.currentScript);\n\n\t\treturn Array.from(document.styleSheets).filter(ss=>origin==elemX.getOrigin(ss))\n\t}\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/browser/styling.util.js?");

/***/ }),

/***/ "./util/bu-browser.js":
/*!****************************!*\
  !*** ./util/bu-browser.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";'use strict';\n/**\n* @module bu-browser\n* @author plundell\n* @license MIT\n* @description Helper and utility functions for browsers\n*\n* This script should be bundled for the web with browserify or webpack\n*/\n\nmodule.exports=function exportBetterUtilBrowser(dep){\n\n    //Pass all deps straight on to cX\n    const cX=__webpack_require__(/*! ./bu-common.js */ \"./util/bu-common.js\")(dep);\n\n    //Rename the log\n    const _log = cX._log;\n    _log.changeName('BetterUtil');\n\n\t\n\tconst elemX=__webpack_require__(/*! ./browser/elements.util.js */ \"./util/browser/elements.util.js\")({cX,_log});\n\tconst styleX=__webpack_require__(/*! ./browser/styling.util.js */ \"./util/browser/styling.util.js\")({cX,_log,elemX});\n\tconst mobX=__webpack_require__(/*! ./browser/mobile.util.js */ \"./util/browser/mobile.util.js\")({cX,_log,elemX});\n\tconst restX=__webpack_require__(/*! ./browser/rest.util.js */ \"./util/browser/rest.util.js\")({cX,_log});\n    const evtX=__webpack_require__(/*! ./browser/domevents.util.js */ \"./util/browser/domevents.util.js\")({cX,_log,elemX});\n\t\n    //Combine everything onto the same object\n    var bu=Object.assign(cX,elemX,styleX,mobX,restX,evtX);\n\n    //Since this module is exclusivly used in the browser, we also set the exported\n    //object on the passed in one, that way if dep==window it will automatically be\n    //exposed globally (and if dep is just a temp object then no worries...)\n    dep.BetterUtil=bu;\n\n    return bu;\n\n}\n\n\n\n//# sourceURL=webpack:///./util/bu-browser.js?");

/***/ }),

/***/ "./util/bu-common.js":
/*!***************************!*\
  !*** ./util/bu-common.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n* @module bu-common\n* @author plundell\n* @description General purpose javascript utilities and helpers\n* @license MIT\n*\n* This file is meant to be 'required'. It in turn requires all util files in the 'common' folder \n* and re-exports them as one object.\n*\n* This module is required by bu-node and bu-browser which are probably the entry points you'll\n* want to use. \n*/\n\nmodule.exports=function exportBetterUtilCommon(dep){\n\t\n\t//The passed in object should contain all the dependencies.\n\tfunction missingDependency(which){throw new Error(\"BetterUtil is missing a dependency: \"+which);}\n\tconst BetterLog = dep.BetterLog || missingDependency('BetterLog');\n\tconst BetterEvents = dep.BetterEvents || missingDependency('BetterEvents');\n\n\t//Also make sure it contains two function we need\t\n\tvar {varType,logVar}=BetterLog;\n\tif(typeof varType!='function'||typeof logVar!='function'){\n\t\tconsole.error({\n\t\t\tvarType:[typeof varType,varType]\n\t\t\t,logVar:[typeof logVar,logVar]\n\t\t\t,BetterLog:[typeof BetterLog,BetterLog]\n\t\t});\n\t\tthrow new Error(\"BUGBUG: The BetterLog constructor didn't have prop-funcs varType and logVar\");\n\t}\n\n\tconst _log=new BetterLog('cX')\n\n\n\n\tconst vX=__webpack_require__(/*! ./common/vars.util.js */ \"./util/common/vars.util.js\")({varType,logVar,_log});\n\tconst aX=__webpack_require__(/*! ./common/arr.util.js */ \"./util/common/arr.util.js\")({vX,_log});\n\tconst fX=__webpack_require__(/*! ./common/functions.util.js */ \"./util/common/functions.util.js\")({vX,_log,aX});\n\tconst oX=__webpack_require__(/*! ./common/obj.util.js */ \"./util/common/obj.util.js\")({vX,_log});\n\tconst pX=__webpack_require__(/*! ./common/promise.util.js */ \"./util/common/promise.util.js\")({vX,_log});\n\tconst stX=__webpack_require__(/*! ./common/string.util.js */ \"./util/common/string.util.js\")({vX,_log});\n\tconst mX=__webpack_require__(/*! ./common/misc.util.js */ \"./util/common/misc.util.js\")({vX,_log, stX});\n\tconst tX=__webpack_require__(/*! ./common/time.util.js */ \"./util/common/time.util.js\")({vX,_log});\n\tconst netmask=__webpack_require__(/*! ./common/netmask.polyfill.js */ \"./util/common/netmask.polyfill.js\");\n\tconst validate=__webpack_require__(/*! ./common/validate.util.js */ \"./util/common/validate.util.js\")({netmask});\n\tconst Timer=__webpack_require__(/*! ./common/timer.class.js */ \"./util/common/timer.class.js\")({BetterLog,BetterEvents});\n\n\tconst cX=Object.assign(\n\t\t{\n\t\t\tvalidate\n\t\t\t,_log\n\t\t\t,netmask\n\t\t\t,Timer\n\t\t}\n\t\t,vX,aX,fX,oX,pX,stX,mX,tX\n\t)\n\n\treturn cX;\n}\n\n\n\n\n//# sourceURL=webpack:///./util/bu-common.js?");

/***/ }),

/***/ "./util/common/arr.util.js":
/*!*********************************!*\
  !*** ./util/common/arr.util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/common/arr.util.js\n//simpleSourceMap2=/lib/util/common/arr.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to ARRAYS\n*/\n;'use strict';\nmodule.exports=function export_aX({_log,vX}){\n\n\t//Methods to export\n\tvar _exports= {\n\t    'join':join\n\t    ,'uniqueArrayFilter':uniqueArrayFilter\n\t    ,'extractItem':extractItem\n\t    ,'extractItems':extractItems\n\t    ,'flatten':flatten\n\t    ,'rowsToString':rowsToString\n\t    ,'getFirstOfType':getFirstOfType\n\t    ,'arrayDiff':arrayDiff\n\t    ,'sameArrayContents':sameArrayContents\n\t    ,'anyArrayOverlap':anyArrayOverlap\n\t    ,'pushToNestedArray':pushToNestedArray\n\t    ,'filterSplit':filterSplit\n\t};\n\n\n\n\n\n\n\n\n\t/*\n\t* Join an array, optionally setting last delimiter to something else\n\t* @return string\n\t*/\n\tfunction join(arr, delimit, lastDelimit){\n\t\ttry{\n\t\t\tvX.checkType('array',arr);\n\t\t\tvar last= (typeof lastDelimit=='string' ? lastDelimit+arr.splice(-1,1) : \"\");\n\t\t\treturn arr.join(delimit) + last;\n\t\t}catch(err){\n\t\t\t_log.throw(err);\n\t\t}\n\t}\n\n\n\n\tfunction uniqueArrayFilter(value, index, arr) { \n\t\t// vX.checkType('array',arr);\n\t    return arr.indexOf(value) === index;\n\t}\n\n\n\tfunction extractItem(arr,item){\n\t\tvX.checkType('array',arr);\n\t\treturn extractCommon(arr,item);\n\t}\n\n\t/*\n\t* Extract several items from an array\n\t*\n\t* @param array arr\n\t* @param array|function x \tList of items to extract, or a callback which get's passed each item and if it\n\t*\t\t\t\t\t\t\treturns truthy then the item is extracted\n\t*\n\t* @return array \t\tAn array of the items that existed (ie. could be an empty array)\n\t*/\n\tfunction extractItems(arr,x){\n\t\tif(vX.checkTypes(['array',['array','function']],Object.values(arguments))[1]=='function'){\n\t\t\tvar extracted=[],i;\n\t\t\tfor(i=arr.length-1; i>-1;i--){\n\t\t\t\tif(x(arr[i],i,arr)){\n\t\t\t\t\textracted.unshift(arr.splice(i,1)[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn extracted;\n\t\t}else{\n\t\t\treturn x\n\t\t\t\t.map(item=>extractCommon(arr,item))\n\t\t\t\t.filter(item=>typeof item!='undefined');\n\t\t}\n\t}\n\n\t/*\n\t*@private\n\t*/\n\tfunction extractCommon(arr,item){\n\t\tlet i=arr.indexOf(item);\n\t\treturn (i>-1 ? arr.splice(i,1)[0] : undefined);\n\t}\n\n\n\n\n\tfunction flatten(arr){\n\t\tvar ret=[];\n\t\tarr.forEach(child=>{\n\t\t\tif(Array.isArray(child))\n\t\t\t\tret=ret.concat(child);\n\t\t\telse\n\t\t\t\tret.push(child);\n\t\t})\n\t\treturn ret;\n\t}\n\n\tfunction rowsToString(arr){\n\t\t//So as not to change the original array, we create a duplicate\n\t\tvar arr2=[];\n\t\t//First we're going to find the longest string in each column, which decides the width of that column\n\t\tvar ll={},c;\n\t\tarr.forEach(row=>{\n\t\t\tvar row2={};\n\t\t\tfor(c in row){\n\t\t\t\tswitch(row[c]){\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\trow2[c]='<undef>'; break;\n\t\t\t\t\tcase null:\n\t\t\t\t\t\trow2[c]='<null>';break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\trow2[c]=String(row[c]);\n\t\t\t\t}\n\t\t\t\tlet l=row2[c].length\n\t\t\t\tif(!ll[c])\n\t\t\t\t\tll[c]=Math.max(String(c).length, l); //longest of column title and this value\n\t\t\t\telse if(ll[c]<l)\n\t\t\t\t\tll[c]=l\n\t\t\t}\n\t\t\tarr2.push(row2);\n\t\t})\n\n\t\tvar output=''\n\n\t\t//Add the header row\n\t\tfor(c in ll){\n\t\t\toutput+=String(c).padEnd(ll[c]+2);\n\t\t}\n\t\toutput+='\\n'\n\n\t\t//Add all data\n\t\tarr2.forEach(row=>{\n\t\t\tfor(c in ll){\n\t\t\t\tlet str=row[c]||'<undef>';\n\t\t\t\toutput+=str.padEnd(ll[c]+2);\n\t\t\t}\n\t\t\toutput+='\\n'\n\t\t})\n\t\treturn output;\n\t}\n\n\n\t/*\n\t* Look through an array for the first instance of a given type, returning (possibly extracting) it\n\t*\n\t* @param array arr \t \t\tAn array or the arguments obj\t\t\n\t* @param any type \t\t\t@see checkType(arg2)\n\t* @param extract bool \t\tDefault false. If true the item is removed from arr\n\t*\n\t* @return any|undefined\t\tThe target item, or undefined\n\t*/\n\tfunction getFirstOfType(arr, type,extract=false){\n\n\t\tif(vX.checkType(['array','object'],arr)=='object'){\n\t\t\tif(typeof arr.length!='number')\n\t\t\t\t_log.throwType(\"arg #1 to be an array-like object\",arr);\n\t\t\telse\n\t\t\t\tarr=Array.from(arr);\n\t\t}\n\n\t\tvar i=0,l=arr.length;\n\t\tfor(i;i<l;i++){\n\t\t\tlet v=arr[i]\n\t\t\tif(vX.checkType(type,v,true)){\n\t\t\t\tif(extract)\n\t\t\t\t\tarr.splice(i,1);\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\n\n\t/*\n\t* Check difference between 2 arrays\n\t*\n\t* @param array A\n\t* @param array B\n\t*\n\t* @return [[only in A],[only in B],[in both]] \tReturns array with 3 child arrays\n\t*/\n\tfunction arrayDiff(A,B,...flags){\n\t\tif(!flags.includes('noCheck'))\n\t\t\tvX.checkTypes(['array','array'],[A,B]);\n\n\t\tvar onlyA=[],onlyB=[],both=[],x;\n\t\tfor(x of A){\n\t\t\tif(B.indexOf(x)>-1)\n\t\t\t\tboth.push(x);\n\t\t\telse\n\t\t\t\tonlyA.push(x);\n\t\t}\n\t\tfor(x of B){\n\t\t\tif(A.indexOf(x)==-1)\n\t\t\t\tonlyB.push(x);\n\t\t}\n\t\treturn [onlyA,onlyB,both];\n\t}\n\n\n\t/*\n\t* Check if 2 arrays contain the same items, even if those items are not in the same order\n\t*\n\t* @param array A\n\t* @param array B\n\t*\n\t* @return boolean\n\t*/\n\tfunction sameArrayContents(A,B){\n\t\tvX.checkTypes(['array','array'],[A,B]);\n\n\t\tif(A.length!=B.length)\n\t\t\treturn false;\n\n\t\tvar [onlyA,onlyB,ignore]=arrayDiff(A,B,'noCheck');\n\t\treturn onlyA.length==0 && onlyB.length==0\n\t}\n\n\n\t/*\n\t* Check if 2 arrays have any overlap (but quicker than getting a full arrayDiff\n\t*\n\t* @param array A\n\t* @param array B\n\t*\n\t* @return boolean\n\t*/\n\tfunction anyArrayOverlap(A,B){\n\t\tvar x;\n\t\tfor(x of A){\n\t\t\tif(B.indexOf(x)>-1)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/*\n\t* @throws TypeError \tIf nested prop exists and is not an array\n\t*/\n\tfunction pushToNestedArray(obj,key,value){\n\t\tif(!obj.hasOwnProperty(key))\n\t\t\tobj[key]=[];\n\t\tobj[key].push(value);\n\t}\n\n\n\n\t/*\n\t* Filter an array into two arrays\n\t*\n\t* @param array arr\n\t* @param function func\n\t* @return array \t\t\tAn array with items that returned truthy. The falsey items\n\t*\t\t\t\t\t\t\tare set on a hidden property .rest\n\t*/\n\tfunction filterSplit(arr,func,retainIndex=false){\n\t\ttry{\n\t\t\tvar i,l=arr.length,a=[],b=[];\n\t\t\tif(retainIndex){\n\t\t\t\tfor(i=arr.length-1;i>=0;i--){\n\t\t\t\t\tif(func(arr[i])){\n\t\t\t\t\t\ta[i]=arr[i];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb[i]=arr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(i=arr.length-1;i>=0;i--){\n\t\t\t\t\tif(func(arr[i])){\n\t\t\t\t\t\ta.unshift(arr[i])\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb.unshift(arr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject.defineProperty(a,'rest',{value:b,writable:true,configurable:true});\n\t\t\treturn a;\n\t\t}catch(err){\n\t\t\tcX.checkTypes(['array','function'],arguments);\n\t\t\tcX._log.makeError(err).throw();\n\t\t}\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/arr.util.js?");

/***/ }),

/***/ "./util/common/functions.util.js":
/*!***************************************!*\
  !*** ./util/common/functions.util.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/functions.util.js\n//simpleSourceMap2=/lib/util/common/functions.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n\nmodule.exports=function export_fX({_log,vX,aX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\tprettyArgs\n\t\t,getArgNames\n\t\t,callWithNamedArgs\t\n\t\t,once\t\n\t\t,renameFunction\n\t\t,betterTimeout\n\n\t};\n\n\n\n\n\n\t/*\n\t\tThis function can be called from within another function and returns\n\t\tan object where the parameters and their values are the calling functions\n\t\targument names and the values passed in to them\n\n\t\t@liveArgs*: the 'arguments' array from the calling function\n\n\t\t@throws Error If calling function is native or bound\n\t\t@return: An object {callerArg1:passedInValue1, callerArg2:passedInValue2 ...}\n\t*/\n\tfunction prettyArgs(liveArgs){\n\t\tretObj = Object()\n\t\tvar argArray = JSON.parse(JSON.stringify(liveArgs)) // hardcopy\n\t\tif(argNames = getArgNames(arguments.callee.caller)){\n\t\t\tfor(i in argArray){\n\t\t\t\tretObj[argNames[i]]=argArray[i]\n\t\t\t}\n\t\t} \n\n\t\treturn retObj\n\t}\n\n\n\t/*\n\t* This function gets the names of a given functions arguments\n\t*\n\t* @param function f\n\t*\n\t* @throws Error \tIf function was bound or native\n\t* @return array \tAn array of strings (or empty array)\n\t*/\n\tfunction getArgNames(f,showDefaults=false) {\n\t\ttry{\n\t\t\tvar fnStr = f.toString();\n\t\t\tif(fnStr=='function () { [native code] }'){\n\t\t\t\tif(!f.length)\n\t\t\t\t\treturn [];\n\t\t\t\tthrow 'Because passed function was native or bound.';\n\t\t\t}\n\t\t\t\n\t\t\t//Grab everything between the first parenthesis\n\t\t\tfnStr=fnStr.slice(fnStr.indexOf('(')+1,fnStr.indexOf(')'));\n\t\t  \tif(fnStr){\n\t\t  \t\tvar arr=fnStr.split(',').map(arg=>arg.trim());\n\t\t  \t\tif(showDefaults)\n\t\t  \t\t\treturn arr;\n\t\t  \t\telse\n\t\t  \t\t\treturn arr.map(arg=>arg.replace(/(.+)=.+/,'$1').trim()) //remove possible default value and whitespace\n\t\t  \t}else{\n\t\t  \t\treturn [];\n\t\t  \t}\n\t  \t} catch(err){\n\t  \t\t_log.makeError(err).prepend('Could not get argument names.').throw();\n\t  \t}\n\t}\n\n\n\t/*\n\t* Call a func given an object of named args\n\t*\n\t* @param function func \t\tThe function to call\n\t* @param object args \t\tAn object with keys matching the names of the functions args\n\t* @param @opt object self \tCall the function as\n\t*\n\t* @throw TypeError \t\t\tIf the args expected by this function are wrong\n\t* @throw any \t\t\t\tWhatever the function you're calling may throw\n\t* @return any \t\t\t\tReturns whatever the function returns\n\t*/\n\tfunction callWithNamedArgs(func, args, self){\n\t\tvX.checkTypes(['function','object',['object','undefined']],[func,args,self]);\t\n\t\treturn func.apply(self,getArgNames(func).map(key=>args[key]));\n\t}\n\n\n\t/*\n\t* Change the name of a function. \n\t*\n\t* @param function fn\n\t* @param string name\n\t*\n\t* @return void\n\t*/\n\tfunction renameFunction(fn,name){\n\t\tvX.checkTypes(['function','string'],arguments);\n\t\tObject.defineProperty(fn,'name',{value:name,writable:false, configurable:true})\n\t}\n\n\n\n\t/*\n\t* Wrap a $callback in another function that prevents the original being called more than once\n\t*\n\t* @param function callback\n\t* @opt function onDupCall \tAn error-first callback for subsequent calls to @return. It can choose to return\n\t*\t\t\t\t\t\t\t or log or throw.\n\t* @throw <ble TypeError>\n\t* @return function \t\tA new function. Subsequent calls to it will return/throw same as the first call unless $onDupCall\n\t*/\n\tfunction once(callback,onDupCall){\n\t\tvX.checkTypes(['function',['function','undefined']],arguments);\n\n\t\tfunction onceCallback(...args){\n\t\t\t//We're going to store the result on a hidden prop on the returned func so it\n\t\t\t//can be used to check if the function has been called or not...\n\n\t\t\t//...so start by checking if such a prop exists, else call $callback now!\n\t\t\tif(!onceCallback.hasOwnProperty('_once')){\n\t\t\t\ttry{\n\t\t\t\t\tvar value=callback(...args);\n\t\t\t\t}catch(err){\n\t\t\t\t\tvar error=err;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(onceCallback,'_once',{configurable:true,value:[error,value]})\n\t\t\t\n\t\t\t//If this is a second call, and $onDupCall was passed...\n\t\t\t}else if(onDupCall){\n\t\t\t\t///...call it now with [error,value,[newArgs]]\n\t\t\t\treturn onDupCall(...onceCallback._once,args);\n\t\t\t}\n\n\t\t\t//If we're still running, this is either the first call or subsequent calls aren't a problem\n\t\t\t//and only return the same as the first\n\t\t\tif(error)\n\t\t\t\tthrow error;\n\t\t\telse\n\t\t\t\treturn value;\n\t\t}\n\n\t\tif(callback.name)\n\t\t\trenameFunction(onceCallback,callback.name+'_once');\n\n\t\treturn onceCallback;\n\t}\n\n\n\n\t/*\n\t* @return object \tAn object with methods that allow for manipulation of timeouts\n\t* \t@prop function callback \tThe passed in $callback (using getter, cannot be changed)\n\t* \t@prop number delay \t\t\tThe current delay (getter+setter)\t\n\t*\t@method execute(this,args) \tApply the callback immediately. If nothing is passed to it, run possible waiting action\n\t* \t@method trigger(...args)\t$callback after a timeout, ignoring repeated calls during wait\n\t* \t@method block(...args)\t\t$callback first, then ignore repeated calls during wait\n\t*\t@method clear()\t\t\t\tclear any pending timeout (regardless if .timeout() or .block() set it)\n\t*   @method debounce(...args) \tClear pending timeout if it exists, start a new one regardless\n\t* \t@method throttle(...args) \tLike block(), but the last missed call is run after the timeout\n\t* \t@method postpone\t\t\tIf a timeout exists, change it's expiration, else do nothing\n\t* \t@method expire \t\t\t\tIf a timeout exists, clear it + run $callback, else do nothing\n\t*\n\t*/\n\tfunction betterTimeout(...args){\n\t\tvar delay=aX.getFirstOfType(args,'number');\n\t\tvar callback=aX.getFirstOfType(args,'function');\n\t\tvar callAsOverride=aX.getFirstOfType(args,'object');\n\n\t\tvX.checkTypes(['function','number'],[callback,delay]);\n\n\t\t//Define private props\n\t\tvar timerId, result, after;\n\t\t\n\t\tvar obj={};\n\t\tObject.defineProperties(obj,{\n\t\t\tcallback:{get:()=>callback}\n\t\t\t,delay:{get:()=>delay, set:(val)=>{if(typeof val=='number')delay=val}}\n\t\t\t,result:{get:()=>result}\n\t\t\t,ignored:{get:()=>timerId?after:undefined}\n\t\t})\n\n\n\t\t/*\n\t\t* Call $callback and store the results. \n\t\t*\n\t\t* NOTE: if args aren't passed in here AND no calls to .timeout() or .block() have been ignored\n\t\t*\t\tthen this function will do nothing\n\t\t*\n\t\t* @opt object callAs\n\t\t* @opt array args\n\t\t*\n\t\t* @return <obj>\n\t\t*/\n\t\tobj.execute=function execute(callAs,args){\n\t\t\tif(!args){\n\t\t\t\tif(!after)\n\t\t\t\t\treturn;\n\t\t\t\targs=after[1];\n\t\t\t\tcallAs=after[0];\n\t\t\t}\n\t\t\tresult=callback.apply(callAsOverride||callAs,args);\n\t\t\tafter=undefined;\n\t\t\treturn obj;\n\t\t}\n\n\n\t\t/*\n\t\t* Prevent any upcomming calls \n\t\t*/\n\t\tobj.clear=function clear(){\n\t\t\tif(timerId){\n\t\t\t\tclearTimeout(timerId);\n\t\t\t\ttimerId=undefined;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\n\t\t/*\n\t\t* Trigger a timeout with the callback at the end, ignoring new calls during that time\n\t\t*/\n\t\tobj.trigger=function trigger(){\n\t\t\tif(!timerId){\n\t\t\t\t//Store in .after so .expire and .delay can alter the timeout but use the same args\n\t\t\t\tafter=[this,arguments];\n\t\t\t\t\n\t\t\t\ttimerId=setTimeout(()=>{\n\t\t\t\t\tclear().execute(this,arguments);\n\t\t\t\t}, delay);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\n\t\t/*\n\t\t* Invert the workflow, ie. call first then block during a timeout. \n\t\t*/\n\t\tobj.block=function block(){\n\t\t\tif(!timerId){\n\t\t\t\t//Set a blocking timeout...\n\t\t\t\ttimerId=setTimeout(clear,delay)\n\n\t\t\t\t//...then execute\n\t\t\t\texecute(this,arguments);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\n\t\t/*\n\t\t* Discard any existing timeouts, then trigger a new one\n\t\t*/\n\t\tobj.debounce=function debounce(){\n\t\t\treturn clear().trigger.apply(this,arguments);\n\t\t}\n\n\t\t/*\n\t\t* Same as .block but the last call during the timeout is run directly after. This is good when throttleing inputs\n\t\t* so the last/freshest data is received\n\t\t*/\n\t\tobj.throttle=function throttle(){\n\t\t\tif(!timerId){\n\t\t\t\t//Set a blocking timeout, but at the end of it we check if anything has been set on .after\n\t\t\t\t//in which case the callback get's run again...\n\t\t\t\ttimerId=setTimeout(()=>{\n\t\t\t\t\ttimerId=undefined;\n\t\t\t\t\texecute()\n\t\t\t\t},delay);\n\n\t\t\t\t//...but first we run it right away\n\t\t\t\tapply(this,arguments);\n\t\t\t\t  //^this also undefines .after\n\t\t\t}else{\n\n\t\t\t\t//Store missed calls in .after so the last one can be used by apply() when the timer expires ^\n\t\t\t\tafter=[this,arguments];\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\n\n\n\n\t\t/*\n\t\t* Move a current timeout further into the future. This works for any method\n\t\t*/\n\t\tobj.postpone=function postpone(){\n\t\t\tif(timerId){\n\t\t\t\tclear();\n\t\t\t\tif(after){\n\t\t\t\t\t//regardless which method set $after, now we want to execute it after a delay\n\t\t\t\t\ttrigger.apply(after[0],after[1]);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn obj;\n\t\t}\n\t\n\n\t\t/*\n\t\t* Expire a timeout now and run $callback if .after is set. This works after any method\n\t\t*/\n\t\tobj.expire=function expire(){\n\t\t\tif(timerId){\n\t\t\t\tclear().execute();\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t}\n\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/functions.util.js?");

/***/ }),

/***/ "./util/common/misc.util.js":
/*!**********************************!*\
  !*** ./util/common/misc.util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/misc.util.js\n//simpleSourceMap2=/lib/util/common/misc.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n\nmodule.exports=function export_mX({_log,stX,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\n\t\t'round':round\n\n\t\t,'getRandomInt':getRandomInt\n\n\t\t,'eventTimeout':eventTimeout\n\n\t\t,'mapping':{\n\t\t\t'prepare':prepareMap\n\t\t\t,'apply':applyMap\n\t\t}\n\n\t\t,range\n\t};\n\n\n\t/*\n\t* Round to specific number of decimal places\n\t* \thttp://www.jacklmoore.com/notes/rounding-in-javascript/\n\t*\n\t* @param number value \t\tAny value to round\n\t* @param number decimals \tInteger number of decimals\n\t*\n\t* @return number\n\t*/\n\tfunction round(value, decimals=0) {\n\t  return Number(Math.round(value+'e'+decimals)+'e-'+decimals);\n\t}\n\n\n\n\n\tfunction getRandomInt(max=1000000) {\n\t  \treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\n\n\n\n\n\t/*\n\t* Listen for an event once, calling callback if it's not fired within a given period\n\t*\n\t* @param <EventEmitter> emitter \tJust needs to have method 'once'\n\t* @param string \t\teventName\n\t* @param number \t\ttimeoutMs\n\t* @param function \t\ttimeoutCallback\n\t* @param mixed \t\t\tcallbackArg\n\t*\n\t* @return number \tThe timeout id so it can be cleared\n\t*/\n\tfunction eventTimeout(emitter,eventName,timeoutMs,timeoutCallback,callbackArg){\n\t\tvar triggered=false;\n\t\temitter.once(eventName,()=>triggered=true);\n\t\treturn setTimeout(()=>{\n\t\t\tif(triggered==false)\n\t\t\t\ttimeoutCallback(callbackArg)\n\t\t},timeoutMs)\n\t}\n\n\n\n\n\n\n\n\n\n\t/*\n\t* This function transforms a @map and @returns an object where parameter keys can be thought of\n\t* as 'aliases'(many) and parameter values are the (few) names they map to.\n\t* \n\t* @param object map\t\t\t\tKeys are the desired props, values are single aliases, \n\t*\t\t\t\t\t\t\t\t  or arrays of aliases. Example: \n\t*\t\t\t\t\t\t\t\t\t\t{'Name':'n','Age':['a','years']}\n\t* @param @opt boolean addSelf \tDefault true. If true, add entry to map that maps the desired prop \n\t*\t\t\t\t\t\t\t\t to itself (makes it easy to just lookup once)\n\t* @param @opt boolean addLower \tDefault true. If true, the lower case of each desired prop will be \n\t*\t\t\t\t\t\t\t\t  included\n\t* \n\t* @throw TypeError \t\tIf $map is poorly formated\n\t*\n\t* @return: An object where each parameter name corresponds to a string the case and spelling of which\n\t*\t\t  is the desired output when applying the prapared map. Example:\n\t*\t\t  {\n\t*\t\t \t 'Name': 'Name' \t<-- included if @addSelf = true\n\t*\t\t \t ,'name': 'Name'\t<-- included if @addLower = true\n\t*\t\t\t ,'n':'Name' \n\t*\t\t \t ,'Age':'Age', \t\t<-- included if @addSelf = true\n\t*\t\t \t ,'age':'Age', \t\t<-- included if @addLower = true\n\t*\t\t \t ,'a':'Age', \n\t*\t\t \t ,'years':'Age', \n\t*\t\t  }\n\t*/\n\tfunction prepareMap(map, addSelf=true, addLower=true){\n\n\t\tvar MAP = {}, real, alias;\n\t\ttry{\n\t\t\tfor(real in map){\n\t\t\t\tvar aliases=map[real];\n\t\t\t\tif(!Array.isArray(aliases)){\n\t\t\t\t\taliases=[aliases];\n\t\t\t\t}\n\n\t\t\t\t//First add the aliases\n\t\t\t\tfor(alias in aliases){ //eg. n=>Name\n\t\t\t\t\tMAP[alias]=real;\n\t\t\t\t\n\t\t\t\t\t//Optionally add lower case version of alias\n\t\t\t\t\tif(typeof alias=='string' && addLower){\n\t\t\t\t\t\tMAP[alias.toLowerCase()]=real;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Then optionally add lower case version of real\n\t\t\t\tif(typeof real=='string' && addLower){\n\t\t\t\t\tMAP[real]=real\n\t\t\t\t}\n\n\t\t\t\t//Then optionally add self\n\t\t\t\tif(addSelf){\n\t\t\t\t\tMAP[real]=real\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Finally, set secret prop so we can know it's already been prepared (to allow\n\t\t\t//both prepared and unprepared maps to be passed to apply)\n\t\t\tObject.defineProperty(MAP,'_hasBeenPrepared',{value:true});\n\t\t\treturn MAP\n\t\t} catch(e) {\n\t\t\t_log.throwType('Unsupported formated map passed to prepareMap():', map, e)\n\t\t}\n\t\t\n\t}\n\n\t/*\n\t* Map props on an object \n\t*\n\t* @param object data \t\n\t* @param object map \t\t\t\t\tThe object returned from prepareMap(), or an array that can \n\t*\t\t\t\t\t\t\t\t\t\t\tbe passed to it\n\t* @param boolean onlyReturnMatches \t\tIf true, only props with a map-entry will be returned\n\t* \t\n\t* @return object \t\t\t\t\t\t\n\t*/\n\tfunction applyMap(data, map, onlyReturnMatches=false){\n\t\tvX.checkTypes(['object','object'],[data,map]);\n\n\t\tvar MAP=(!map._hasBeenPrepared ? prepareMap(map) : map)\n\t\t\t,mData={}\n\t\t\t,key\n\t\t;\n\n\t\tif(onlyReturnMatches){\n\t\t\tfor(key in data){\n\t\t\t\tif(MAP[key]){\n\t\t\t\t\tmData[MAP[key]]=data[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(key in data){\n\t\t\t\tmData[MAP[key]]=data[key]\n\t\t\t}\n\t\t}\n\n\t\treturn mData\n\t}\n\n\n\n\t/*\n\t* Get a range of numbers\n\t*\n\t* @param number from\n\t* @param number to\n\t*\n\t* @return array\n\t*/\n\tfunction range(from,to){\n\t\tvX.checkTypes(['number','number'],arguments);\n\t\treturn [...Array(to+1).keys()].slice(from);\n\t}\n\n\n\n\n\n\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/misc.util.js?");

/***/ }),

/***/ "./util/common/netmask.polyfill.js":
/*!*****************************************!*\
  !*** ./util/common/netmask.polyfill.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/common/netmask.polyfil.js\n//simpleSourceMap2=/lib/util/common/netmask.polyfil.js\n/*\n* netmask (Polyfill)\n*\n* Date: Feb 2020\n*\n* This module contains the npm module 'netmask' so we don't need to depend on an external package.\n* \thttps://www.npmjs.com/package/netmask\n* \n* The module is origninally written in CoffeScript but has been transpiled using\n* \thttps://awsm-tools.com/code/coffee2js\n*\n*/\n;'use strict';\nmodule.exports=(function() {\n\tvar Netmask, ip2long, long2ip;\n\n\tlong2ip = function(long) {\n\t\tvar a, b, c, d;\n\t\ta = (long & (0xff << 24)) >>> 24;\n\t\tb = (long & (0xff << 16)) >>> 16;\n\t\tc = (long & (0xff << 8)) >>> 8;\n\t\td = long & 0xff;\n\t\treturn [a, b, c, d].join('.');\n\t};\n\n\tip2long = function(ip) {\n\t\tvar b, byte, i, _i, _len;\n\t\tb = (ip + '').split('.');\n\t\tif (b.length === 0 || b.length > 4) {\n\t\t\tthrow new Error('Invalid IP');\n\t\t}\n\t\tfor (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {\n\t\t\tbyte = b[i];\n\t\t\tif (isNaN(parseInt(byte, 10))) {\n\t\t\t\tthrow new Error(\"Invalid byte: \" + byte);\n\t\t\t}\n\t\t\tif (byte < 0 || byte > 255) {\n\t\t\t\tthrow new Error(\"Invalid byte: \" + byte);\n\t\t\t}\n\t\t}\n\t\treturn ((b[0] || 0) << 24 | (b[1] || 0) << 16 | (b[2] || 0) << 8 | (b[3] || 0)) >>> 0;\n\t};\n\n\tNetmask = (function() {\n\t\tfunction Netmask(net, mask) {\n\t\t\tvar error, i, _i, _ref;\n\t\t\tif (typeof net !== 'string') {\n\t\t\t\tthrow new Error(\"Missing `net' parameter\");\n\t\t\t}\n\t\t\tif (!mask) {\n\t\t\t\t_ref = net.split('/', 2), net = _ref[0], mask = _ref[1];\n\t\t\t}\n\t\t\tif (!mask) {\n\t\t\t\tswitch (net.split('.').length) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmask = 8;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tmask = 16;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tmask = 24;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tmask = 32;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Invalid net address: \" + net);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof mask === 'string' && mask.indexOf('.') > -1) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.maskLong = ip2long(mask);\n\t\t\t\t} catch (_error) {\n\t\t\t\t\terror = _error;\n\t\t\t\t\tthrow new Error(\"Invalid mask: \" + mask);\n\t\t\t\t}\n\t\t\t\tfor (i = _i = 32; _i >= 0; i = --_i) {\n\t\t\t\t\tif (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {\n\t\t\t\t\t\tthis.bitmask = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (mask) {\n\t\t\t\tthis.bitmask = parseInt(mask, 10);\n\t\t\t\tthis.maskLong = 0;\n\t\t\t\tif (this.bitmask > 0) {\n\t\t\t\t\tthis.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Invalid mask: empty\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.netLong = (ip2long(net) & this.maskLong) >>> 0;\n\t\t\t} catch (_error) {\n\t\t\t\terror = _error;\n\t\t\t\tthrow new Error(\"Invalid net address: \" + net);\n\t\t\t}\n\t\t\tif (!(this.bitmask <= 32)) {\n\t\t\t\tthrow new Error(\"Invalid mask for ip4: \" + mask);\n\t\t\t}\n\t\t\tthis.size = Math.pow(2, 32 - this.bitmask);\n\t\t\tthis.base = long2ip(this.netLong);\n\t\t\tthis.mask = long2ip(this.maskLong);\n\t\t\tthis.hostmask = long2ip(~this.maskLong);\n\t\t\tthis.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;\n\t\t\tthis.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);\n\t\t\tthis.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;\n\t\t}\n\n\t\tNetmask.prototype.contains = function(ip) {\n\t\t\tif (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {\n\t\t\t\tip = new Netmask(ip);\n\t\t\t}\n\t\t\tif (ip instanceof Netmask) {\n\t\t\t\treturn this.contains(ip.base) && this.contains(ip.broadcast || ip.last);\n\t\t\t} else {\n\t\t\t\treturn (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;\n\t\t\t}\n\t\t};\n\n\t\tNetmask.prototype.next = function(count) {\n\t\t\tif (count == null) {\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\treturn new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);\n\t\t};\n\n\t\tNetmask.prototype.forEach = function(fn) {\n\t\t\tvar index, lastLong, long;\n\t\t\tlong = ip2long(this.first);\n\t\t\tlastLong = ip2long(this.last);\n\t\t\tindex = 0;\n\t\t\twhile (long <= lastLong) {\n\t\t\t\tfn(long2ip(long), long, index);\n\t\t\t\tindex++;\n\t\t\t\tlong++;\n\t\t\t}\n\t\t};\n\n\t\tNetmask.prototype.toString = function() {\n\t\t\treturn this.base + \"/\" + this.bitmask;\n\t\t};\n\n\t\treturn Netmask;\n\n\t})();\n\n\treturn {ip2long,long2ip,Netmask};\n\n})()\n\n//# sourceURL=webpack:///./util/common/netmask.polyfill.js?");

/***/ }),

/***/ "./util/common/obj.util.js":
/*!*********************************!*\
  !*** ./util/common/obj.util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/promise.util.js\n//simpleSourceMap2=/lib/util/common/promise.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to OBJECTS\n*/\n\nmodule.exports=function export_oX({_log,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\t'objCreateFill':objCreateFill\n\t\t,'combineKeysValues':combineKeysValues\n\t\t,'recombineKeysValues':recombineKeysValues\n\t\t,'addUniqueItemToNestedArr':addUniqueItemToNestedArr\n\t\t,'combineUniqueNestedArrays':combineUniqueNestedArrays\n\t\t,'splitArrayItemsToObject':splitArrayItemsToObject\n\t\t,'indentStringToObject':indentStringToObject\n\t\t,'objectToLines':objectToLines\n\t\t,flattenObject\n\t\t,'hasOwnProperties':hasOwnProperties\n\t\t,'keysToLower':keysToLower\n\t\t,'subObj':subObj\n\t\t,'extract':extract\n\t\t,'emptyObject':emptyObject\n\t\t,'getFirstMatchingProp':getFirstMatchingProp\n\t\t,'nestedGet':nestedGet\n\t\t,'nestedSet':nestedSet\n\t\t,nestedAssign\n\t\t,'getChildProps':getChildProps\n\t\t,'groupChildrenByProp':groupChildrenByProp\n\t\t,'groupKeysByValue':groupKeysByValue\n\t\t,'argObjToArr':argObjToArr\n\t\t,'nestedObjToArr':nestedObjToArr\n\t\t,'forEachNestedPrimitive':forEachNestedPrimitive\n\t\t,'objToQueryStr':objToQueryStr\n\t};\n\n\n\n\n\n\tfunction objCreateFill(keys,value,copyValue=false){\n\t\tvX.checkType('array',keys);\n\n\t\tvar obj={};\n\t\tfor(let key of keys){\n\t\t\tobj[key]=copyValue ? vX.copy(value) : value;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tfunction combineKeysValues(keys,values,formatKeys=null,formatValues=null){\n\t\tvX.checkTypes(['array','array'],[keys,values]);\n\t\tif(keys.length!=values.length)\n\t\t\tthrow new Error(\"Expected both arrays to be same length, they were \"+keys.length+\" and \"+values.length);\n\n\t\tif(typeof formatKeys!='function')\n\t\t\tformatKeys=x=>x\n\t\tif(typeof formatValues!='function')\n\t\t\tformatValues=x=>x\n\n\t\tvar obj={};\n\t\tfor(let i in keys){\n\t\t\tobj[formatKeys(keys[i])]=formatValues(values[i]);\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tfunction recombineKeysValues(obj,formatKeys,formatValues){\n\t\tvX.checkType('object',obj);\n\t\treturn combineKeysValues(Object.keys(obj),Object.values(obj),formatKeys,formatValues);\n\t}\n\n\n\tfunction addUniqueItemToNestedArr(obj,key,value){\n\t\tif(!obj.hasOwnProperty(key))\n\t\t\tobj[key]=[value]\n\t\telse if(!Array.isArray(obj[key]))\n\t\t\tthrow new TypeError(\"Expected prop (\"+key+\") to be array, was:\" +typeof obj[key])\n\t\telse if(!obj[key].includes(value))\n\t\t\tobj[key].push(value);\n\n\t\treturn;\n\t}\n\n\t/*\n\t* Two objects both with nested arrays. Append unique items from source to target.\n\t*\n\t* @param array source \tEg. {a:[1,2],b[2,3,4]}\n\t* @param array target \tEg. {a:[1,6],c:[5]} \tNOTE: This array gets altered\n\t*\n\t* \t@target after: \t{a:[1,2,6],b[2,3,4],c:[5]}\n\t*\n\t* @return void\n\t*/\n\tfunction combineUniqueNestedArrays(source,target){\n\t\tfor(let key of Object.keys(source)){\n\t\t\tlet arr=typeof source[key]=='array' ? source[key] : [source[key]];\n\t\t\tif(!target.hasOwnProperty(key))\n\t\t\t\ttarget[key]=arr;\n\t\t\telse if(Array.isArray(target[key]))\n\t\t\t\t\t_log.throwType(`nested key ${key} to be array`,target[key]);\n\t\t\telse\n\t\t\t\tarr.forEach(item=>{\n\t\t\t\t\tif(!target[key].includes(item))\n\t\t\t\t\t\ttarget[key].push(item);\n\t\t\t\t})\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t* @param array[string,...] arr \tArray of key/value pairs, eg: \n\t*\t\t\t\t\t\t\t\t\t['key1=value1', 'key2=value2',...]\n\t* @param string delimiter \t\tThe character used in every item of @arr to split key/value, eg:\n\t*\t\t\t\t\t\t\t\t\t '='\n\t*\n\t* @return object \t\t\t\tFrom above example: \n\t*\t\t\t\t\t\t\t\t\t{key1:'value1', key2:'value2'}\n\t*/\n\tfunction splitArrayItemsToObject(arr,delimiter){\n\t\t//Check types, throwing on fail\n\t\tif(vX.checkTypes(['array',['string','object']],[arr,delimiter])[1]=='object')\n\t\t\tvX.instanceOf(RegExp, delimiter);\n\n\t\tvar obj={};\n\t\tvar firstErr=true;\n\t\tarr.forEach((line,i)=>{\n\t\t\ttry{\n\t\t\t\tvX.checkType('string',line);\n\n\t\t\t\t//Split on first delimiter (glueing rest together if needed)\n\t\t\t\tvar [key, ...value]=line.split(delimiter);\n\t\t\t\tobj[key]=value.join(delimiter);\n\t\t\t}catch(err){\n\t\t\t\tif(firstErr){\n\t\t\t\t\tfirstErr=false;\n\t\t\t\t\t_log.warn(\"Error parsing array for key-value pairs\");\n\t\t\t\t}\n\t\t\t\t_log.warn(\"   item \"+i+\": \"+err.message);\n\t\t\t}\n\t\t})\n\t\treturn obj;\n\t\t\n\t}\n\n\n\t/*\n\t* @param string str \tExample:\n\t*\t\t\t\t\t\t\t\"wlan0\n\t*\t\t\t\t\t\t\t\taddr 0.0.0.0\n\t*\t\t\t\t\t\t\t\thwaddr aa:aa:aa:aa:aa:aa\n\t*\t\t\t\t\t\t\t\tdetails\n\t*\t\t\t\t\t\t\t\t\ttype wifi\n\t*\t\t\t\t\t\t\teth0\n\t*\t\t\t\t\t\t\t\taddr 192.168.1.2\n\t*\t\t\t\t\t\t\t\thwaddr bb:bb:bb:bb:bb:bb\n\t*\t\t\t\t\t\t\t\"\n\t* @return object \t\tFrom above example:\n\t*\t\t\t\t\t\t\t{\n\t*\t\t\t\t\t\t\t\t'wlan0':{\n\t*\t\t\t\t\t\t\t\t\t'addr 0.0.0.0':{}\n\t*\t\t\t\t\t\t\t\t\t,'hwaddr aa:aa:aa:aa:aa:aa':{}\n\t*\t\t\t\t\t\t\t\t\t,'details':{\n\t*\t\t\t\t\t\t\t\t\t\t'type wifi'\n\t*\t\t\t\t\t\t\t\t\t}\n\t*\t\t\t\t\t\t\t\t}\n\t*\t\t\t\t\t\t\t\t,'eth0':{\n\t*\t\t\t\t\t\t\t\t\t'addr 192.168.1.2':{}\n\t*\t\t\t\t\t\t\t\t\t,'hwaddr bb:bb:bb:bb:bb:bb':{}\n\t*\t\t\t\t\t\t\t\t}\n\t*\t\t\t\t\t\t\t}\n\t*/\n\tfunction indentStringToObject(str){\n\n\t\tvar data={},len=0, curr=[data],last=data;\n\t\tstr.split('\\n').forEach(line=>{\n\t\t\tlet m=line.match(/^(\\s*)(.+)$/);\n\t\t\tif(!m) return; //skip empty lines\n\t\t\t\n\t\t\t//Determine by the length of the indentation if we work our way up or down\n\t\t\t//the object structure\n\t\t\tlet l=m[1].length;\n\t\t\tif(l>len){\n\t\t\t\t//more indent, move down by adding the last created object to the current position array\n\t\t\t\tcurr.unshift(last); \n\t\t\t}else if(l<len){\n\t\t\t\t//less indent, move up by removing the last added object to the current position array\n\t\t\t\tcurr.shift();\n\t\t\t}\n\t\t\tlen=l; //save for next round\n\n\t\t\t//create new object and set it on the current position \n\t\t\tlast={};\n\t\t\tcurr[0][m[2].trim()]=last;\n\n\t\t})\n\t\treturn data;\n\t}\n\n\n\t/*\n\t* Turn object into a string, eg:\n\t* \t\t{key1:value1,key2:value2} => key1=value1\\nkey2=value2\n\t*\n\t* @param object obj\n\t* @param string delimiter \tDelimiter to use between key and value, eg '='\n\t*\n\t* @return string\n\t*/\n\tfunction objectToLines(obj,delimiter){\n\t\treturn Object.entries(obj).map(([key,value])=>key+delimiter+value).join('\\n');\n\t}\n\n\t/*\n\t* @param object obj \tFrom    {type:{shape:'round',color:'red'},weight:4}\n\t* @opt string delim\n\t*\n\t* @throws <ble TypeError>\n\t* @return object \t\tTo \t\t{'type.shape':'round','type.color':'red',weight:4}\n\t*/\n\tfunction flattenObject(obj,delim='.'){\n\t\tvX.checkTypes(['object','string'],[obj,delim]);\n\t\tvar flat={};\n\t\tvar address=[];\n\t\tvar loop=(self)=>{\n\t\t\tObject.entries(self).forEach(([key,value])=>{\n\t\t\t\tif(vX.isPrimitive(value)){\n\t\t\t\t\tflat[address.concat(key).join(delim)]=value;\n\t\t\t\t}else{\n\t\t\t\t\taddress.push(key);\n\t\t\t\t\tloop(value);\n\t\t\t\t\taddress.pop();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tloop(obj);\n\n\t\treturn flat;\n\t}\n\n\n\n\n\t/*\n\t* Check if an object has ANY of a list of properties\n\t*\n\t* @return bool\n\t*/\n\tfunction hasOwnProperties(obj,keys,mode='any'){\n\t\tvX.checkTypes(['object','array','string'],[obj,keys,mode]);\n\t\t\n\t\tswitch(mode){\n\t\t\tcase 'any': //object contains at least one of the keys\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\n\t\t\tcase 'all': //object contains all the keys, but optionally others as well\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(!obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase 'noother': //object does not contain any other keys, but it may contain none\n\t\t\t\treturn Object.keys(obj).every(key=>keys.includes(key))\n\n\t\t\tcase 'exact':\n\t\t\t\treturn hasOwnProperties(obj,keys,'noother') && hasOwnProperties(obj,keys,'all');\n\n\t\t\tcase 'array':\n\t\t\t\tvar ret=[];\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\tret.push(keys[i]);\n\t\t\t\t}\n\t\t\t\tif(!ret.length)\n\t\t\t\t\treturn null;\n\t\t\t\telse\n\t\t\t\t\treturn ret;\n\n\t\t\tcase 'object':\n\t\t\t\tvar ret={};\n\t\t\t\tfor(var i=0; i<keys.length;i++){\n\t\t\t\t\tif(obj.hasOwnProperty(keys[i]))\n\t\t\t\t\t\tret[keys[i]]=obj[keys[i]];\n\t\t\t\t}\n\t\t\t\tif(!Object.keys(ret).length)\n\t\t\t\t\treturn null;\n\t\t\t\telse\n\t\t\t\t\treturn ret;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unrecognized mode: \"+mode);\n\n\t\t}\n\t}\n\n\t/*\n\t* Make sure all keys in an object are lower case (non-recursive)\n\t*\n\t* @param object obj\n\t* \n\t* @return object\n\t*/\n\tfunction keysToLower(obj){\n\t\treturn recombineKeysValues(obj,key=>key.toLowerCase()); \n\t}\n\n\n\t/*\n\t* Get specific keys from an object, returning a new object\n\t*\n\t* @param object obj\n\t* @param mixed \tkeys \t\t\tA single key, an array of keys, or a function to validate keys\n\t* @param bool excludeMissing \tIf true, keys that are not found on obj are not included on returned object. Else\n\t*\t\t\t\t\t\t\t\tthe returned object will have that key with value undefined\n\t* \n\t* @throws TypeError\n\t* @return object\n\t*/\n\tfunction subObj(obj,keys, excludeMissing=false){\n\t\tvar types=vX.checkTypes([['array','object'],['string','number','array','function']],[obj,keys])\n\n\t\tif(types[1]=='function'){\n\t\t\tkeys=Object.entries(obj).filter(keyvalue=>keys(keyvalue[0],keyvalue[1])).map(keyvalue=>keyvalue[0]);\n\t\t\texcludeMissing=false; //nothing to exclude\n\t\t}else if(types[1]!='array'){\n\t\t\treturn obj[keys];\n\t\t}\n\n\t\tvar rObj={};\n\t\tif(excludeMissing){\n\t\t\tkeys.forEach(key=>{\n\t\t\t\tif(obj.hasOwnProperty(key))\n\t\t\t\t\trObj[key]=obj[key]\n\t\t\t})\n\t\t}else{\n\t\t\tkeys.forEach(key=>rObj[key]=obj[key])\n\t\t}\n\n\t\treturn rObj;\n\t}\n\n\tfunction extract(obj,keys, excludeMissing){\n\t\tvar data=subObj(obj,keys,excludeMissing);\n\n\t\tif(Array.isArray(keys)||typeof keys=='function')\n\t\t\tObject.keys(data).forEach(key=>delete obj[key]);\n\t\telse\n\t\t\tdelete obj[keys];\n\n\t\treturn data;\n\t}\n\n\tfunction emptyObject(obj){\n\t\treturn extract(obj,Object.keys(obj));\n\t}\n\n\t/*\n\t* Find a value within a sub-object that matches a criteria\n\t*\n\t* @param object obj \t\t\t@see subObj\n\t* @param array keys \t\t\t@see subObj\n\t* @param @opt function crit \tDefaults to truthy value\n\t* @param @opt boolean extract \t@see subObj\n\t*\n\t* @return any|undefined \tThe first matching prop value, or undefined\n\t*/\n\tfunction getFirstMatchingProp(obj,keys,crit=null,_extract=false){\n\t\tif(!crit)\n\t\t\tcrit=(x)=>x?true:false //returns first non-empty\n\t\telse\n\t\t\tvX.checkType(['function','null'],crit)\n\n\n\t\tif(_extract)\n\t\t\tobj=extract(obj,keys,true)\n\t\telse\n\t\t\tobj=subObj(obj,keys,true)\n\n\t\treturn Object.values(obj).find(crit);\n\t}\n\n\n\n\n\n\t/*\n\t* Get a nested child from a multi-level object or array\n\t*\n\t* @param obj array|object\n\t* @param keypath array \t\t\t\t\tArray of keys, each pointing to one level deeper. NOTE: this array will be altered\n\t*\t\t\t\t\t\t\t\t\t\t\tby this function, containing any remaining keys after recursion has happened\n\t*\t\t\t\t\t\t\t\t\t\t\tto the available depth\n\t* @param bool returnLastObject \t\t\tDefault false => if a nested property doesn't exist, undefined will be returned. \n\t*\t\t\t\t\t\t\t\t\t\t\ttrue=>the last existing object will be returned and the keypath reflects\n\t*\t\t\t\t\t\t\t\t\t\t\tthe remaining keys\n\n\t* @throws TypeError \t\t\t\t\tIf either params ^ are wrong, or if [there is a non-object along keypath]\n\t* @return mixed|[mixed,false|array]  \tThe requested value, or @see $returnLastObject\n\t*/\n\tfunction nestedGet(obj,keypath,returnLastObject=false){\n\t\t// _log.traceFunc(arguments)\n\t\tvX.checkTypes([['object','array'],'array'],[obj,keypath]); //throw typeerror\n\n\t\tvar subobj=obj, address=[];\n\t\twhile(keypath.length){\n\t\t\t//Starting this loop means we're trying to go down one level...\n\t\t\tif(typeof subobj!='object')\n\t\t\t\t//...having a non-object means that's impossible, so throw an error\n\t\t\t\t_log.throw(`Cannot get nested value, non-object @ ${address.join('.')}:`,subobj, obj);\n\n\t\t\telse if(!subobj.hasOwnProperty(keypath[0])){\n\t\t\t\t//...having nothing also means that's impossible, but here we offer an option, see arg #3\n\t\t\t\tif(returnLastObject)\n\t\t\t\t\t//To know if this is not the desired position, the caller has to confirm that keypath isn't empty\n\t\t\t\t\treturn subobj;\n\t\t\t\telse\n\t\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t//Finally, there is a step down, go to it and restart loop\n\t\t\tsubobj=subobj[keypath[0]];\n\t\t\taddress.push(keypath.shift());\n\t\t\t// _log.debug(address.join('.'),subobj)\n\t\t}\n\n\t\t//At this point we've successfully navigated to the desired location, so return the value there\n\t\treturn subobj;\n\t}\n\n\n\n\t/*\n\t* Set a nested child on a multi-level object or array\n\t*\n\t* @param obj array|object\n\t* @param keys array \t\tArray of keys, each pointing to one level deeper. NOTE: this array is altered\n\t* @param mixed value \t\t\n\t* @param bool create \t\tDefault false. If true the path will be created (with objects only)\n\t*\n\t* @throws TypeError \t\tSee nestedGet.\n\t* @return mixed  \t\t\tThe value set\n\t*/\n\tfunction nestedSet(obj,keys,value,create=false){\n\t\t// _log.traceFunc(arguments);\n\t\t//First check arg#2, and use it to get the object we're setting on\n\t\tvX.checkType('array',keys); //throw typeerror\n\t\tvar key=keys.pop();\n\t\tif(!key)\n\t\t\t_log.throw(\"No keys specified, cannot set value on object: \",value,obj);\n\n\t\t//For logging vv, we need an un-altered keys array so we can determine where a nested value waa\n\t\tvar _keys=vX.copy(keys);\n\n\t\t//Get the nested object we'll be setting on (also works if $keys are now empty)\n\t\tvar subobj=nestedGet(obj,keys,true); //true=>return last existing object so we can create the \n\t\tlet address=_keys.splice(-keys.length).join(); //_keys=[1,2,3]  keys=[2,3]  =>  1.2\n\t\tif(create){\t\t\t\t\t\t\t\t\t\t\t//      rest here\n\t\t\t//If any keys didn't exist, we create them now\n\t\t\tvar k;\n\t\t\twhile(k=keys.shift()){\n\t\t\t\tsubobj[k]={}; //create the next level\n\t\t\t\tsubobj=subobj[k]; //move the \"pointer\", if you will, to that level\n\t\t\t}\n\t\t\t\n\t\t}else if(keys.length){\n\t\t\t_log.makeError(`Not creating @ '${address}':`,obj).throw();\n\t\t}\n\t\t\t\n\n\t\tif(typeof subobj!='object') //array or object works\n\t\t\t_log.throw(`Not an object @ '${address}':`,obj)\n\t\t\n\n\t\t//If we're still running here. obj will be the object we're setting on, key the prop we're setting and value \n\t\t//the value, so just get on with it and return\n\t\treturn subobj[key]=value;\n\t}\n\n\n\t/*\n\t* Assign to nested objects without overwriting non-mentioned props\n\t*\n\t* @param object target \tThe object that gets changed\n\t* @param object obj \tThe object with new data to be assigned to $target\n\t*\n\t* {type:{\t\t\t\t{type:{\t\t\t\t\t{type:{\n\t*\tshape:'round'   +     \tcolor:'blue'\t=\t\tshape:'round'\n\t*\t,color:'red'}\t\t}}\t\t\t\t\t\t\t,color:'blue'}\n\t* ,weight:4}    \t\t\t\t\t\t\t\t,weight:4}\n\t*\n\t* @throws <ble TypeError>\n\t*\n\t* @return object \t\t$target\n\t*/\n\tfunction nestedAssign(target,data){\n\t\tvX.checkTypes(['object','object'],arguments);\n\t\tvar delim='<&@%>'; //any random string that is sure not to exist in a key\n\t\tvar arr=flattenObject(data,delim);\n\t\tObject.entries(arr).forEach(([address,value])=>nestedSet(target,address.split(delim),value,'create'));\n\t\treturn target;\n\t}\n\n\n\t/*\n\t* Get prop from each nested child object in an object\n\t*/\n\tfunction getChildProps(obj,prop,onMissing){\n\t\tvar ret={}\n\t\t\t,types=vX.checkTypes([['object','array'],['string','array']],[obj,prop])\n\t\t;\n\t\t\n\t\t//So we don't have to check on every prop, do 1 of 2 loops\n\t\tif(types[1]=='string'){\n\t\t\t//...getting prop on the base object\n\t\t\tObject.entries(obj).forEach(([key,child])=>{\n\t\t\t\tif(child.hasOwnProperty(prop))\n\t\t\t\t\tret[key]=child[prop]\n\t\t\t\telse if(onMissing!=undefined)\n\t\t\t\t\tret[key]=onMissing\n\t\t\t\t//if onMissing is not set, the key is not included\n\t\t\t})\n\t\t}else{\n\t\t\t//Get nested prop\n\t\t\tObject.entries(obj).forEach(([key,child])=>{\n\t\t\t\ttry{\n\t\t\t\t\tvar val=nestedGet(child,prop);\n\t\t\t\t}catch(err){\n\t\t\t\t\tval=undefined\n\t\t\t\t}\n\n\t\t\t\t//Loop early if the prop doesn't exist and arg#3 is undef\n\t\t\t\tif(val==undefined && onMissing==undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tret[key]=val\n\t\t\t})\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* From: \n\t*\t{\t\t\t\t\t\t\t\t\t\t\t[\n\t*\t\tBob:{age:44,gender:'Male'}\t\t\t\t\t0:{age:44,gender:'Male'}\n\t*\t\t,Steve:{age:82,gender:'Male'}\t\t\t\t,1:{age:82,gender:'Male'}\n\t*\t\t,Sue:{arge:24,gender:'Female'}\t\t\t\t,2:{arge:24,gender:'Female'}\n\t*\t}\t\t\t\t\t\t\t\t\t\t\t]\n\t*\n\t* To:\n\t*\t{\t\t\t\t\t\t\t\t\t\t\t{\n\t*\t\tMale:{\t\t\t\t\t\t\t\t\t\tMale:{\n\t*\t\t\tBob:{age:44,gender:'Male'}\t\t\t\t\t0:{age:44,gender:'Male'}\n\t*\t\t\t,Steve:{age:82,gender:'Male'}\t\t\t\t,1:{age:82,gender:'Male'}\n\t*\t\t}\t\t\t\t\t\t\t\t\t\t\t}\n\t*\t\t,Female:{\t\t\t\t\t\t\t\t\t,Female:{\n\t*\t\t\tSue:{age:24,gender:'Female'}\t\t\t\t2:{age:24,gender:'Female'}\n\t*\t\t}\t\t\t\t\t\t\t\t\t\t\t}\n\t*\t}\t\t\n\t*\n\t* @param \t\t\t\t\t\t\t\t\t\n\t*/\n\tfunction groupChildrenByProp(obj,prop,...optional){\n\t\tvX.checkTypes([['object','array'],'string'],[obj,prop])\n\t\t\n\t\tvar onMissing='undefined',extract=false;\n\t\toptional.forEach((x,i)=>{\n\t\t\tswitch(typeof x){\n\t\t\t\tcase 'boolean': \n\t\t\t\t\textract=x; break;\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'string': \n\t\t\t\t\tif(x=='extract')\n\t\t\t\t\t\textract=true;\n\t\t\t\t\telse\n\t\t\t\t\t\tonMissing=x; \n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.makeError(`Arg #${i+2} can be string/number/boolean, got:`,x).throw('TypeError');\n\t\t\t}\n\t\t})\n\n\t\tvar ret={};\n\t\tObject.entries(obj).forEach(([key,child])=>{\n\t\t\tvar v=child[prop]||onMissing;\n\t\t\tv=(typeof v=='number'?v:String(v));\n\t\t\tret[v]=ret[v]||{}\n\t\t\tret[v][key]=child;\n\t\t\tif(extract) delete child[prop];\n\t\t})\n\t\treturn ret;\n\t}\n\n\t/*\n\t* From:\n\t*\t{\n\t*\t\tfoo:'bar'\n\t*\t\t,cat:true\n\t*\t\t,hat:'bar'\n\t*\t}\n\t*\n\t*  To:\n\t*  \t{\n\t*\t\tbar:['foo','hat']\n\t*\t\t,true:['cat']\n\t*  \t}\n\t*/\n\tfunction groupKeysByValue(obj){\n\t\tvX.checkType(['object','array'],obj)\n\t\tvar grouped={},key;\n\t\tfor(key in obj){\n\t\t\tif(!grouped.hasOwnProperty(key))\n\t\t\t\tgrouped[key]=[];\n\t\t\tgrouped[key].push(obj[key]);\n\t\t}\n\t}\n\n\n\n\n\tfunction argObjToArr(obj){\n\t\tvar arr=[], key;\n\n\t\tfor(key in obj){\n\t\t\tarr.push(key);\n\t\t\tarr.push(obj[key]);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/*\n\t* Turn object of nested objects into array of nested objects, moving the key in the parent object\n\t* into each child\n\t*\n\t* @param object obj\n\t* @param string propName\n\t*\n\t* @return array\n\t*/\n\tfunction nestedObjToArr(obj, propName='id'){\n\t\tvar key, arr=[];\n\t\tfor(key in obj){\n\t\t\tlet x={};\n\t\t\tx[propName]=key;\n\t\t\tarr.push(Object.assign(x,obj[key]));\n\t\t}\n\t\treturn arr;\n\t}\n\n\t/*\n\t* @param object|array obj \n\t* @param function callback \tWill be called with the current object and the key\n\t*\n\t* @return object|array \t\tThe passed in $obj \t\t\n\t*/\n\tfunction forEachNestedPrimitive(obj,callback){\n\t\tvX.checkType(['object','array'],obj);\n\t\tfunction recurs(obj){\n\t\t\tfor(let key in obj){\n\t\t\t\tif(vX.checkType(['object','array'],obj[key],true))\n\t\t\t\t\trecurs(obj[key]);\n\t\t\t\telse\n\t\t\t\t\tcallback(obj,key);\n\t\t\t}\n\t\t}\n\t\trecurs(obj);\n\t\treturn obj;\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Turn an object into a legal query string\n\t*\n\t* @param object obj \tEg. {hello:\"bob\",foo:[\"bar\",\"car\"]}\n\t*\n\t* @see string.util.js:queryStrToObj()\n\t*\n\t* @throw <ble.TypeError>\n\t* @return string \t\tEg. \"hello=bob&foo[]=bar,car\". NOTE: no leading '?' or '#'\n\t*/\n\tfunction objToQueryStr(obj){\n\t\tvX.checkType('object',obj);\n\t\tvar parts=[],key,value;\n\t\tfor(key in obj){\n\t\t\tvalue=obj[key];\n\t\t\t\n\t\t\t//For all-primitive, arrays we use the special syntax: key[]=item1,item2\n\t\t\tif(Array.isArray(value) && vX.allPrimitive(value)){\n\t\t\t\tkey+='[]'\n\t\t\t\tvalue=value.join(',');\n\t\t\t}\n\n\t\t\tif(typeof value=='object'){\n\t\t\t\tvalue=JSON.stringify(obj);\n\t\t\t}\n\n\t\t\t//Empty string, null and undefined all get turned into empty string\n\t\t\tif(vX.isEmpty(value,null)){ //null is normally considered non-empty\n\t\t\t\tvalue=''\n\t\t\t}\n\t\t\tparts.push(key+'='+encodeURIComponent(value));\n\t\t}\n\t\treturn parts.join('&');\n\t}\n\n\n\n\treturn _exports;\n\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/obj.util.js?");

/***/ }),

/***/ "./util/common/promise.util.js":
/*!*************************************!*\
  !*** ./util/common/promise.util.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/promise.util.js\n//simpleSourceMap2=/lib/util/common/promise.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to PROMISES\n*/\n \n\nmodule.exports=function export_pX({_log,vX}){\n\n\n\t//Export\n\tvar _exports={\n\t\t'sleep':sleep\n\t\t,'toPromise':toPromise\n\t\t,'applyPromise':applyPromise\n\t\t,'wrapFuncInPromise':wrapFuncInPromise\n\t\t,'awaitAllPromises':awaitAllPromises\n\t\t,'firstResolved':firstResolved\n\t\t,'InspectablePromise':InspectablePromise\n\t\t,'promiseTimeout':promiseTimeout\n\t\t,'rejectTimeout':rejectTimeout\n\t\t,'exposedPromise':exposedPromise\n\t\t,'groupPromises':groupPromises\n\t\t,'thenCallback':thenCallback\n\t\t,'promiseAlways':promiseAlways\n\t}\n\n\n\t/*\n\t* Simulate sleeping by creating a promise that resolves x ms later\n\t*\n\t* NOTE: This function should be called with the 'await' prefix from within an 'async' function\n\t* \n\t* @param integer ms \tThe number of milliseconds to sleep\n\t* @param bool \t log \tIf true, a message will be logged to the console before and after sleeping\n\t*\n\t* @return Promise  \t\t\n\t*/\n\tfunction sleep(ms,returnValue=undefined,log=null){\n\t\tif(log && log instanceof _log)\n\t\t\tlog.debug(\"Going to sleep for \"+ms+\" ms...\");\n\n\t    return new Promise(resolve=>{\n\t        setTimeout(()=>{\n\t        \tif(log && log instanceof _log)\n\t        \t\tlog.debug('...waking up');\n\t        \t\n\t        \tresolve(returnValue);\n\t        },ms)\n\t    })\n\t}\n\n\n\t/*\n\t* Turn smth into a promise. \n\t*\n\t* @param function|<Promise>|any x \tNOTE: if function, it will be called\n\t*\n\t* @return <Promise> \tDepending on what's passed in, this will return:\n\t*\t\t<Promise> --> same promsie\n\t*\t\tfunction --> executes function inside a promise, then returns the promise\n\t* \t\tany --> same variable, wrapped in resolved promise\n\t*/\n\tfunction toPromise(x){\n\t\tif(x instanceof Promise)\n\t\t\treturn x\n\t\telse if(typeof x =='function')\n\t\t\treturn applyPromise(x)\n\t\telse\n\t\t\treturn Promise.resolve(x);\n\t}\n\n\n\t/*\n\t* Call a function and return a promise that resolves/rejects with result\n\t*/\n\tfunction applyPromise(func,args,callAs=undefined){\n\t\ttry{\n\t\t\tvX.checkType('function',func);\n\t\t\t\n\t\t\tif(vX.varType(args)!='array')\n\t\t\t\targs=[args];\n\n\t\t\tvX.checkType(['object','null','undefined'],callAs);\n\n\t\t\treturn new Promise(async function _applyPromise(resolve,reject){\n\t\t\t\ttry{\n\t\t\t\t\tvar data=await func.apply(callAs,args);\n\t\t\t\t\tresolve(data);\n\t\t\t\t}catch(err){\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}catch(err){\n\t\t\treturn _log.reject('Failed to wrap function in promise.',err);\n\t\t}\n\t}\n\n\t/*\n\t* Wrap a function in another function that ensures the returned value\n\t* will be a Promise.\n\t*\n\t* NOTE: this does NOT call the function, only wraps it for future calls\n\t*\n\t* @param function func\n\t* @param object callAs\n\t*\n\t* @return function\n\t*/\n\tfunction wrapFuncInPromise(func,callAs){\n\t\tvX.checkType('function',func);\n\t\treturn (function(...args){\n\t\t\ttry{\n\t\t\t\tPromise.resolve(func.apply(callAs||this||null,args))\n\t\t\t}catch(err){\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\t\t})\n\t}\n\n\n\n\n\n\n\t/*\n\t* Wait for all promises to finish (not like Promise.all that rejects on the first reject)\n\t*\n\t* @param array promises \tAn array of Promise objects\n\t* @param array options \t\tOptional. Array of string option flags. Available are:\n\t*\t\t'flatten' \t\t- Un-nest recursive/nested calls to this function\n\t*\t\t'alwaysResolve' - Even if some @promises reject, resolve with retObj (object)\n\t*\t\t'onlyResolved' \t- Even if some @promises reject, resolve with retObj.resolved (array)\n\t*\t\t'logRejected' \t- Log all the rejected promises\n\t* \t\t'timeout' \t\t- This rejects early if timeout reached. Next item in array must be number of ms. \n\t*\t\t\t\t\t\t\tNOTE: promises will keep executing after timeout fires\n\t*\t\t'array' \t\t- Return array of arrays (@see retObj.all)\n\t*\t\t\n\t*\n\t* @return Promise(array|object) \t\t@see @options. Default: If any @promises are rejected this rejects with an object \n\t*\t\t\t\t\t\t\t\t\t\twith props 'resolved', 'rejected' (arrays of resulting values with indexes retained \n\t*\t\t\t\t\t\t\t\t\t\tfrom @promises) and 'all' (array or arrays [bool, value]). If all @promises resolve\n\t*\t\t\t\t\t\t\t\t\t\tthis resolve with an array of those values.\n\t*/\n\tfunction awaitAllPromises(promises,options=[]){\n\n\t\t_log.makeEntry('note',\"TODO: replace call to awaitAllPromises() with groupPromises()\")\n\t\t\t.changeWhere(1).highlight('blue');\n\n\t\tvX.checkTypes(['array','array'],[promises,options]);\n\n\t\tvar anyErrors=false;\n\n\t\t//Prepare the return object outside main promise so we can reject with it if option timeout triggers\n\t\tvar retObj={\n\t\t\tresolved:[]\n\t\t\t,rejected:[]\n\t\t\t,all:[] //array of arrays, [result(true/false), value]\n\t\t\t,remaining:promises.length\n\t\t\t,promises:promises.map(toPromise) //make sure any functions get called and wrapped in promises\n\t\t\t,err:null\n\t\t\t,awaitAllPromises:null\n\t\t};\n\n\t\t//Loop through all promises and wrap them so they all...\n\t\tvar wrappedPromises=retObj.promises.map(p=>\n\t\t\tp.then(\n\t\t\t\tdata=>[true, data]\n\t\t\t\t,err=>{\n\t\t\t\t\tanyErrors=true;\n\t\t\t\t\treturn [false, err];\n\t\t\t\t}\n\t\t\t) //...resolve with an array [result, value]\n\t\t\t.then(arr=>{retObj.remaining-=1;return arr}) //...decrease 'remaining' counter (good if timeout used)\n\t\t);\n\n\t\t//...^^ array can now be passed to Promise.all without it finishing on the first reject\n\t\tretObj.awaitAllPromises=Promise.all(wrappedPromises).then(retArr=>{\t//because we handled everything ^^ => nothing here will fail\n\t\t\ttry{\n\n\t\t\t\t//Before we do anything else, if we want to flatten (usefull if this func is called multiple times)...\n\t\t\t\tif(options.indexOf('flatten')>-1){\n\t\t\t\t \t//...check if any of the promises produced a value containing the special flag we set below for \n\t\t\t\t \t//this very purpose. NOTE: this resets the indexes so they mean nothing...\n\t\t\t\t\tvar tmp=[];\n\t\t\t\t\tretArr.forEach(([success,val])=>{\n\t\t\t\t\t\tswitch(val.__awaitAllPromises__){\n\t\t\t\t\t\t\tcase 'mixed_array':\n\t\t\t\t\t\t\t\ttmp=tmp.concat(val);\n\t\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\t\ttmp=tmp.concat(val.rejected.map(v=>[false,v]));\n\t\t\t\t\t\t\t\tval=val.resolved; // same handling vv, don't break;\n\t\t\t\t\t\t\tcase 'resolved_array':\n\t\t\t\t\t\t\t\ttmp=tmp.concat(val.map(v=>[true,v]));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ttmp.push([success,val]); \n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tretArr=tmp;\n\t\t\t\t}\n\n\t\t\t\t//Set on return obj\n\t\t\t\tretObj.all=retArr;\n\t\t\t\t\n\n\t\t\t\t//Split resolved/rejected and set on return obj\n\t\t\t\tretArr.forEach(([success,val],i)=>{\n\t\t\t\t\tif(success==true)\n\t\t\t\t\t\tretObj.resolved[i]=val; \t//NOTE: since keys are not consecutive, console.log will look eg.  \n\t\t\t\t\telse\t\t\t   \t\t\t\t// \t\t\t[<4 empty items>,'foo',<2 empty items>,'bar']\n\t\t\t\t\t\tretObj.rejected[i]=val;\n\t\t\t\t});\n\n\t\t\t\t//If any ^^ rejected, set an error that says so \n\t\t\t\tif(retObj.rejected.length && !retObj.err) //don't overwrite timeout err set vv\n\t\t\t\t\tretObj.err='The following promises rejected: '+Object.keys(retObj.rejected).join(',');\n\n\n\t\t\t\t//To enable the functionality of 'flatten' option, add a flag on both object and arrays ^^\n\t\t\t\tObject.defineProperty(retObj.resolved,'__awaitAllPromises__',{value:'resolved_array'});\n\t\t\t\tObject.defineProperty(retObj,'__awaitAllPromises__',{value:'object'});\n\t\t\t\tObject.defineProperty(retArr,'__awaitAllPromises__',{value:'mixed_array'});\n\t\t\t\t// retObj.rejected.prototype.__awaitAllPromises__=true; //not needed because it's never returned...\n\n\n\t\t\t\t//If we want to log all rejected\n\t\t\t\tif(options.indexOf('logRejected')>-1){\n\t\t\t\t\tvar l=retObj.promises.length;\n\t\t\t\t\tretObj.rejected.forEach((err,i)=>_log.makeError(err)\n\t\t\t\t\t\t.addHandling(`This was promise ${i+1} of ${l} passed to awaitAllPromises().`).exec());\n\t\t\t\t}\n\n\t\t\t\tif(options.indexOf('array')>-1)\n\t\t\t\t\treturn anyErrors ? Promise.reject(retArr) : Promise.resolve(retArr);\n\n\t\t\t\telse if(options.includes('alwaysResolve'))\n\t\t\t\t\treturn Promise.resolve(retObj);\n\n\t\t\t\telse if(options.indexOf('onlyResolved')>-1 || !anyErrors)\n\t\t\t\t\t//Grab only the resolved ones as array(retain index)(may be empty array), and resolve\n\t\t\t\t\treturn Promise.resolve(retObj.resolved);\n\n\t\t\t\telse\n\t\t\t\t\treturn Promise.reject(retObj)\n\n\t\t\t}catch(err){\n\t\t\t\t_log.error(\"BUGBUG awaitAllPromises():\",err);\n\t\t\t\treturn Promise.reject(retObj);\n\t\t\t}\n\t\t})\n\n\t\tvar i=options.indexOf('timeout')\n\t\tvar timeout=options[i+1];\n\t\tif(i>-1 && typeof timeout=='number'){\n\t\t\treturn Promise.race([\n\t\t\t\tretObj.awaitAllPromises\n\t\t\t\t,sleep(timeout).then(()=>{\n\t\t\t\t\tretObj.err='timeout'\n\t\t\t\t//TODO 2019-09-13: This should instead prompt ^^ to finish in the same way it would have otherwise...\n\t\t\t\t//\t\t\t\t\tso at least we get the data we have...\n\t\t\t\t\treturn Promise.reject(retObj);\n\t\t\t\t})\n\t\t\t]);\n\n\t\t}else\n\t\t\treturn retObj.awaitAllPromises;\n\n\t\t\n\t}\n\n\n\n\t/*\n\t* @return Promise(mixed,err)\tResolves with value of first resolved promise, rejects if none resolve\n\t*/\n\tfunction firstResolved(promises,logRejected=false){\n\t\tvar stack=new Error().stack; //to use in error below vv\n\n\t\treturn new Promise(function _firstResolved(resolve,reject){\n\t\t\tvX.checkTypes(['array','boolean'],[promises,logRejected]);\n\n\t\t\tlet l=promises.length, errs=[];\n\t\t\tvar e=0,success=false;\n\t\t\tpromises.map(p=>toPromise(p) //make sure any functions get called and wrapped in promises\n\t\t\t\t.then(\n\t\t\t\t\tdata=>{\n\t\t\t\t\t\tif(!success){\n\t\t\t\t\t\t\tsuccess=true;\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}else if(logRejected){\n\t\t\t\t\t\t\tlog.note(\"More than one promise resolved:\",data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t,err=>{\n\t\t\t\t\t\t//Log or save error\n\t\t\t\t\t\tif(logRejected)\n\t\t\t\t\t\t\tlog.error(err);\n\t\t\t\t\t\telse if(!success)\n\t\t\t\t\t\t\terrs.push(err);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//If all promises have finised and we still don't have success, reject\n\t\t\t\t\t\te++\n\t\t\t\t\t\tif(e>=l && !success){\t\n\t\t\t\t\t\t\treject(log.makeError(`All ${l} promises rejected.`,\n\t\t\t\t\t\t\t\tlogRejected?\"See previous logs\":errs).setStack(stack)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t) \n\t\t\t)\n\t\t})\n\t}\n\n\n\n\t/*\n\t* @constructor\n\t*/\n\tfunction InspectablePromise(promise){\n\t\tthis.status='pending';\n\t\tthis.result=undefined;\n\n\t\tvar {promsie:promise2,resolve,reject}=exposedPromise();\n\n\t\tvar _private={\n\t\t\tresolvedHandler:null\n\t\t\t,rejectHandler:null\n\t\t}\n\n\n\t\t//When the actual promise resolves/rejects, just store the result\n\t\tpromise.then(\n\t\t\t\tdata=>{\n\t\t\t\t\tif(this.status=='pending'){\n\t\t\t\t\t\tthis.status='resolved';\n\t\t\t\t\t\tthis.result=data;\n\t\t\t\t\t\tif(typeof _private.resolveHandler=='function')\n\t\t\t\t\t\t\tresolve(_private.resolveHandler(data));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t,err=>{\n\t\t\t\t\tif(this.status=='pending'){\n\t\t\t\t\t\tthis.status='rejected';\n\t\t\t\t\t\tthis.result=err;\n\t\t\t\t\t\tif(typeof _private.rejectHandler=='function')\n\t\t\t\t\t\t\tresolve(_private.rejectHandler(err));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t;\n\n\t\t//Bring these methods to surface\n\t\tthis.then=(resolveHandler,rejectHandler)=>{\n\n\t\t\tswitch(this.status){\n\t\t\t\tcase 'pending':\n\t\t\t\t\t_private.resolveHandler=resolveHandler;\n\t\t\t\t\t_private.rejectHandler=rejectHandler;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'resolved':\n\t\t\t\t\tif(typeof resolveHandler=='function')\n\t\t\t\t\t\tresolve(resolveHandler(this.result));\n\t\t\t\tcase 'timeout':\n\t\t\t\tcase 'rejected':\n\t\t\t\t\tif(typeof rejectHandler=='function')\n\t\t\t\t\t\treturn resolve(rejectHandler(this.result))\n\t\t\t\t\telse \n\t\t\t\t\t\treturn reject(this.result);\n\n\t\t\t}\n\n\t\t\treturn promise2;\n\t\t}\n\n\t\tthis.catch=(rejectHandler)=>{\n\t\t\tif(typeof rejectHandler=='function'){\n\t\t\t\tif(this.status=='rejected')\n\t\t\t\t\tresolve(rejectHandler(this.result))\n\t\t\t\telse \n\t\t\t\t\t_private.rejectHandler=rejectHandler;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn promise2;\n\t\t}\n\t}\n\n\n\n\n\n\t/*\n\t* Add timeout to a promise or function (func will be called)\n\t*\n\t* @return Promise(any, any|Promise)\n\t*/\n\tfunction promiseTimeout(promise,timeout=1,rejectValue='timeout'){\n\t\tpromise=toPromise(promise);\n\t\treturn Promise.race([\n\t\t\tpromise\n\t\t\t,sleep(timeout).then(()=>{\n\t\t\t\tif(arguments.length==3){\n\t\t\t\t\t//Since we're abandoning it, we can't have it fail async silently...\n\t\t\t\t\tpromise.catch(_log.error); \n\t\t\t\t\treturn Promise.reject(rejectValue)\n\t\t\t\t}else{\n\t\t\t\t\t//rejecting with promise object doesn't wait for it to finish, but the caller\n\t\t\t\t\t//can add their own handling to it\n\t\t\t\t\treturn Promise.reject(promise) \n\t\t\t\t}\n\n\t\t\t})\n\t\t]);\n\t\t\n\t}\n\n\n\n\n\n\n\t/*\n\t* Add timeout ability given the resolve/reject functions of a Promise. Said timeout can easily be cleared (@see return)\n\t*\n\t* @return object{resolve,reject,clear} \tReturns 3 functions, new resolve and reject, and a clear timeout\n\t*/\n\tfunction rejectTimeout(resolve,reject,timeout){\n\t\tvX.checkTypes(['function','function','number'],[resolve,reject,timeout]);\n\n\t\t// console.log('setting timeout');\n\t\tlet id=setTimeout(()=>{\n\t\t\t// console.log('rejected about to time out');\n\t\t\treject('timeout');\n\t\t},timeout);\n\n\t\tvar clear=()=>{clearTimeout(id);};\n\t\t\n\t\t// console.log('creating new resolve');\n\t\tvar newResolve=function(x){\n\t\t\t// console.log('new resolve called');\n\t\t\tclearTimeout(id);\n\t\t\tresolve(x);\n\t\t}\n\n\t\tvar newReject=function(x){\n\t\t\tclearTimeout(id);\n\t\t\treject(x);\t\n\t\t}\n\t\t// console.log('returning new resolve');\n\t\treturn {resolve:newResolve,reject:newReject,clear:clear};\n\t}\n\n\n\t/*\n\t* Create a Promise, breakout resolve and reject, return as object. That way you can return the promise while\n\t* keeping resolve/reject to use async\n\t*\n\t* @return object{promise,resolve,reject,callback[,clear]}\n\t*/\n\tfunction exposedPromise(timeout=null){\n\t\tvar inspect={status:'pending',result:undefined,done:false}\n\t\t\t,ret={inspect}\n\t\t\t,promise = new Promise((resolve,reject)=>{\n\t\t\t\tret.resolve=resolve;\n\t\t\t\tret.reject=reject;\n\t\t\t})\n\t\t;\n\n\t\tret.promise=promise.then(\n\t\t\tdata=>{ret.inspect.done=true;ret.inspect.status='resolved';ret.inspect.result=data;return data}\n\t\t\t,err=>{ret.inspect.done=true;ret.inspect.status='rejected';ret.inspect.result=err;return Promise.reject(err)}\n\t\t);\n\n\n\t\tif(typeof timeout=='number'){\n\t\t\tObject.assign(ret,rejectTimeout(ret.resolve,ret.reject,timeout));\n\t\t}\n\n\n\t\tret.callback=function(err,data){return err ? ret.reject(err) : ret.resolve(data)};\n\n\t\treturn ret;\n\t}\n\n\n\n\t/*\n\t* Exposes a group of promises, see @return\n\t*\n\t* @param array promises \tAll items will be sent to @see toPromise()\n\t* @param @opt <BetterLog>   Will log.error(reject) and log.trace(resolve)\n\t* @param @opt <Emitter>  \tAny object with 'emit' method. Emits 'resolve','reject','finished'\n\t*\n\t* @return object \tSee top and bottom of function body\n\t*/\n\tfunction groupPromises(promises,...optional){\n\t\t\n\t\tvX.checkTypes(['array'],[promises]); //use typeS so it throws 'arg #1...'\n\n\t\t//Grab optional args\n\t\tvar i=optional.length-1,log,emitter;\n\t\tfor(i;i>=0;i--){\n\t\t\tlet x=optional[i];\n\t\t\tif(x && typeof x=='object'){\n\t\t\t\tif(x.constructor.name=='BetterLog')\n\t\t\t\t\tlog=x;\n\t\t\t\telse if(typeof x.emit=='function')\n\t\t\t\t\temitter=x;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Make sure we have an array of promises. This will call any functions, wrap any values etc.\n\t\tpromises=promises.map(toPromise)\n\n\t\t//Prepare the return object \n\t\tvar r={\n\t\t\tresolved:[]  \t//array[any] - indexes match $promises (implies holes), values are resolved data\n\t\t\t,rejected:[]    //array[any] - indexes match $promises (implies holes), values are rejected err\n\t\t\t,all:[] \t\t//array[any] - indexes match $promises, [[result(true/false), value],...]\n\t\t\t,promises: promises  //array[<Promise>]\n\t\t\t,err:null \t\t //string - 'x of y promises rejected, z remaining'\n\t\t};\t\n\t\tObject.defineProperty(r,'remaining',{enumerable:true,get:()=>{return r.promises.length-Object.keys(r.all).length}});\n\n\t\t//2019-11-28: NO, do not do this vv. If you do this r.promise never resolves... for some reason\n\t\t//Add shortcuts to...\n\t\t// r.then=r.promise.then.bind(r.promise)\n\t\t// r.catch=r.promise.catch.bind(r.promise)\n\n\n\t\t//Loop through the promises and handle, ie. creating a new array of promises \n\t\t//that will all resolve AND at the same time populate the arrays of the return obj\n\t\tlet l=r.promises.length;\n\t\tvar handledPromises=r.promises.map((groupedPromise,i)=>groupedPromise\n\t\t\t.then(\n\t\t\t\tresolved=>{\n\t\t\t\t\tr.resolved[i]=resolved; \n\t\t\t\t\tr.all[i]=[true, resolved]\n\t\t\t\t\t\n\t\t\t\t\tif(log)\n\t\t\t\t\t\tlog.trace(`Promise #${i} resolved (${r.remaining} remaining) with:`,resolved);\n\t\t\t\t\tif(emitter)\n\t\t\t\t\t\temitter.emit('resolve',resolved,i)\n\t\t\t\t}\n\t\t\t\t,rejected=>{\n\t\t\t\t\tr.rejected[i]=rejected; \n\t\t\t\t\tr.all[i]=[false, rejected]\n\n\t\t\t\t\t\n\t\t\t\t\tif(log)\n\t\t\t\t\t\tlog.makeError(rejected).addHandling(`Promise ${i+1} rejected (${r.remaining} remaining)`).exec();\n\t\t\t\t\tif(emitter)\n\t\t\t\t\t\temitter.emit('reject',rejected,i);\n\n\t\t\t\t\tvar msg=`${Object.keys(r.rejected).length} of ${l} promises rejected`\n\t\t\t\t\tif(r.remaining)\n\t\t\t\t\t\tmsg+=`, ${r.remaining} remaining`\n\t\t\t\t\tr.err=msg;\n\t\t\t\t}\n\t\t\t) \n\t\t\t.then(function allFinished(){\n\t\t\t\tif(r.remaining<1&&log){\n\t\t\t\t\tlog.trace(\"All grouped promises have finished\");\n\t\t\t\t\tif(emitter)\n\t\t\t\t\t\temitter.emit('finished',r);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\t//Finally, add a promise that resolves/rejects when all promises have finished\n\t\tr.promise=Promise.all(handledPromises).then(()=>(r.err?Promise.reject(r):r)) \n\n\n\t\treturn r;\n\t}\n\n\t\t\n\n\n\n\t/*\n\t* Call a callback on both success/fail in a promise flow, returning whatever the callback returns\n\t*\n\t* @param <Promise>|any promise \n\t* @param function(err,data) callback\n\t*\n\t* @return Promise  \t\t\t\n\t*/\n\tfunction thenCallback(promise,callback){\n\t\treturn Promise.resolve(promise).then(\n\t\t\tdata=>callback(null,data)\n\t\t\t,err=>callback(err)\n\t\t);\n\t}\n\n\n\t/*\n\t* Call a callback on both success/fail in a promise flow, resolveing/rejecting with the same value\n\t* that was passed in, ie. response from callback will be ignored\n\t*\n\t* @param <Promise>|any promise \t\t\t\n\t* @param function(err,data) callback\n\t*\n\t* @return Promise  \t\t\t\n\t*/\n\tfunction promiseAlways(promise,callback){\n\t\treturn Promise.resolve(promise).then(\n\t\t\tdata=>{callback(null,data); return data}\n\t\t\t,err=>{callback(err); return Promise.reject(err)}\n\t\t);\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/promise.util.js?");

/***/ }),

/***/ "./util/common/string.util.js":
/*!************************************!*\
  !*** ./util/common/string.util.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/string.util.js\n//simpleSourceMap2=/lib/util/common/string.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n\nmodule.exports=function export_stX({_log,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\tmd5hash\n\t\t,formatString\n\t\t,firstToUpper\n\t\t,firstToLower\n\t\t,toLower\n\t\t,trim\n\t\t,substring\n\t\t,replaceAll\n\t\t,escapeRegExp\n\t\t,regexpAll\n\t\t,limitString\n\t\t,split\n\t    ,splitAt\n\t    ,indexWords\n\t    ,linuxTableToObjects\n\t    ,wrapInBashColor\n\t    ,progressBar\n\t    ,queryStrToObj\n\t\t,dashToCamel\n\t\t,randomString\n\t\t,getUniqueString\n\t};\n\n\n\t/*\n\t* Get hexdec encoded md5 sum of string\n\t*\n\t* @param string str\n\t*\n\t* @return string \t\n\t*/\n\tfunction md5hash(str){\n\t\tif(typeof CryptoJS=='undefined')\n\t\t\tthrow new Error(\"Cannot find CryptoJS\");\n\t\tif(typeof str != 'string')\n\t\t\tthrow new TypeError(\"Can only hash strings\")\n\n\t\tvar hash = CryptoJS.MD5(str);\n\t\treturn hash.toString(CryptoJS.enc.hex);\n\t}\n\n\n\t/*\n\t* Format a string\n\t*\n\t* @param string format\n\t* @param string str\n\t*\n\t* @return string \t\tThe formated $str, or an empty string if no such format exists or\n\t*\t\t\t\t\t\t$str wasn't a string\n\t*/\n\tfunction formatString(format,str){\n\t\tif(typeof str!='string')\n\t\t\treturn '';\n\n\t\tswitch(format){\n\t\t\tcase 'firstToUpper':\n\t\t\tcase 'firstBig':\n\t\t\tcase 'capitalize':\n\t\t\t\treturn firstToUpper(str);\n\t\t\tcase 'firstToLower':\n\t\t\tcase 'firstSmall':\n\t\t\t\treturn firstToLower(str);\n\t\t\tcase 'toLowerCase':\n\t\t\tcase 'toLower':\n\t\t\tcase 'lower':\n\t\t\tcase 'low':\n\t\t\tcase 'small':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'toUpperCase':\n\t\t\tcase 'toUpper':\n\t\t\tcase 'upper':\n\t\t\tcase 'up':\n\t\t\tcase 'big':\n\t\t\tcase 'large':\n\t\t\tcase 'capitals':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/*\n\t* Capitalize first letter of string\n\t*\n\t* @param string str\n\t*\n\t* @return string\n\t*/\n\tfunction firstToUpper(str){\n\t\treturn str.charAt(0).toUpperCase() + str.slice(1);\n\t}\n\n\t/*\n\t* Un-capitalize first letter of string\n\t*\n\t* @param string str\n\t*\n\t* @return string\n\t*/\n\tfunction firstToLower(str){\n\t\treturn str.charAt(0).toLowerCase() + str.slice(1);\n\t}\n\n\t/*\n\t* Check if string, in which case make lowercaser, else return arg#2\n\t*\n\t* @param string \tstr\n\t* @param any \t\tdeflt\n\t*\n\t* @return string|@deflt\n\t*/\n\tfunction toLower(str,deflt=undefined){\n\t\treturn typeof str=='string' ? str.toLowerCase() : deflt;\n\t}\n\n\n\t/*\n\t* More capable substring function, able to start from end of string\n\t*/\n\tfunction substring(str,start,length){\n\t\tvX.checkType('string',str);\n\t\tif(start>str.length)\n\t\t\treturn '';\n\t\t\n\t\tif(start<0){\n\t\t\tstart=str.length+start;\n\t\t}\n\n\t\tvar finish=str.length;\n\t\tif(typeof length=='number')\n\t\t\tMath.min(start+length, str.length);\n\t\t\n\t\treturn str.substring(start,finish)\n\t}\n\n\n\n\t/*\n\t* Trim quotes, spaces and newlines from the start/end of a string\n\t*\n\t* @var string str \t\t\tAny string\n\t* @var bool   checkEmpty\tDefault false. If true an error is throw if not non-empty string\n\t*\n\t* @throw TypeError \t\t\tIf @str is not a string\n\t* @throw Error \t\t\t\tSee @checkEmpty\n\t*\n\t* @return string  \t\t\tThe trimmed string\n\t*/\n\tfunction trim(str,checkEmpty=false){\n\t\tif(typeof str!='string')\n\t\t\t_log.throwType('string',str);\n\n\n\t\tfunction replace(s){\n\t\t\treturn s\n\t\t\t\t.trim()\n\t\t\t\t.replace(/^[\"'\\n]+/,\"\")\n\t\t\t\t.replace(/[\"'\\n]+$/,\"\")\n\t\t\t\t.trim()\n\t\t\t;\n\t\t}\n\n\t\t//Call the above function repeatedly until the string stops changing\n\t\tvar s,i=0;\n\t\twhile(str!=(s=replace(str))){\n\t\t\tstr=s;\n\t\t\tif(++i>10){\n\t\t\t\t_log.warn(\"Exceeded 10 loops when trying to trim string...\")\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(checkEmpty && str=='')\n\t\t\tthrow new Error(\"String was empty\");\n\t\telse\n\t\t\treturn str;\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Replace all occurences of a substring. \n\t*\n\t* @param string target \t\t\tThe string to operate on\n\t* @param string search \t\t\tThe substring to remove\n\t* @param string replacement \tA substring to insert in replacement of @search\n\t*\n\t* @return string\n\t*/\n\tfunction replaceAll(target,search,replacement){\n\t\tif(target.length<40){\n\t\t\t//This is slower than using RegExp, but it does not rely on the search string being properly escaped, \n\t\t\t//and for a shorter string it may be quicker not to have to escape the search string\n\t\t\treturn target.split(search).join(replacement);\n\t\t}else{\n\t\t\t//This will be faster, but we have to make sure the search string is escaped first, which only makes\n\t\t\t//it worth it for slightly longer strings\n\t\t\tsearch=escapeRegExp(search);\n\t\t\treturn target.replace(new RegExp(search, 'g'), replacement);\n\t\t}\n\n\n\t}\n\n\t/*\n\t* Escape any regexp characters in a string so it can be used for exact matches in an actual RegExp\n\t*\n\t* Example: \t'hello.world'=>'hello\\.world'\n\t*\n\t* @return string\n\t*/\n\tfunction escapeRegExp(str) {\n\t\tvX.checkType('string',str)\n\t \treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n\t}\n\n\n\n\t/*\n\t* Get all matches for a regexp on a string, ie. run regexp.exec until it returns nothing\n\t*\n\t* NOTE: this only works if the 'g' flag is set, else RegExp.exec won't remember the position of the \n\t*       last match and you'll have an infinite loop on your hands... So if 'g' is not set, we do it for you\n\t*\n\t* @param <RegExp> regexp\n\t* @param string str\n\t* @param number maxMatches  Break loop if it matches more than this number. Default 0=infinite\n\t* \n\t* @return array[array,...] \tEach item is a match, ie. a child array. See \n\t*\t\t\thttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec#Description\n\t\t\n\t\tExample. \n\t\t\tregexp -->\t/(\\w+)ball/   \n\t\t\tstr    -->\t'football is better than basketball'\n\t\t\treturn -->\t[[football,foot],[basketball, basket]]\n\t*/\n\tfunction regexpAll(regexp, str,maxMatches=0){\n\t\t// vX.instanceOf(RegExp,regexp);\n\t\tvX.checkTypes(['<RegExp>','string'],[regexp,str]);\n\n\t\t//Make sure we have the g flag\n\t\tif(regexp.flags.indexOf('g')==-1){\n\t\t\t_log.debug(\"Adding 'g' flag to regexp else we cannot get all matches. \"+regexp);\n\t\t\tregexp=new RegExp(regexp.toString()+'g');\n\t\t}\n\n\t\tvar matches=[],match,i=0;\n\t\twhile((match=regexp.exec(str))!==null){\n\t\t\ti++;\n\t\t\tif(maxMatches && maxMatches<i){\n\t\t\t\t_log.warn(`Exceeded max matches (${maxMatches}), breaking early.`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatches.push(match);\n\t\t}\n\n\t\t// _log.trace('The regexp ('+String(regexp)+') matched '+matches.length+' times');\n\t\treturn matches;\n\t}\n\n\n\n\n\n\t/*\n\t* Make sure a string isn't too long by removing the middle of it\n\t*\n\t* @param string\n\t* @param number\n\t*\n\t* @return string\n\t*/\n\tfunction limitString(str,limit){\n\t\tvX.checkType('string',str);\n\t\tlet len=str.length;\n\t\tif(len>limit){\n\t\t\tvar half=Math.round(limit/2);\n\t\t\treturn str.substring(0,half)+' ...'+(len-limit)+'... '+str.substring(len-half);\n\t\t}else\n\t\t\treturn str;\n\n\t}\n\n\n\n\t/*\n\t* return array\n\t*/\n\tfunction split(str,delimit,lastDelimit){\n\t\ttry{\n\t\t\tvX.checkType('string',str);\n\t\t\tvar arr=str.split(delimit);\n\t\t\tvX.checkType(['array'],arr); //throw on fail\n\t\t\tif(lastDelimit){\n\t\t\t\tvar last=arr.pop();\n\t\t\t\tif(vX.checkType(['string'],last,true))\n\t\t\t\t\tarr.concat(last.split(lastDelimit))\n\t\t\t}\n\t\t\treturn arr;\n\t\t} catch(err){\n\t\t\t_log.throw(err);\n\t\t}\t\n\n\t}\n\n\t/*\n\t* Split a string at multiple locations\n\t*\n\t* @param string str \t\t\tString to split\n\t* @param array[number] splitArr Array of numbers where to split the string\n\t*\n\t* @return array\n\t*/\n\tfunction splitAt(str,splitArr){\n\t\tvX.checkTypes(['string','array'],arguments);\n\t\tvar arr=[],i;\n\t\tfor(i=0;i<splitArr.length;i++){\n\t\t\tarr.push(str.substring(splitArr[i],splitArr[i+1]).trim());\n\t\t}\n\t\treturn arr;\n\t}\n\n\n\t/*\n\t* From a string, get an object where keys are the starting index of each word and values are the word.\n\t*\n\t* @param string line \t\n\t*\n\t* @return obj \t\n\t*/\n\tfunction indexWords(line){\n\t\tvar obj={},i=0;\n\t\tline.match(/[^\\s]+(\\s+|$)/g).forEach(m=>{ //matches non-whitespace followed by whitespace (capture \n\t\t\t\t\t\t\t\t\t\t\t\t  //group not used for capturing, only regex syntax)\n\t\t\tobj[i]=m.trim(); //m is the full match (word+white), but we trim the white\n\t\t\ti+=m.length;//move index total length of match (word+white)\n\t\t\t//Now i is the starting index of the next word\n\t\t})\n\t\treturn obj;\n\t}\n\n\n\t/*\n\t* Turn the output from a linux command into an array of object (ie. one object per line)\n\t*\n\t* @param string|array stdout\n\t* @param @opt boolean headersToLowerCase\n\t* @param @opt boolean outputIsTerese \t\tDefault false. Set true if lines have spaces in columns \n\t*\t\t\t\t\t\t\t\t\t\t\t other than the before last one, eg:\n\t* \t\t\t\t\t\t\t\t\t\t\t\tname age hobby                weight\n\t*  \t \t\t\t\t\t\t\t\t\t\t\tBob  33 To go to the movies      70\n\t*\n\t* @return object\n\t*/\n\tfunction linuxTableToObjects(stdout, headersToLowerCase=false, outputIsTerese=false){\n\t\t//Make sure we have a string\n\t\tif(typeof stdout=='object' && stdout.hasOwnProperty('stdout'))\n\t\t\tstdout=stdout.stdout\n\n\t\t//Turn string into arr\n\t\tvar arr;\n\t\tif(Array.isArray(stdout))\n\t\t\tarr=stdout\n\t\telse{\n\t\t\tif(typeof stdout!='string')\n\t\t\t\tstdout=stdout.toString('utf8').trim();\n\n\t\t\tif(typeof stdout!='string')\n\t\t\t\t_log.throwType('string',stdout);\n\n\t\t\tarr=stdout.split('\\n')\n\t\t}\n\n\t\t//Make sure arr contains some non-empty lines\n\t\tvar arr=arr.map(line=>line.trim()).filter(line=>line);\n\t\tif(!arr.length)\n\t\t\treturn [];\n\n\t\t//extract the headers row and turn into array\n\t\ttry{\n\t\t\tvar headers=arr.splice(0,1)[0];\n\n\t\t\t//If output is terese, use special function to split...\n\t\t\tif(outputIsTerese){\n\t\t\t\tlet obj=indexWords(headers);\n\t\t\t\toutputIsTerese=Object.keys(obj);\n\t\t\t\theaders=Object.values(obj);\n\t\t\t}else{\n\t\t\t\theaders=headers.split(/\\s+/)\n\t\t\t}\n\n\t\t\tif(headersToLowerCase)\n\t\t\t\theaders=headers.map(header=>header.toLowerCase());\n\t\t\t// console.log('GOT HEADERS:',headers);\n\t\t}catch(err){\n\t\t\t_log.makeError('Failed to convert linux columns to array of objects.',err).throw();\n\t\t}\n\n\t\t//Now turn each row into an object, using the header for for prop names\n\t\treturn arr.map(line=>{\n\t\t\tvar values;\n\t\t\tif(outputIsTerese){\n\t\t\t\tvalues=splitAt(line,outputIsTerese);\n\t\t\t}else{\n\t\t\t\tvalues=line.split(/\\s+/);\t\t\t\t\t\t\t//BUG: this split combined with.... vv\n\t\t\t\t// log.info('GOT VALUES:',values);\n\n\t\t\t\t//Assume that only the last column has spaces... may NOT be the case...\n\t\t\t\tif(values.length>headers.length){\n\t\t\t\t\t//eg. \tname \t\tdescription \t=> ['name','description']\n\t\t\t\t\t//\t\tBob \t\tLikes to ski \t=> ['Bob','Likes','to','ski']\n\t\t\t\t\tlet lastCol=values.splice(headers.length-1).join(' ');\n\t\t\t\t\tvalues.push(lastCol);\n\t\t\t\t\t//now we have: ['Bob', 'Likes to ski']\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(values.length!=headers.length){\n\t\t\t\t_log.throw(\"Problem converting columns to array of objects. There are \"\n\t\t\t\t\t+`${headers.length} headers and ${values.length} values`,log.logVar(headers,1000), log.logVar(values,1000))\n\t\t\t}\n\n\t\t\tvar obj={};\n\t\t\tfor(let i in headers){\n\t\t\t\tobj[headers[i]]=values[i];\n\t\t\t}\n\t\t\treturn obj;\n\t\t})\n\t}\n\n\n\n\tvar bashColors={\n\t\t//Color\t\t\tText \tBackground\n\t\t'black'\t\t\t:['30'\t,'40']\n\t\t,'red'\t\t\t:['31'\t,'41']\n\t\t,'green'\t\t:['32'\t,'42']\n\t\t,'yellow'\t\t:['33'\t,'43']\n\t\t,'blue'\t\t\t:['34'\t,'44']\n\t\t,'magenta'\t\t:['35'\t,'45']\n\t\t,'cyan'\t\t\t:['36'\t,'46']\n\t\t,'white'\t\t:['37'\t,'47']\n\t\t,'brightblack'\t:['90'\t,'100']\n\t\t,'brightred'\t:['91'\t,'101']\n\t\t,'brightgreen'\t:['92'\t,'102']\n\t\t,'brightyellow'\t:['93'\t,'103']\n\t\t,'brightblue'\t:['94'\t,'104']\n\t\t,'brightmagenta':['95'\t,'105']\n\t\t,'brightcyan'\t:['96'\t,'106']\n\t\t,'brightwhite'\t:['97'\t,'107']\n\t}\n\n\t\t\t\n\n\n\tfunction wrapInBashColor(str,f,b){\n\t\tvar c;\n\t\tif(typeof f=='string'){\n\t\t\tf=f.toLowerCase().replace(' ','')\n\t\t\tif(bashColors.hasOwnProperty(f)){\n\t\t\t\tc=bashColors[f][0];\n\t\t\t\tstr='\\x1b['+c+'m'+str\n\t\t\t}\n\t\t}\n\n\t\tif(typeof b=='string'){\n\t\t\tb=b.toLowerCase().replace(' ','')\n\t\t\tif(bashColors.hasOwnProperty(b)){\n\t\t\t\tc=bashColors[b][1];\n\t\t\t\tstr='\\x1b['+c+'m'+str\n\t\t\t}\n\t\t}\n\n\t\tif(c)\n\t\t\tstr+='\\x1b[0m';\n\n\t\treturn str;\n\t}\n\n\n\n\tfunction progressBar(progress,totalLength=10,color=false,fill='x',empty='.'){\n\t\tvar prog=Math.round(progress*totalLength),rest=totalLength-prog\n\t\tfill=fill.repeat(prog);\n\t\tif(color)\n\t\t\tfill=wrapInBashColor(fill,color);\n\t\treturn '['+fill+empty.repeat(rest)+']';\n\n\t}\n\n\n\t/*\n\t* Turn a hash or search string into an object\n\t*\n\t* @param string str \tA query string like \"hello=bob&foo[]=bar,car\", with or without leading # or ?\n\t*\n\t* @see obj.util.js:objToQueryStr()\n\t*\n\t* @throw <ble.TypeError>\n\t* @return object \t\tEg. {hello:\"bob\",foo:[\"bar\",\"car\"]}\n\t*/\n\tfunction queryStrToObj(str){\n\t\tvX.checkType('string',str);\n\n\t\t//Remove leading ? or #\n\t\tif(str.substring(0,1)=='#'||str.substring(0,1)=='?')\n\t\t\tstr=str.substring(1);\n\n\t\tvar obj={},pairs = str.split('&'),i=pairs.length-1;\n\t    for (i;i>=0;i--) {\n\t    \ttry{\n\t\t        var pair = pairs[i].split('='),key=pair[0];\n\t\t        //Empty values are allowed (the key becomes a flag), but not missing keys\n\t\t        if(key){\n\t\t        \t//First turn obvious stuff into their real vartype, like numbers, null, undefined etc.\n\t\t        \tvar value=vX.stringToPrimitive(pair[1]);\n\t\t        \t// if it's still a string, decode it...\n\t\t        \tif(value && typeof value=='string'){\n\t\t        \t\tvalue=decodeURIComponent(value);\n\t\t        \t}\n\t\t        \t//The key could indicate that we have an array...\n\t\t\t        if(key.substring(key.length-2)=='[]'){\n\t\t\t        \tkey=key.substring(0,key.length-2);\n\t\t\t        \tif(vX.isEmpty(value)){ //null, undefined, empty string... but not false or 0\n\t\t\t        \t\tvalue=[]\n\t\t\t        \t}else if(typeof value=='string'){\n\t\t\t        \t\tvalue=value.split(',').map(vX.stringToPrimitive);\n\t\t\t        \t}else{\n\t\t\t        \t \tvalue=[value]; //could be '0' or 'false'\n\t\t\t        \t}\n\n\t\t\t        //Or the value could indicate that it's a json\n\t\t\t        }else if(value[0]=='{' || value[0]=='['){\n\t\t\t        \tvalue=vX.tryJsonParse(value) //will return parsed object or the same string on fail\n\t\t\t        }\n\t\t\t        obj[key]=value;\n\t\t        }\n\t    \t}catch(err){\n\t    \t\t_log.warn(\"Bad pair in uri string:\",pairs[i],str,err);\n\t    \t}\n\t    }\n\t    return obj;\n\t}\n\n\t/*\n\t* Convert \"hello-world\" => \"helloWorld\"\n\t*\n\t* @param string str\n\t* @return string\n\t*/\n\tfunction dashToCamel(str){\n\t\treturn str.replace(new RegExp('-([a-z])', 'g'), (match,capture)=>capture.toUpperCase())\n\t}\n\n\n\n\n\tfunction randomString(length=32, chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') {\n\t    var result = '';\n\t    for (var i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];\n\t    return result;\n\t}\n\n\n\tfunction getUniqueString(str, existing){\n\t\tvX.checkTypes(['string','array'],arguments);\n\n\t\tif(!existing.includes(str))\n\t\t\treturn str;\n\n\t\t//First try appending a number from 2 to 999\n\t\tvar i;\n\t\tfor(i=2;i<1000;i++){\n\t\t\tlet str2=str+'_'+String(i);\n\t\t\tif(!existing.includes(str2))\n\t\t\t\treturn str2;\t\t\n\t\t}\n\n\t\t//Then try 10 times to append a random string\n\t\ti=10;\n\t\twhile(i--){\n\t\t\tlet str2=str+'_'+randomString(10);\n\t\t\tif(!existing.includes(str2))\n\t\t\t\treturn str2;\t\t\t\n\t\t}\n\n\t\t//This is veeeeeeeeeeery unlikely...\n\t\t_log.throw(\"Could not find unique string\",arguments);\n\t}\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/string.util.js?");

/***/ }),

/***/ "./util/common/time.util.js":
/*!**********************************!*\
  !*** ./util/common/time.util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {//simpleSourceMap=/my_modules/util/common/time.util.js\n//simpleSourceMap2=/lib/util/common/time.util.js\n/*\n* This module should only be required by util.common.js in NodeJS. If using in browser, please bundle\n* util.browser.js with eg. Browserify\n*\n* This module exports an object with functions on it. \n*\n* This is a helper module for time and date related functions\n*/\n\nmodule.exports=function export_tX({vX,_log}){\n\n\t//Methods to export\n\tvar _exports={\n\t\tBetterDate\n\t\t,makeDate\n\t\t,formatDate\n\t\t,formatDatetime\n\t\t,today\n\t\t,tomorrow\n\t\t,todayMs\n\t\t,tomorrowMs\n\t\t,age\n\t\t\n\t\t,timerStart\n\t\t,timerStop\n\n\t\t,timeToDate\n\t\t,compareTimes\n\t};\n\n\n\n\tvar dow_arr=['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];\n\n\tfunction BetterDate(x){\n\t\t//So we don't have to use new...\n\t\tif(this.constructor!=BetterDate){\n\t\t\treturn new BetterDate(x);\n\t\t}\n\n\t\tthis.date=makeDate((x && x.date && x.date instanceof Date) ? x.date : x)\n\n\t\tObject.defineProperties(this,{\n\t\t\tformat:{enumerable:true,get:()=>formatDate(this.date)}\n\t\t\t,dom:{enumerable:true, get:()=>this.date.getDate()}\n\t\t\t,dow:{enumerable:true, get:()=>this.date.getWeek()}\n\t\t\t,month:{enumerable:true, get:()=>this.date.getMonth()}\n\t\t\t,year:{enumerable:true, get:()=>this.date.getYear()}\n\t\t\t,hour:{enumerable:true, get:()=>this.date.getHours()}\n\t\t\t,minute:{enumerable:true, get:()=>this.date.getMinutes()}\n\t\t\t,time:{enumerable:true, get:()=>this.date.toTimeString().split(' ').unshift()}\n\t\t\t,unix:{enumerable:true, get:()=>this.date.valueOf()}\n\n\t\t})\n\n\t\tthis.first={dom:{this:{},last:{},next:{}}};\n\t\tObject.defineProperties(this.first.dom.this,'week',{enumerable:true, get:()=>this.date.getDate()-this.date.getDay()});\n\t\tObject.defineProperties(this.first.dom.next,'week',{enumerable:true, get:()=>(new Date(this.first.dom.this.week+7)).getDate()});\n\t\tObject.defineProperties(this.first.dom.last,'week',{enumerable:true, get:()=>(new Date(this.first.dom.this.week-7)).getDate()});\n\n\t\tthis.last={dom:{this:{},last:{},next:{}}};\n\t\tObject.defineProperties(this.last.dom.this,'week',{enumerable:true, get:()=>this.first.dom.this.week+6});\n\t\tObject.defineProperties(this.last.dom.next,'week',{enumerable:true, get:()=>this.first.dom.next.week+6});\n\t\tObject.defineProperties(this.last.dom.last,'week',{enumerable:true, get:()=>this.first.dom.last.week+6});\n\n\t\tthis.copy=()=>new BetterDate(this.date);\n\n\n\t\tthis.compare={\n\t\t\ttime:(str)=>compareTimes(str,this.time)\n\t\t\t,date:(str)=>{var d=makeDate(str);return d>this.date?1:d<this.date?-1:0;}\n\t\t}\n\n\n\t\tfunction checkWhat(what){\n\t\t\t//Start by making sure we have a string with first letter capitalized\n\t\t\tvX.checkType('string',what);\n\t\t\twhat=what.substr(0,1).toUpperCase()+what.substr(1);\n\n\t\t\t//Now check if this specific guy wants an 's'\n\t\t\tif(typeof this.date['get'+what]=='function')\n\t\t\t\treturn what\n\t\t\telse if(what.substr(-1)=='s'){\n\t\t\t\t//We don't know that there is a func when removing the s, but we return anyway\n\t\t\t\t//for consistency. ie. If we got 'Weeks' we want to return 'Week', that way we\n\t\t\t\t//don't have to check for both when converting to days (see this.add())\n\t\t\t\treturn what.slice(0,-1);\n\t\t\t}else if(typeof this.date['get'+what+'s']=='function'){\n\t\t\t\treturn what+'s';\n\t\t\t}\n\t\t}\n\n\t\tthis.set=(what,to)=>{\n\t\t\twhat='set'+checkWhat(what);\n\t\t\tthis.date=new Date(this.date[what](to));\n\t\t\treturn this;\n\t\t}\n\t\tthis.set.dom=this.set.dayofmonth=this.set.bind(this,'date');\n\t\tthis.set.dow=this.set.dayofweek=(dow)=>this.set('date',this.first.dow.this.week+dow);\n\t\tthis.set.months=this.set.month=this.set.bind(this,'month');\n\t\tthis.set.years=this.set.year=this.set.bind(this,'year');\n\t\tthis.set.hours=this.set.hour=this.set.bind(this,'hours');\n\t\tthis.set.minutes=this.set.minute=this.set.bind(this,'minutes');\n\t\tthis.set.time=(str)=>{\n\t\t\tif(typeof str!='string')\n\t\t\t\t_log.makeTypeError('string time HH:MM',str).throw();\n\n\t\t\tvar m=str.match(/^(\\d{2}):(\\d{2}):?(\\d{2})?$/);\n\t\t\tif(m){\n\t\t\t\tthis.set.hour(m[1]);\n\t\t\t\tthis.set.minute(m[2]);\n\t\t\t\tthis.set.second(m[3]||0);\n\t\t\t}else{\n\t\t\t\t_log.makeError('Bad time format. Expected HH:MM, got: '+str).setCode('EINVAL').throw();\n\t\t\t}\n\t\t}\n\n\t\tthis.goto={};\n\t\tthis.goto.upcoming=(what)=>{\n\t\t\tvar dow=what;\n\t\t\tif(vX.checkType(['string','number'],dow)=='string'){\n\t\t\t\tdow=dow_arr.indexOf(dow.toLowerCase());\n\t\t\t}\n\t\t\tif(dow<0 || dow>6)\n\t\t\t\t_log.makeError('Expected a string weekday or number between 0-6, got:',what).setCode('EINVAL').throw();\n\t\t\t\t\n\t\t\t//If the day has passed or is today, to do next week\n\t\t\tif(this.dow>=dow){\n\t\t\t\tthis.add.week(1);\n\t\t\t}\n\t\t\treturn this.set.dow(dow);\n\t\t}\n\t\t\n\n\t\tthis.add=(what,much)=>{\n\t\t\tvX.checkType('number',much);\n\t\t\twhat=checkWhat(what);\n\t\t\tif(what=='Week'){\n\t\t\t\tmuch=much*7\n\t\t\t\twhat='Date'\n\t\t\t}else if(what=='Day'){\n\t\t\t\twhat='Date';\n\t\t\t}\n\t\t\tthis.date=new Date(this.date['set'+what](this.date['get'+what]()+much));\n\t\t\treturn this;\n\t\t}\n\t\tthis.add.days=this.add.day=this.add.bind(this,'date');\n\t\tthis.add.weeks=this.add.week=this.add.bind(this,'week');\n\t\tthis.add.months=this.add.month=this.add.bind(this,'month');\n\t\tthis.add.years=this.add.year=this.add.bind(this,'year');\n\t\tthis.add.hours=this.add.hour=this.add.bind(this,'hours');\n\t\tthis.add.minutes=this.add.minute=this.add.bind(this,'minutes');\n\n\t\tthis.sub=(what,much)=>this.add(what,-1*much)\n\t\tthis.sub.days=this.sub.day=this.sub.bind(this,'date');\n\t\tthis.sub.weeks=this.sub.week=this.sub.bind(this,'week');\n\t\tthis.sub.months=this.sub.month=this.sub.bind(this,'month');\n\t\tthis.sub.years=this.sub.year=this.sub.bind(this,'year');\n\t\tthis.sub.hours=this.sub.hour=this.sub.bind(this,'hours');\n\t\tthis.sub.minutes=this.sub.minute=this.sub.bind(this,'minutes');\n\n\t}\n\n\n\n\n\n\tfunction makeDate(x){\n\t\tif(typeof x=='undefined')\n\t\t\treturn Date.now();\n\t\telse{\n\t\t\tvar d=new Date(x);\n\t\t\tif(d=='Invalid Date'){\n\t\t\t\t_log.makeError(\"Invalid Date:\",_log.constructor.logVar(x)).setCode('EINVAL').throw();\n\t\t\t}\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t/*\n\t* @return string \tYYYY-MM-DD\n\t*/\n\tfunction formatDate(x){\n\t\tx=makeDate(x);\n\t\tvar y = x.getFullYear(),\n\t\t\tm = String(x.getMonth() + 1).padStart(2, '0'), //+1 => january is month 0\n\t\t\td = String(x.getDate()).padStart(2, '0')\n\t\t;\n\n\t\treturn `${y}-${m}-${d}`;\n\t}\n\n\t/*\n\t* @return string \n\t*/\n\tfunction formatDatetime(x){\n\t\tvar str=makeDate(x).toString();\n\t\treturn str.split('(')[0];\n\t}\n\n\tfunction today(){\n\t\treturn formatDate();\n\t}\n\n\tfunction tomorrow(){\n\t\treturn formatDate(new Date(Date.now() + (24 * 60 * 60 * 1000)));\n\t}\n\n\t/*\n\t* @return number \tMilliseconds from epoch to midnight this morning (past)\n\t*/\n\tfunction todayMs(){\n\t\treturn Date.parse(today()).getTime();\n\t}\n\n\t/*\n\t* @return number \tMilliseconds from epoch to midnight tonight (future)\n\t*/\n\tfunction tomorrowMs(){\n\t\treturn Date.parse(tomorrow()).getTime();\n\t}\n\n\n\n\tfunction age(ts, unit='best',short=false){\n\t\tvar ms=Date.now()-ts;\n\n\t\tswitch(unit){\n\t\t\tcase 'best':\n\t\t\t\tif(ms<1000)\n\t\t\t\t\treturn 'now';\n\t\t\t\telse if(ms<(1000*60))\n\t\t\t\t\treturn String(age(ts,'sec'))+(short ? ' sec':' seconds');\n\t\t\t\telse if(ms<(1000*60*60))\n\t\t\t\t\treturn String(age(ts,'m'))+(short ? ' min':' minutes');\n\t\t\t\telse if(ms<(1000*60*60*24))\n\t\t\t\t\treturn String(age(ts,'h'))+(short ? ' hrs':' hours');\n\t\t\t\telse\n\t\t\t\t\treturn String(age(ts,'days'))+(short ? ' days':' days');\n\n\t\t\tcase 'ms':\n\t\t\tcase 'millisec':\n\t\t\tcase 'millisecond':\n\t\t\tcase 'milliseconds':\n\t\t\t\treturn ms;\n\t\t\tcase 's':\n\t\t\tcase 'sec':\n\t\t\tcase 'second':\n\t\t\tcase 'seconds':\n\t\t\t\treturn Math.round(ms/1000,1);\n\t\t\tcase 'm':\n\t\t\tcase 'min':\n\t\t\tcase 'minute':\n\t\t\tcase 'minutes':\n\t\t\t\treturn Math.round(ms/1000/60,1);\n\t\t\tcase 'h':\n\t\t\tcase 'hours':\n\t\t\tcase 'hour':\n\t\t\t\treturn Math.round(ms/1000/60/60,1);\n\t\t\tcase 'd':\n\t\t\tcase 'days':\n\t\t\tcase 'day':\n\t\t\t\treturn Math.round(ms/1000/60/60/24,1);\n\t\t}\n\t}\n\n\n\tfunction timerStart(){\n\t\tif(process)\n\t\t\treturn process.hrtime();\n\t\telse\n\t\t\treturn window.performance.now()\n\t}\n\n\tfunction timerStop(start,format){\n\t\tvar nano;\n\t\tif(process){\n\t\t\tlet durr = process.hrtime(start);\n\t\t\tnano=(durr[0]*1000000000)+durr[1];\n\t\t}else{\n\t\t\tnano=(window.performance.now()-start)*1000000;\n\t\t}\n\t\tswitch(format){\n\t\t\tcase 's':\n\t\t\tcase 'sec':\n\t\t\tcase 'seconds':\n\t\t\t\treturn round(nano/1000000000);\n\t\t\tcase 'ms':\n\t\t\tcase 'milli':\n\t\t\tcase 'milliseconds':\n\t\t\t\treturn round(nano/1000000);\n\t\t\tcase 'us':\n\t\t\tcase 'micro':\n\t\t\tcase 'microseconds':\n\t\t\t\treturn round(nano/1000); \n\t\t\tcase 'ns':\n\t\t\tcase 'nano':\n\t\t\tcase 'nanoseconds':\n\t\t\t\treturn nano;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Please specify format (arg #2)\");\n\t\t}\n\t}\n\n\n\tfunction timeToDate(str){\n\t\treturn new Date('1970-01-01 '+str);\n\t}\n\n\n\t/*\n\t* Compare 2 string times\n\t*\n\t* @param string a\n\t* @param string b\n\t*\n\t* @return number \t1 if $a is later, 0 if same time, -1 if $a is earlier\n\t*/\n\tfunction compareTimes(a,b){\n\t\tif(a==b)\n\t\t\treturn 0;\n\n\t\ta=timeToDate(a);\n\t\tb=timeToDate(b);\n\n\t\treturn a>b?1:a<b?-1:0\n\t}\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js */ \"../../../../../../../opt/node-v8.11.3-linux-x64/lib/node_modules/webpack/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./util/common/time.util.js?");

/***/ }),

/***/ "./util/common/timer.class.js":
/*!************************************!*\
  !*** ./util/common/timer.class.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/timer.class.js\n//simpleSourceMap2=/lib/timer.class.js\n/*\n* This module exports a constructor. It can be required by nodeJS but is optimized to run \n* in browser by not using nodeJS native EventEmitter\n*/\n\n;'use strict';\nmodule.exports=function exportTimer(dep={}){\n    \n    function missingDependency(which){throw new Error(\"Missing dependency for timer.class.js: \"+which);}\n    const BetterLog = dep.BetterLog                || missingDependency('BetterLog');\n    const BetterEvents = dep.BetterEvents          || missingDependency('BetterEvents');\n\n    /*\n    * Object which keeps track of an interval and timeout timer, allowing for pause and\n    * resume, emitting events as it goes\n    *\n    * @emit interval(number,number) Emits on every interval (arg #1) with elapsed and remaining time.\n    * @emit timeout(number)         Emits once when timer ends with arg #2\n    * @emit event(evt)              Emits along with both ^^, arg is event name\n    *\n    * @param number interval    Milliseconds between emiting interval events\n    * @param number timeout     Milliseconds to wait before emiting 'timeout' event\n    * @param number startFrom   Milliseconds that have already passed. Both _private.elapsed and _private.remaining\n    *                             will be adjusted, but when resetting the timer it will start from 0 and last the\n    *                             full value of timeout \n    */\n    function Timer(interval=null,timeout=null, startFrom){\n        \n\n        var self=this;\n\n        //Inheritence step 1\n        BetterEvents.call(this);\n\n\n        this.running=false;\n\n        Object.defineProperty(this,'_log',{value:new BetterLog(this)});\n\n        Object.defineProperty(this,'_private',{value:{\n            timeoutIds:[]\n        }});\n\n\n\n        function getNow(){\n            var last=self._private\n            var now={\n                now:(new Date()).getTime()\n            }\n            now.timeSinceLastStart=(last.start ? now.now - last.start : 0);\n            now.elapsed=Math.max(last.elapsed+now.timeSinceLastStart,0);\n            now.remaining=typeof last.remaining!='number' ? null : Math.max(last.remaining-now.timeSinceLastStart,0);\n            now.nextInterval=typeof last.nextInterval!='number'? null : Math.max(last.lastInterval||now.now+last.interval-now.now,0); \n            return now;\n        }\n\n        /*\n        * @return null|number>0\n        */\n        this.getRemaining=function(){\n            if(this.running)\n                return getNow().remaining;\n            else\n                return self._private.remaining;\n        }\n\n        /*\n        * @return number\n        */\n        this.getElapsed=function(now){\n            if(this.running){\n                return getNow().elapsed;\n            }else\n                return self._private.elapsed;\n        }\n\n        \n\n\n        /*\n        * @return bool        True if was previously running, else false\n        */\n        this.pause = function() {\n\n            if(this.running){\n\n                //Save remaining and elapsed time, then change flag so all future checks (until we resume) returns\n                //the values are setting here\n                var now=getNow()\n                Object.assign(this._private,now);\n                // self._log.note('PAUSED and set values:',now);\n\n                this.running=false;\n                \n                //You can clear timeouts and intervals with the same command\n                //      https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval)\n                var id;\n                while(id=this._private.timeoutIds.pop()){\n                    // self._log.info(\"clearing timeout/interval\",id);\n                    clearTimeout(id)\n                }\n                \n                return true;\n            }else{\n                // self._log.note(\"NOT RUNNING, not pausing...\")\n            }\n\n            return false;\n        };\n\n        //Since the next interval may be less than 1 interval increment away (because we may have\n        //paused in the middle of an interval), it needs to be fired in a seperate timeout, so we \n        //define the func seperately to use it twice\n        function emitInterval(){\n            var now=getNow();\n            self._private.lastInterval=now.now; \n            self.emit('interval',now.elapsed,now.remaining);\n        }\n\n\n        /*\n        * @return bool        True if was previously paused, else false\n        */\n        this.resume = function() {\n            if(!this.running){\n                // self._log.note('RESUMING...next interval',this._private.nextInterval,'  remaining',this._private.remaining);\n\n                this._private.start=getNow().now;\n                \n                this.running=true;\n\n\n                if(typeof this._private.nextInterval=='number')\n                    //We're going to fire the first timeout manually, and then set an interval staring from\n                    //that point. This is because we may have paused in between 2 intervals which implies that \n                    //the next interval is less than one interval away. NOTE: that nextInterval also get's adjusted  \n                    //by adjustElapsed()\n                    this._private.timeoutIds.push(\n                        setTimeout(()=>{\n                            // 1. Fire first manually, having waited... vv\n                            emitInterval(); //Emit right away\n\n                            //2. Start interval that will take over after first\n                            this._private.timeoutIds.push(setInterval(emitInterval,self._private.interval));\n\n                        },this._private.nextInterval)//                  ^^ ...this long\n                    ); \n                //NOTE: if no timeout is set, interval can go on forever\n\n                if(typeof this._private.remaining=='number') //so it fires right away if remaining is zero\n                    this._private.timeoutIds.push(setTimeout(()=>{\n                        self.pause();\n                        self.emit('timeout',self._private.timeout);\n                    }, this._private.remaining));\n\n                return true;\n            }else{\n                // self._log.note(\"ALREADY RUNNING, not resuming...\");\n            }\n\n            return false;\n\n            \n        };\n\n\n\n        /*\n        * Instead of creating a new Timer and having to listen for events again, this method allows resetting\n        * the two main parameters (essentially creating a new Timer)\n        *\n        * NOTE: This pauses timer if running\n        *\n        * @param number|true|null i    Milliseconds between emiting 'interval' events. True=>use value from creation\n        * @param number|true|null t    Milliseconds to wait before emiting 'timeout' event. True=>use value from creation\n        *\n        * @return boolean   True if reset succeeded, else false\n        */\n        this.reset=function(i=true,t=true, startFrom){\n            this.pause();\n            \n            //The special-case value 'true' implies we use whatever value was used when the Timer was created\n            i=(i===true ? self._private.interval : i);\n            t=(t===true ? self._private.timeout : t);\n\n            try{\n                self._log.debug(\"Resetting timer with:\",i,t,startFrom);\n                resetVars(i,t, startFrom);\n                return true;\n            }catch(err){\n                self._log.error('Failed to reset timer',err);\n                return false;\n            }\n        }\n\n        /*\n        * Like .reset() but also starts timer after\n        *\n        * @return boolean \n        */\n        this.restart=function(){\n            if(this.reset.apply(this,Object.values(arguments))){\n                this.resume();\n                return true;\n            }else{\n                return false;\n            }\n        }\n\n        /*\n        * Adjust the elapsed and remaining time by specifying how much time has actually elapsed\n        *\n        * @param number actualElapsed\n        * return void\n        */\n        this.adjustElapsed=function(actualElapsed){\n            try{\n                if(typeof actualElapsed!='number')\n                    self._log.throwType(\"number\",actualElapsed);\n                if((self._private.timeout && actualElapsed>self._private.timeout) || actualElapsed<0)\n                    throw new RangeError(\"Valid range 0-\"+self._private.timeout+', got '+actualElapsed);\n            }catch(err){\n                self._log.error('Failed to adjust elapsed time',err);\n                return;\n            }\n            \n            //Pause it. \n            var resumeAfter=this.pause();\n           \n            //If we're not changing anything, skip ahead\n            if(actualElapsed!=this._private.elapsed){\n\n                //Always set elapsed\n                this._private.elapsed=actualElapsed;\n                \n                //If there's an interval, adjust nextInterval. Here however we have to consider the change^ so\n                //the intervals keep fireing at the right time. Eg. elapsed=16, actualElapsed=18, interval=5, meaning\n                //nextInterval=4 but it should be 2. Or actualElapsed=14 meaning nextInterval should be 1\n                let i=self._private.interval;\n                if(i){\n                    self._private.nextInterval=(Math.ceil(actualElapsed/i)*i)-actualElapsed\n                }\n\n                //Adjust remaining if there's a timeout\n                if(self._private.timeout)\n                    self._private.remaining=self._private.timeout-actualElapsed;\n\n                self._log.info(`Elapsed time set to: ${this._private.elapsed} of ${self._private.timeout}`);\n            }else{\n                self._log.debug(`No change, timer is still set at: ${this._private.elapsed}`);\n            }\n\n            if(resumeAfter)\n                this.resume();\n        }\n\n\n        /*\n        * Add or delete timeout without affecting elapsed time.\n        *\n        * NOTE: If timeout < elapsed\n        *\n        * @param number|falsey timeout\n        * return void\n        */\n        this.setTimeout=function(timeout){\n            if(timeout && typeof timeout!='number')\n                self._log.throwType(\"number|falsey\",timeout);\n\n\n            var resumeAfter=this.pause();\n\n            self._private.timeout=timeout || null;\n            self._private.remaining=timeout ? timeout-this._private.elapsed : null;\n\n            if(resumeAfter)\n                this.resume();\n        }\n\n\n        /*\n        * Type-checks and sets the two main parameters\n        *\n        * @return void\n        */\n        function resetVars(i,t,startFrom){\n            if(i && typeof i!='number')\n                self._log.throwType(\"arg #1 to be falsey or a number\",i);\n            if(t && typeof t!='number')\n                self._log.throwType(\"arg #2 to be falsey or a number\",t);\n            self._private.nextInterval=self._private.interval=i || null;\n            self._private.timeout=self._private.remaining=t || null;\n            self._private.elapsed=0;\n            self._private.lastInterval=0;\n\n            if(startFrom)\n                self.adjustElapsed(startFrom);\n\n            return;\n        }\n\n\n        resetVars(interval,timeout,startFrom);\n    }\n    Timer.prototype=Object.create(BetterEvents.prototype); \n    Object.defineProperty(Timer.prototype, 'constructor', {value: Timer});\n\n\n    return Timer;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/timer.class.js?");

/***/ }),

/***/ "./util/common/validate.util.js":
/*!**************************************!*\
  !*** ./util/common/validate.util.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/util/common/validate.util.js\n//simpleSourceMap2=/lib/util/common/validate.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module contains helper/util functions related to validating various data, like emails etc\n*/\n\n\n\nmodule.exports=function export_validate({netmask,vX}){\n\n\t//Methods to export\n\tvar _exports={\n\t\t'email':validateEmail\n\t\t,'ip':validateIP\n\t};\n\n\n\n\tfunction validateEmail(str){\n\t\tvar regexp=/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/\n\t\treturn str.match(regexp);\n\t}\n\n\n\tfunction validateIP(str,...flags){\n\t\tif(typeof str !=='string'){\n\t\t\tvX._log.makeError(\"Expected a IP string, got:\",this.log.logVar(str)).throw('TypeError');\n\t\t}\n\t\t\n\t\ttry{\t\n\t\t\ttry{\n\t\t\t\tnetmask.ip2long(str)\n\t\t\t}catch(err){\n\t\t\t\tvX._log.makeError(`Not valid IP: ${str}`).throw();\n\t\t\t}\n\t\t\t\t\n\t\t\tif(str.includes('/')){\n\t\t\t\tif(!flags.includes('allowSubnet') && !flags.includes('requireSubnet')){\n\t\t\t\t\tvX._log.makeError(`Got subnet, wanted regular IP: ${str}`).throw();\n\t\t\t\t}\n\t\t\t}else if(flags.includes('requireSubnet')){\n\t\t\t\tvX._log.makeError(`Got regular IP, wanted subnet: ${str}`).throw();\n\t\t\t}\n\n\t\t}catch(err){\n\t\t\tif(flags.includes('throw'))\n\t\t\t\tvX._log.makeError(err).throw();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\n\n\n\treturn _exports;\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n\n\n//# sourceURL=webpack:///./util/common/validate.util.js?");

/***/ }),

/***/ "./util/common/vars.util.js":
/*!**********************************!*\
  !*** ./util/common/vars.util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//simpleSourceMap=/my_modules/util/common/vars.util.js\n//simpleSourceMap2=/lib/util/common/vars.util.js\n/*\n* This module should only be required in NodeJS. If using in browser, please bundle with eg. Browserify\n*\n* This module exports an object with functions on it. If a global object is passed in, the 'util' \n* property on it will be amended with the ones in this file.\n*\n* @param object globalObj \t\tEither window if in broswer (see bottom), or 'this', ie whatever scope\n* \t\t\t\t\t\t\t\tthis script is executed in\n*/\n;'use strict';\n\nmodule.exports=function export_vX({varType,logVar,_log}){\n    \n\tvar _exports={\n\t\t'varType':varType\n\t\t,'logVar':logVar\n\t\t,'checkType':checkType\n\t\t,'checkTypes':checkTypes\n\t\t,'checkProps':checkProps\n\t\t,'isEmpty':isEmpty\n\t\t,'sameValue':sameValue\n\t\t,'compare':compare\n\t\t,'getCompareFunc':getCompareFunc\n\t\t,'isPrimitive':isPrimitive\n\t\t,'allPrimitive':allPrimitive\n\t\t,stringToPrimitive\n\t\t,stringToNumber\n\t\t,'forceType':forceType\n\t\t,'tryJsonParse':tryJsonParse\n\t\t,'tryJsonStringify':tryJsonStringify\n\t\t,'stringifySafe':stringifySafe\n\t\t,'copy':copy\n\t\t,'instanceOf':instanceOf\n\t\t,stripComments\n\t};\n\n\n\n\n\n\t/*\n\t* Check Throw a TypeError with a well formated message\n\t*\n\t* @param mixed expected \t\tString vartype, or array of <<\n\t* @param any got \t\t\t\tThe actual variable that was the wrong type\n\t* @param bool|string falseOrCaller \tIf ===true, then false is returned on error, if a string, said string \n\t*\t\t\t\t\t\t\t\t\t  is used in error (see first line of func body vv)\n\t*\n\t* @throw TypeError \t\t\t\tIf the type was bad (unless @falseOrCaller===true)\n\t* @return string|bool \t\t\tString if arg#3===true (@see helper.varType($got)) or false if arg#3==false && type is bad\n\t*/\n\tvar lookup={\n\t\t'bool':'boolean'\n\t\t,'arr':'array'\n\t\t,'obj':'object'\n\t\t,'str':'string'\n\t\t,'nr':'number'\n\t\t,'*':'any'\n\t\t,'mixed':'any'\n\t}\n\t// var primitiveObject={\n\t// \t'string':String\n\t// \t,'number':Number\n\t// \t,'boolean':Boolean\n\t// }\n\tfunction checkType(expectedType, got,falseOrCaller=false){\n\t\t//First do a very quick check so we don't waste time in non-complicated situations\n\t\tif(typeof got==expectedType){\n\t\t\treturn expectedType;\n\t\t}\n\n\t\tvar errStr=(typeof falseOrCaller=='string' ? falseOrCaller+'() e' : 'E') +\"xpected \";\n\t\tvar gotType=varType(got);\n\t\tswitch(varType(expectedType)){\n\t\t\tcase 'string':\n\t\t\t\texpectedType=lookup[expectedType] || expectedType;\n\t\t\t\tif(gotType == expectedType || expectedType=='any'){\n\t\t\t\t\t// console.log(\"SAMESAMESAME - returning\");\n\t\t\t\t\treturn gotType;\n\t\t\t\t}else if(expectedType=='primitive'){ //shortcut to check if primitive\n\t\t\t\t\tif(isPrimitive(got)){\n\t\t\t\t\t\t// console.log('PRIMITIVE success');\n\t\t\t\t\t\treturn gotType;\n\t\t\t\t\t}\n\t\t\t\t\t// console.log('PRIMITIVE but failed',gotType,typeof gotType);\n\t\t\t\t}else if(expectedType.substring(0,1)=='<'){\n\t\t\t\t\tif(gotType=='object'){\n\t\t\t\t\t\tvar name=expectedType.substring(1,expectedType.length-1);\n\n\t\t\t\t\t\t//Check all the constructors along the proto chain\n\t\t\t\t\t\tvar self=got,selves=[];\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tif(self.constructor.name==name)\n\t\t\t\t\t\t\t\treturn expectedType; //NOTE: returns the passed in string WITH '<', ie. <ClsName>\n\t\t\t\t\t\t\tselves.push(self);\n\t\t\t\t\t\t\tself=self.__proto__;\n\t\t\t\t\t\t\tif(!self.__proto__ || self.constructor==self.__proto__.constructor)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// else\n\t\t\t\t\t\t// console.log(`WRONG OBJECT:${got.constructor.name}!=${name}`);\n\t\t\t\t} \n\t\t\t\t//else{ console.log(\"NOT THE SAME -\",expectedType,gotType,gotType == expectedType,got);}\n\n\t\t\t//2019-12-09: DO NOT allow String object when checking for 'string' since many native functions \n\t\t\t//will fail if given String() when expecting string\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'array':\n\t\t\t\tvar goodType=expectedType.find(t=>checkType(t,got,true))\n\t\t\t\tif(goodType)\n\t\t\t\t\treturn goodType;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\tcase 'function':\n\t\t\t\ttry{\n\t\t\t\t\tif(got instanceof expectedType)\n\t\t\t\t\t\treturn expectedType.constructor.name;\n\t\t\t\t\tbreak;\n\t\t\t\t}catch(err){\n\t\t\t\t\t_log.error(err);\n\t\t\t\t\t//2019-11-28: It seems BetterLog instances fail here\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t_log.throw(\"BUGBUG: checkType() expected arg#1 to be string/array/object/function, got:\",logVar(expectedType));\n\t\t}\n\t\tif(falseOrCaller===true)\n\t\t\treturn false;\n\t\telse{\n\t\t\tlet entry=_log.makeTypeError(expectedType,got)\n\t\t\t\t.setOptions({printFunc:true})\n\t\t\t\t.changeWhere(1)//1==remove this line from the stack\n\t\t\tentry.func=falseOrCaller;\n\t\t\tentry.throw();\n\t\t}\n\t}\n\n\n\n\tfunction checkTypes(expArr,gotArr, falseOrCaller){\n\t\tif(varType(expArr)!='array')\n\t\t\t_log.throwType(\"arg #1 to be an array\",expArr);\n\t\tswitch(varType(gotArr)){\n\t\t\tcase 'object':\n\t\t\t\tgotArr=Object.values(gotArr); //so we can pass 'arguments'. NOTE: that it only contains explicitly passed\n\t\t\t\t\t\t\t\t\t\t\t  //args, not default values or omitted\n\t\t\tcase 'array':\n\t\t\t\t//It's important we don't alter the array, in case it's used again\n\t\t\t\tgotArr=[].concat(gotArr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_log.throw(\"BUGBUG: checkTypes() expected arg#2 to be an array, got:\",logVar(gotArr));\n\t\t}\n\n\t\tvar diff=expArr.length-gotArr.length\n\t\tif(diff>0){\n\t\t\t//Fill second array with undefined (needed when passing 'arguments' where some where omitted. NOTE: default values\n\t\t\t//are not included in arguments object)\n\t\t\tgotArr.push.apply(gotArr,new Array(diff));\n\t\t}else if(diff<0){\n\t\t\t//splice second array, ie. we only check as far as we've been told\n\t\t\tgotArr.splice(expArr.length,Math.abs(diff));\n\n\t\t}\n\n\t\ttry{\n\t\t\tvar i, gotTypes=[];\n\t\t\tfor(i=0;i<expArr.length;i++){\n\t\t\t\tgotTypes.push(checkType(expArr[i],gotArr[i],false)); //false==throw\n\t\t\t}\n\t\t\treturn gotTypes;\n\n\t\t}catch(err){\n\t\t\tif(falseOrCaller===true)\n\t\t\t\treturn false;\n\t\t\telse{\n\t\t\t\ttry{\n\t\t\t\t\t// err.message=(typeof falseOrCaller=='string' ? falseOrCaller+'() a' : 'A')+'rg #'+(i+1)+': '+err.message\n\t\t\t\t\t// throw(err);\n\t\t\t\t\tvar BLE=_log.makeError(err);\n\t\t\t\t\tBLE.msg=(typeof falseOrCaller=='string' ? falseOrCaller+'() a' : 'A')+'rg #'+(i+1)+': '+BLE.msg;\n\t\t\t\t\tBLE.changeWhere(1); //remove another line from the stack\n\t\t\t\t}catch(e){\n\t\t\t\t\tconsole.error(\"BUGBUG checkTypes(): something was wrong with <BetterLogEntry>:\",e,typeof BLE,BLE);\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t\tthrow BLE;\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t* @param object obj \tAny object\n\t* @param object types \tKeys are same as obj, values are expected types (string or array or strings)\n\t*\n\t* @throws TypeError \tIf args passed to this func is wrong\n\t* @throws TypeError \t@see $falseOrCaller\n\t* @return object|false\n\t*/\n\tfunction checkProps(obj,types,falseOrCaller){\n\t\tif(!checkType('object',types,true)) \n\t\t\t_log.makeError(\"BUGBUG: checkProps expects arg#2 to be an object, got:\",types).throw(\"TypeError\");\n\t\t\n\t\ttry{\n\t\t\tcheckType('object',obj);\n\t\t\tvar key;\n\t\t\tfor(key in types){\n\t\t\t\ttry{\n\t\t\t\t\ttypes[key]=checkType(types[key],obj[key],false); //false==>throw or return type\n\t\t\t\t}catch(err){\n\t\t\t\t\tif(falseOrCaller===true){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar msg=` prop '${key}'`;\n\t\t\t\t\tif(obj.hasOwnProperty(key)){\n\t\t\t\t\t\tmsg='Bad'+msg+': '+logVar(obj[key]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg='Missing'+msg;\n\t\t\t\t\t}\n\t\t\t\t\tif(falseOrCaller){\n\t\t\t\t\t\tmsg=falseOrCaller+'(): '+msg;\n\t\t\t\t\t}\n\t\t\t\t\t_log.makeError(msg,err).throw();\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn types;\n\t\t}catch(ble){\n\t\t\tble.changeWhere(1).throw();\n\t\t}\n\t}\n\n\n\n\n\t/*\n\t* Check if a variable contains information, ie. everything except: undefined, null, empty string,\n\t* empty object, empty array\n\t*\n\t* @param any v\n\t*\n\t* @flags ...considerEmpty \tSeveral things can be considered empty or not. By default none\n\t*\t\t\t\t\t\t\tof them are, but you can change this by passing one or more of \n\t*\t\t\t\t\t\t\tthem as args, or pass '*' to consider them all empty. Available\n\t*\t\t\t\t\t\t\titems are:\n\t*\t\t\t\t\t\t\t\t\t0, null, false\n\t*\t\t\t\t\t\t\t\t\t\t\t\n\t* Note: String that match /^\\s*$/ are also considered empty\n\t*\n\t* @return boolean\n\t*/\n\tfunction isEmpty(v,...considerEmpty){\n\t\t\n\t\tlet t= varType(v);\n\t\tswitch(t){\n\t\t  //Objects and arrays are considered empty if they don't have any items\n\t\t\tcase 'nodelist':\n\t\t\tcase 'array':\n\t\t\t\treturn (v.length ? false : true);\n\n\t\t\tcase 'object':\n\t\t\t\treturn (Object.keys(v).length ? false : true);\n\n\t\t  //Undefined has no informational value and is by definition not anything\n\t\t\tcase 'undefined':\n\t\t\t\treturn true;\n\n\t\t  //Strings with only whitespace characters are considered empty\n\t\t  \tcase 'string':\n\t\t  \t\treturn (!v || v.match(/^\\s*$/) ? true : false);\n\n\t\t  //Here we have an option, by default zero, null and false are NOT considered empty...\n\t\t  \tcase 'boolean':\n\t\t  \tcase 'number':\n\t\t  \tcase 'null':\n\t\t  \t\tif(v)\n\t\t  \t\t\treturn false;\n\t\t  \t\tif(considerEmpty.includes('*')||considerEmpty.includes(v))\n\t\t  \t\t\treturn true;\n\t\t  \t\telse\n\t\t  \t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn (v ? false : true)\n\t\t}\n\t}\n\n\n\t\t\n\tfunction sameValue(a,b){\n\t// _log.traceFunc(arguments,'sameValue');\n\t\tif(typeof a!=typeof b)\n\t\t\treturn false;\n\t\t\n\t\tif(a===b)\n\t\t\treturn true;\n\n\t\tif(a===null || b===null)\n\t\t\treturn false; //if both were null, they'd return true ^^, now only one is, which means !=\n\t\t\n\t\tswitch(varType(a)){\n\t\t\tcase 'number':\n\t\t\tcase 'string':\n\t\t\tcase 'boolean':\n\t\t\tcase 'node':\n\t\t\tcase 'function':\n\t\t\tcase 'undefined':\n\t\t\t\treturn false; //since we tried ^^, we know they're not the same\n\n\t\t\tcase 'array'://Order and values are important\n\t\t\t\tif(a.length!=b.length)\n\t\t\t\t\treturn false;\n\t\t\t\treturn stringifySafe(a)==stringifySafe(b); \n\t\t\t\n\t\t\tcase 'object'://Order could have changed, without properties having changed... still same value\n\t\t\t\t//As a fast first check, just like with array ^^, check that we have the same number of keys\n\t\t\t\tvar aKeys=Object.keys(a), bKeys=Object.keys(b);\n\t\t\t\tif(aKeys.length!=bKeys.length)\n\t\t\t\t\treturn false;\n\n\t\t\t\t//Then check that the keys are the same (sorting first since order doesn't matter here)\n\t\t\t\taKeys.sort();\n\t\t\t\tbKeys.sort();\n\t\t\t\tif(!sameValue(aKeys,bKeys))\n\t\t\t\t\treturn false;\n\n\t\t\t\t//Finally compare every value\n\t\t\t\treturn aKeys.every(key=>a[key]===b[key])\n\t\t\t\n\n\t\t\tcase 'nodelist':\n\t\t\t\tif(a.length!=b.length)\n\t\t\t\t\treturn false;\n\t\t\t\tfor(let i=a.length-1; i>=0;i--){\n\t\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/*\n\t* @return bool\n\t*/\n\tfunction compare(a,operator,b,c){\n\t\treturn getCompareFunc(operator)(a,b,c);\n\t}\n\tcompare.operators=['===','==','!=','!','!==','<','>','<=','>=','in','between','startsWith','endsWith','contains','regexp']\n\tcompare.isOperator=(operator)=>compare.operators.includes(operator);\n\tcompare.startsWithOperator=(string)=>{\n\t\tif(typeof string!='string'){\n\t\t\treturn undefined;\n\t\t}\n\t\treturn compare.operators.find(op=>string.indexOf(op)==0);\n\t}\n\t/*\n\t* @return [operator,rest of string turned into real value]\n\t*/\n\tcompare.splitOnOperator=(string)=>{\n\t\tlet op=compare.startsWithOperator(string)\n\t\tif(op)\n\t\t\treturn [op,stringToPrimitive(string.substr(op.length))]\n\t\telse\n\t\t\treturn [undefined,string];\n\t}\n\tfunction getCompareFunc(operator){\n\t\tswitch(operator){\n\t\t\tcase 'undefined':\n\t\t\tcase undefined:\n\t\t\tcase '===' : return (a,b)=>a===b;\n\t\t\tcase '==' : return (a,b)=>a==b;\n\t\t\tcase '!=' :\n\t\t\tcase '!' : return (a,b)=>a!=b;\n\t\t\tcase '!==' : return (a,b)=>a!==b;\n\t\t\tcase '<' : return (a,b)=>a<b;\n\t\t\tcase '>' : return (a,b)=>a>b;\n\t\t\tcase '<=' : return (a,b)=>a<=b;\n\t\t\tcase '>=' : return (a,b)=>a>=b;\n\t\t\tcase 'in' : return (a,b)=>(Array.isArray(b) ? b : [b]).includes(a);\n\t\t\tcase 'between' : return (a,b,c)=>typeof a=='number' && a>=b && a<=c;\n\t\t\tcase 'startsWith' : return (a,b)=>typeof a=='string' && a.startsWith(b);\n\t\t\tcase 'endsWith' :return (a,b)=>typeof a=='string' && a.endsWith(b);\n\t\t\tcase 'contains' : return (a,b)=>typeof a=='string' && a.indexOf(b)>-1;\n\t\t\tcase 'regexp' : return (a,b)=>typeof a=='string' && a.search(b)>-1;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown operator: \"+logVar(operator));\n\t\t}\n\t}\n\n\n\n\n\t/*\n\t* Check if a var is primitive or not\n\t*\n\t* NOTE: null is an object in javascript, but we're including it as a primitive as it can be considered 'not complex' \n\t* \t\tand can easily be written to a log, file or stream without formating/encoding. \n\t*\n\t* @param any x\n\t*\n\t* @return boolean\n\t*/\n\tfunction isPrimitive(x){\n\t\tif(x===null)\n\t\t\treturn true\n\t\tswitch(typeof x){\n\t\t\tcase 'string':\n\t\t\tcase 'number':\n\t\t\tcase 'boolean':\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/*\n\t* Check if all values inside an array or object are primitives\n\t*\n\t* @param any x\n\t*\n\t* @return boolean\n\t*/\n\tfunction allPrimitive(x){\n\t\tif(isPrimitive(x))\n\t\t\treturn true;\n\n\t\tswitch(varType(x)){\n\t\t\tcase 'object':\n\t\t\t\tx=Object.values(x);\n\t\t\tcase 'array':\n\t\t\t\treturn x.every(isPrimitive);\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\n\t/*\n\t* Check if a string is a representation of a native javascript value, eg. true/false\n\t*\n\t* @param primitive str \t\tA primitive or a string representing a primitive\n\t* \n\t* @throw <ble TypeError>\n\t*\n\t* @return primitive\n\t*/\n\tfunction stringToPrimitive(str){ \n\t\tif(typeof str!='string'){\n\t\t\tif(!isPrimitive(str))\n\t\t\t\tcX.makeTypeError('string or primitive',str).throw();\n\t\t\treturn str;\n\t\t}\n\n\t\tswitch(str){\n\t\t\tcase 'true':return true;\n\t\t\tcase 'false':return false;\n\t\t\tcase 'null':return null;\n\t\t\tcase 'undefined':return undefined;\n\t\t\tcase '':return '';\n\t\t}\n\n\t\tlet i = stringToNumber(str,true); //true==no throw, we're just testing\n\n\t\treturn (i===undefined ? str : i);\n\t}\n\n\t/*\n\t* Turn a string number with sign into an actual number, eg. '+1'=>1 '-3'=>-3, optionally\n\t* using it to increment a current number\n\t*\n\t* @param string \tchange\n\t* @param boolean \tnoThrow \tIf true, return undefined if not a number\n\t*\n\t* @throw Error \t\t\t\t\tIf not a number. Or @see $noThrow\n\t* @return number \t\t\t\tOr @see $noThrow\n\t*/\n\tfunction stringToNumber(str,noThrow=false){\n\t\tswitch(typeof str){\n\t        case 'number':\n\t            return str;\n\t        case 'string':\n\t\t\t\tlet number=Number(str);\n\t\t\t\tif(typeof number=='number' && !isNaN(number))\n\t\t\t\t\treturn number;\n\n\t            //don't break here, let it fall through to bad value vv\n\t        default:\n\t        \tif(noThrow)\n\t        \t\treturn undefined\n\t        \telse\n\t            \tthrow new Error(\"Bad value, expected a numerical string with an optional sign, got: \"+ vX.logVar(str));\n\t    }\n\t}\n\n\t/*\n\t* Force a specific type, eg. turn \"1\" into 1\n\t*\n\t* @param string \texpectedType\n\t* @param mixed \t\tvalue\n\t*\n\t* @throw TypeError\n\t* @return mixed\n\t*/\n\tfunction forceType(expectedType,value){\n\t\tcheckType('string',expectedType);\n\t\tvar gotType=varType(value);\n\t\tswitch(expectedType){\n\t\t\tcase gotType:\n\t\t\t\treturn value;\n\t\t\tcase 'undefined':\n\t\t\tcase 'null':\n\t\t\t\t//If we got the string 'undefined', return undefined etc\n\t\t\t\tif(typeof value=='string' && value==expectedType)\n\t\t\t\t\treturn value=='null' ? null : undefined;\n\n\t\t\t\t//If we got any empty value, return undefined etc\n\t\t\t\tif(empty(value))\n\t\t\t\t\treturn expectedType=='null' ? null : undefined;\n\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\tswitch(value){\n\t\t\t\t\tcase 'true':\n\t\t\t\t\tcase 'TRUE':\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 'false':\n\t\t\t\t\tcase 'FALSE':\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn value ? true : false;\n\t\t\t\t}\n\t\t\tcase 'number':\n\t\t\t\tvar num=Number(value); //this will convert booleans and strings, but not null, undefined etc...\n\t\t\t\tif(!isNaN(num))\n\t\t\t\t\treturn num;\n\t\t\t\t//If we didn't make a number, throw at bottom...\n\n\t\t\tcase 'string':\n\t\t\t\tif(gotType=='array'||gotType=='object')\n\t\t\t\t\treturn tryJsonStringify(value);\n\n\t\t\t\treturn String(value);\n\t\t\tcase 'array':\n\t\t\t\t//turn objects with numerical keys into arrays... \n\t\t\t\tif(gotType=='object'){\n\t\t\t\t\tif(Object.keys(value).every(Number.isInteger))\n\t\t\t\t\t\treturn Object.values(value);\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak; //any other type of object is bad\n\t\t\t\t}\n\t\t\t\t//don't break so we can try for json vv\n\t\t\tcase 'object':\n\t\t\t\tlet x=tryJsonParse(value);\n\t\t\t\tif(varType(x)==expectedType)\n\t\t\t\t\treturn x\n\t\t\t\t\n\t\t\t\t//Any other scenario is bad\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'promise':\n\t\t\t\treturn Promise.resolve(value);\n\t\t\tcase 'error':\n\t\t\t\treturn new Error(String(value));\n\t\t\tcase 'function':\n\t\t\t\tthrow new Error(\"Cannot force \"+gotType+\" to be a function, noone can...\");\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Arg #1 should be a return value of helper.varType(), got: '+expectedType);\n\t\t}\n\t\tthrow new TypeError(\"Expected \"+expectedType+\", got \"+logVar(value));\n\t}\n\n\n\t/*\n\t* This function attempts to parse a JSON string without throwing errors\n\t*\n\t* @param any x \n\t* @param bool onlyReturnObject\tDefault false. If true, this function will only return @x if it was successfully parsed into\n\t*\t\t\t\t\t\t\t\tan object, or if it was an object to begin with\n\t*\n\t* @return object|undefined\n\t*/\n\n\t\t\t\t\t\t\t \n\tfunction tryJsonParse(x, onlyReturnObject=false){\n\t\tif(typeof x=='object')\n\t\t\treturn x;\n\n\t\ttry{\n\t\t\treturn JSON.parse(x);\n\t\t} catch(e){}\n\n\n\n\t\tif(typeof x=='string'){\n\t\t\t//Try removing comments, and if something changes take that as a sign and run this\n\t\t\t//function again\n\t\t\tvar stripped=stripComments(x);\n\t\t\tif(stripped!=x){\n\t\t\t\tif(stripped==''){\n\t\t\t\t\t_log.note(\"Was the whole string a comment? Because BetterUtil.stripComments() thought it was:\",x);\n\t\t\t\t}else{\n\t\t\t\t\treturn tryJsonParse(stripped);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(x.includes(':')){ \n\t\t\t\tlet wrapper=x.substr(0,1)+x.substr(-1); //NOTE substring() and substr() don't work the same!\n\t\t\t\tif(wrapper=='{}'||wrapper=='[]'){\n\t\t\t\t\tvar warn=_log.makeEntry('warn',\"This is probably a poorly formated JSON string:\",x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(onlyReturnObject && (!x || typeof x !='object')){\n\t\t\tif(warn){warn.exec();}else{_log.debug('Not a JSON string: ', x);} //don't debug if we've already warned\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn x\n\t\t}\n\t}\n\n\n\t/*\n\t* This function attempts to stringify any value, checking first if it is already stringified.\n\t* @param any x\n\t* @return string \tA string that can be passed to JSON.parse() (possibly an empty string)\n\t*/\n\n\t\t\t\t\t\t\t \n\tfunction tryJsonStringify(x){\t\n\t\ttry{\n\t\t\tJSON.parse(x)\n\t\t\treturn x; //x is already a JSON string\n\t\t} catch(e){\n\t\t\ttry{\n\t\t\t\treturn JSON.stringify(x)||''\n\t\t\t}catch(e){\n\t\t\t\treturn ''\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/*\n\t* Turn object into JSON-like string, ie. not valid JSON just something that looks good to log\n\t*/\n\tfunction stringifySafe(obj){\n\t\ttry{\t\t\n\t\t\t//Attempt just to use JSON. This can fail eg. if any circular refs exist (usually true in browser)\n\t\t\treturn JSON.stringify(obj);\n\t\t}catch(err){\n\t\t\tif(err.message.indexOf('circular structure')>-1){\n\t\t\t\t//In case of circ struct, just attempt to get a little bit of info about the first level\n\t\t\t\t//structure... so we have something to log\n\t\t\t\ttry{\n\t\t\t\t\tvar x='';\n\t\t\t\t\tObject.entries(obj).forEach(([key,value])=>{\n\t\t\t\t\t\tx+=key+':';\n\t\t\t\t\t\tswitch(varType(value)){\n\t\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t\tx+=value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tx+=Object.prototype.toString.call(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx+=','\n\t\t\t\t\t})\n\t\t\t\t\tif(varType(obj)=='array')\n\t\t\t\t\t\tx='['+x+']';\n\t\t\t\t\telse\n\t\t\t\t\t\tx='{'+x+'}';\n\n\t\t\t\t\tthrow 'Failed to stringify (circular structure):'+x\n\t\t\t\t}catch(e){\n\t\t\t\t\terr=e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_log.error(err);\n\t\t\treturn `<err:${err.message}>`\n\t\t}\n\t}\n\n\n\n\n\tfunction copy(x){\n\t\tswitch(varType(x)){\n\t\t\tcase 'object':\n\t\t\tcase 'array':\n\t\t\t\treturn JSON.parse(JSON.stringify(x));\n\t\t\tcase 'node':\n\t\t\t\treturn x.cloneNode(true);\n\t\t\tcase 'nodelist':\n\t\t\t\treturn Array.from(x,node=>node.cloneNode(true));\n\t\t\tdefault:\t\n\t\t\t\treturn x;\n\t\t}\n\t}\n\n\n\n\tfunction instanceOf(expected,gotObj,returnFalse){\n\t\ttry{checkType(['function','object'],expected);}\n\t\tcatch(err){\n\t\t\tthrow new TypeError(\"BUGBUG instanceOf() expected arg #1 to be a constructor or object, got: \"+logVar(expected));\n\t\t}\n\n\t\tcheckType('object',gotObj);\n\t\t\n\t\tif(gotObj instanceof expected)\n\t\t\treturn gotObj.constructor;\n\t\telse if(returnFalse)\n\t\t\treturn false;\n\t\telse{\n\t\t\tvar who=typeof expected=='function' ? expected.name : expected.constructor.name;\n\t\t\tthrow new TypeError(\"Expected instance of \"+who+\", got: \"+gotObj.constructor.name);\n\t\t}\n\t}\n\n\n\n\tvar stripper=new RegExp(/(\\/\\*[\\w\\'\\s\\r\\n\\*]*\\*\\/)|(\\/\\/[\\w\\s\\']*)|(\\<![\\-\\-\\s\\w\\>\\/]*\\>)/mg)\n\tfunction stripComments(str){\n\t\tcheckType('string',str);\n\t\treturn str.replace(stripper,'');\n\t}\n\n\n\n\n\t//Methods to export\n\treturn _exports \n\n\n}\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./util/common/vars.util.js?");

/***/ })

/******/ });